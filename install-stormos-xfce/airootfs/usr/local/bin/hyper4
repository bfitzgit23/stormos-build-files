#!/usr/bin/env python3
"""
Tokyo Night Qt5 Panel Bar - Dark Night Edition
Complete Xfce4 panel replacement with enhanced dark night theme
Featuring subtle animations, night sky gradients, and improved visual effects
"""
import sys
import os
import time
import subprocess
import threading
import re
import json
import signal
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QHBoxLayout, 
                            QVBoxLayout, QLabel, QPushButton, QMenu, QSystemTrayIcon,
                            QFrame, QToolButton, QStyle, QAction, QScrollArea,
                            QDialog, QSlider, QCheckBox, QComboBox, QGroupBox,
                            QFormLayout, QSpinBox, QColorDialog, QTabWidget,
                            QSystemTrayIcon, QSizePolicy, QListWidget, QListWidgetItem,
                            QLineEdit, QMessageBox, QInputDialog)
from PyQt5.QtCore import Qt, QTimer, QPoint, QSize, pyqtSignal, QThread, QSettings, QEvent, QPropertyAnimation, QEasingCurve, QObject, QRect
from PyQt5.QtGui import (QIcon, QFont, QPalette, QColor, QPainter, QLinearGradient, 
                        QFontDatabase, QPixmap, QPen, QWheelEvent, QBrush, QRadialGradient, QKeySequence, QCursor)
# Try to import QX11Info from the correct module
try:
    from PyQt5.QtX11Extras import QX11Info
    HAS_X11 = True
except ImportError:
    try:
        from PyQt5.QtGui import QX11Info
        HAS_X11 = True
    except ImportError:
        HAS_X11 = False
        print("Warning: QX11Info not available. Some X11-specific features may be disabled.")
# Enhanced Dark Night Color Palette
class TokyoNight:
    # Base colors - deeper, more night-like
    BACKGROUND = "#0d0f1a"  # Deeper dark blue-black
    FOREGROUND = "#c0caf5"
    # Content colors
    COMMENT = "#3a415e"  # Slightly lighter comment color
    SELECTION = "#1a2332"  # Darker selection
    # Ansi colors - adjusted for night theme
    BLACK = "#0a0b14"  # Almost pure black
    RED = "#f7768e"
    GREEN = "#9ece6a"
    YELLOW = "#e0af68"
    BLUE = "#5a7fc7"  # Slightly muted blue
    PURPLE = "#9b7fc7"  # Muted purple
    CYAN = "#5abfcf"  # Muted cyan
    WHITE = "#a9b1d6"
    # Bright colors - adjusted for night theme
    BRIGHT_BLACK = "#2a3146"  # Darker bright black
    BRIGHT_RED = "#f7768e"
    BRIGHT_GREEN = "#9ece6a"
    BRIGHT_YELLOW = "#e0af68"
    BRIGHT_BLUE = "#5a7fc7"  # Muted bright blue
    BRIGHT_PURPLE = "#9b7fc7"  # Muted bright purple
    BRIGHT_CYAN = "#5abfcf"  # Muted bright cyan
    BRIGHT_WHITE = "#c0caf5"
    # Additional accents - night-themed
    ORANGE = "#ff9e64"
    PINK = "#ff007c"
    TEAL = "#2ac3de"
    # Night sky gradient colors
    NIGHT_TOP = "#0a0b14"  # Deep space black
    NIGHT_BOTTOM = "#1a1b26"  # Tokyo night background
    NIGHT_HIGHLIGHT = "#1f2335"  # Subtle highlight
    # Moon and stars colors
    MOON_GLOW = "#e0e6ff"  # Soft moon glow
    STAR_COLOR = "#ffffff"  # White stars
    NEBULA = "#3a415e"  # Nebula clouds

@dataclass
class Application:
    name: str
    command: str
    icon: str = "üöÄ"
    args: str = ""  # Additional arguments for the command
    workspace: int = -1  # -1 means current workspace, 0+ means specific workspace

class GlobalKeyHandler(QObject):
    """Global key handler for volume keys"""
    def __init__(self, volume_widget):
        super().__init__()
        self.volume_widget = volume_widget
        # Install event filter on the application
        QApplication.instance().installEventFilter(self)
        print("Global key handler installed")

    def eventFilter(self, obj, event):
        """Filter events to catch global key presses"""
        if event.type() == QEvent.KeyPress:
            key = event.key()
            # Handle volume keys globally
            if key == Qt.Key_VolumeUp:
                print("Volume up key pressed")
                new_volume = min(100, self.volume_widget.current_volume + 5)
                self.volume_widget.set_volume(new_volume)
                return True
            elif key == Qt.Key_VolumeDown:
                print("Volume down key pressed")
                new_volume = max(0, self.volume_widget.current_volume - 5)
                self.volume_widget.set_volume(new_volume)
                return True
            elif key == Qt.Key_VolumeMute:
                print("Volume mute key pressed")
                self.volume_widget.toggle_mute_event(None)
                return True
            # Also handle multimedia keys with different key codes
            if hasattr(event, 'nativeScanCode'):
                scan_code = event.nativeScanCode()
                # Common scan codes for volume keys (may vary by keyboard)
                if scan_code in [122, 123]:  # Volume up
                    print(f"Volume up key pressed (scan code: {scan_code})")
                    new_volume = min(100, self.volume_widget.current_volume + 5)
                    self.volume_widget.set_volume(new_volume)
                    return True
                elif scan_code in [121, 122]:  # Volume down
                    print(f"Volume down key pressed (scan code: {scan_code})")
                    new_volume = max(0, self.volume_widget.current_volume - 5)
                    self.volume_widget.set_volume(new_volume)
                    return True
                elif scan_code in [172, 173]:  # Mute
                    print(f"Volume mute key pressed (scan code: {scan_code})")
                    self.volume_widget.toggle_mute_event(None)
                    return True
        return super().eventFilter(obj, event)

class NightSkyWidget(QWidget):
    """Widget with animated night sky background"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.stars = []
        self.animation_timer = QTimer()
        self.animation_timer.timeout.connect(self.update_stars)
        self.animation_timer.start(100)  # Update every 100ms
        self.generate_stars()

    def generate_stars(self):
        """Generate random stars for the night sky"""
        import random
        width = self.width() if self.width() > 0 else 1920
        height = self.height() if self.height() > 0 else 40
        # Create stars with varying sizes and brightness
        for _ in range(50):  # Create 50 stars
            x = random.randint(0, width)
            y = random.randint(0, height)
            size = random.uniform(0.5, 2.0)
            brightness = random.uniform(0.3, 1.0)
            twinkle_speed = random.uniform(0.01, 0.05)
            self.stars.append({
                'x': x, 'y': y, 'size': size, 
                'brightness': brightness, 
                'twinkle_speed': twinkle_speed,
                'phase': random.uniform(0, 2 * 3.14159)  # Random phase
            })

    def update_stars(self):
        """Update star brightness for twinkling effect"""
        import math
        for star in self.stars:
            star['phase'] += star['twinkle_speed']
            star['current_brightness'] = star['brightness'] * (0.5 + 0.5 * math.sin(star['phase']))
        self.update()

    def paintEvent(self, event):
        """Paint the night sky with stars"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        # Create night sky gradient
        gradient = QLinearGradient(0, 0, 0, self.height())
        gradient.setColorAt(0, QColor(TokyoNight.NIGHT_TOP))
        gradient.setColorAt(0.7, QColor(TokyoNight.NIGHT_BOTTOM))
        gradient.setColorAt(1, QColor(TokyoNight.NIGHT_HIGHLIGHT))
        painter.fillRect(self.rect(), gradient)
        # Draw stars
        for star in self.stars:
            color = QColor(TokyoNight.STAR_COLOR)
            color.setAlphaF(star.get('current_brightness', star['brightness']))
            painter.setPen(QPen(color, star['size']))
            painter.drawPoint(star['x'], star['y'])
        # Draw nebula clouds
        nebula_brush = QBrush(QColor(TokyoNight.NEBULA))
        nebula_brush.setStyle(Qt.Dense6Pattern)
        painter.setBrush(nebula_brush)
        painter.setPen(Qt.NoPen)
        painter.setOpacity(0.1)
        painter.drawEllipse(100, 10, 200, 30)
        painter.drawEllipse(500, 5, 150, 20)
        painter.drawEllipse(900, 15, 180, 25)

class WirelessNetworkDialog(QDialog):
    """Dialog for managing wireless network connections"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
        self.scan_networks()

    def setup_ui(self):
        self.setWindowTitle("Wireless Networks")
        self.setFixedSize(500, 600)
        self.setStyleSheet(f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QListWidget {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 4px;
                padding: 5px;
            }}
            QListWidget::item {{
                padding: 8px;
                border-radius: 3px;
            }}
            QListWidget::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
            QLabel {{
                color: {TokyoNight.FOREGROUND};
            }}
            QLineEdit {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                padding: 5px;
                border-radius: 3px;
            }}
            QCheckBox {{
                color: {TokyoNight.FOREGROUND};
            }}
            QGroupBox {{
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                background: {TokyoNight.NIGHT_BOTTOM}80;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }}
        """)
        layout = QVBoxLayout()
        # Title
        title = QLabel("Wireless Networks")
        title.setStyleSheet(f"font-size: 14pt; font-weight: bold; color: {TokyoNight.CYAN};")
        layout.addWidget(title)
        # Network list
        self.network_list = QListWidget()
        self.network_list.itemDoubleClicked.connect(self.connect_to_network)
        layout.addWidget(self.network_list)
        # Buttons
        button_layout = QHBoxLayout()
        self.refresh_btn = QPushButton("Û∞ëê Refresh")
        self.refresh_btn.clicked.connect(self.scan_networks)
        button_layout.addWidget(self.refresh_btn)
        self.connect_btn = QPushButton("Û∞ñ© Connect")
        self.connect_btn.clicked.connect(self.connect_to_selected)
        button_layout.addWidget(self.connect_btn)
        self.disconnect_btn = QPushButton("Û∞ñ™ Disconnect")
        self.disconnect_btn.clicked.connect(self.disconnect_current)
        button_layout.addWidget(self.disconnect_btn)
        button_layout.addStretch()
        self.close_btn = QPushButton("Close")
        self.close_btn.clicked.connect(self.close)
        button_layout.addWidget(self.close_btn)
        layout.addLayout(button_layout)
        # Connection details section
        self.details_group = QGroupBox("Connection Details")
        details_layout = QFormLayout()
        self.ssid_label = QLabel("--")
        self.signal_label = QLabel("--")
        self.security_label = QLabel("--")
        self.status_label = QLabel("--")
        details_layout.addRow("SSID:", self.ssid_label)
        details_layout.addRow("Signal:", self.signal_label)
        details_layout.addRow("Security:", self.security_label)
        details_layout.addRow("Status:", self.status_label)
        self.details_group.setLayout(details_layout)
        layout.addWidget(self.details_group)
        # Password input for secured networks
        self.password_group = QGroupBox("Network Password")
        password_layout = QVBoxLayout()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.password_input.setPlaceholderText("Enter network password")
        password_layout.addWidget(self.password_input)
        self.show_password_check = QCheckBox("Show password")
        self.show_password_check.stateChanged.connect(self.toggle_password_visibility)
        password_layout.addWidget(self.show_password_check)
        self.password_group.setLayout(password_layout)
        self.password_group.setVisible(False)
        layout.addWidget(self.password_group)

        self.setLayout(layout)
        # Update connection details when selection changes
        self.network_list.itemSelectionChanged.connect(self.update_connection_details)

    def toggle_password_visibility(self, state):
        """Toggle password visibility"""
        if state == Qt.Checked:
            self.password_input.setEchoMode(QLineEdit.Normal)
        else:
            self.password_input.setEchoMode(QLineEdit.Password)

    def scan_networks(self):
        """Scan for available wireless networks"""
        self.network_list.clear()
        try:
            # Try to get wireless networks using nmcli
            result = subprocess.run(
                "nmcli -t -f SSID,SIGNAL,SECURITY dev wifi list",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                networks = []
                for line in result.stdout.splitlines():
                    parts = line.split(':')
                    if len(parts) >= 3:
                        ssid = parts[0]
                        signal = parts[1]
                        security = parts[2]
                        # Skip empty SSIDs
                        if not ssid:
                            continue
                        networks.append({
                            'ssid': ssid,
                            'signal': signal,
                            'security': security,
                            'connected': False
                        })
                # Check which network is currently connected
                try:
                    current_result = subprocess.run(
                        "nmcli -t -f NAME,TYPE connection show --active | grep wifi",
                        shell=True, capture_output=True, text=True
                    )
                    if current_result.returncode == 0:
                        current_ssid = current_result.stdout.split(':')[0]
                        for network in networks:
                            if network['ssid'] == current_ssid:
                                network['connected'] = True
                except:
                    pass
                # Sort networks by signal strength (descending) and connection status
                networks.sort(key=lambda x: (not x['connected'], -int(x['signal'])))
                # Add networks to the list
                for network in networks:
                    icon = "Û∞ñ©" if network['connected'] else "Û∞ñ™"
                    security_icon = "üîí" if network['security'] else "üîì"
                    item_text = f"{icon} {network['ssid']} {security_icon} ({network['signal']}%)"
                    item = QListWidgetItem(item_text)
                    item.setData(Qt.UserRole, network)
                    if network['connected']:
                        item.setForeground(QColor(TokyoNight.GREEN))
                    self.network_list.addItem(item)
            else:
                # Fallback to iwlist if nmcli fails
                self.scan_with_iwlist()
        except Exception as e:
            print(f"Error scanning networks: {e}")
            # Try fallback method
            self.scan_with_iwlist()

    def scan_with_iwlist(self):
        """Fallback method using iwlist to scan networks"""
        try:
            result = subprocess.run(
                "iwlist scan 2>/dev/null | grep -E 'ESSID|Quality|Encryption key'",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                networks = []
                current_network = {}
                for line in result.stdout.splitlines():
                    if "ESSID" in line:
                        if current_network:
                            networks.append(current_network)
                        ssid = line.split('"')[1] if '"' in line else "Hidden Network"
                        current_network = {'ssid': ssid}
                    elif "Quality" in line:
                        quality = line.split('=')[1].split('/')[0]
                        current_network['signal'] = int(quality)
                    elif "Encryption key" in line:
                        encrypted = "on" in line.split(':')[1]
                        current_network['security'] = "WPA/WPA2" if encrypted else "Open"
                if current_network:
                    networks.append(current_network)
                # Add networks to the list
                for network in networks:
                    security_icon = "üîí" if network.get('security') != "Open" else "üîì"
                    signal = network.get('signal', 0)
                    item_text = f"Û∞ñ™ {network['ssid']} {security_icon} ({signal}%)"
                    item = QListWidgetItem(item_text)
                    item.setData(Qt.UserRole, network)
                    self.network_list.addItem(item)
        except Exception as e:
            print(f"Error with iwlist scan: {e}")
            self.network_list.addItem(QListWidgetItem("Error scanning networks"))

    def update_connection_details(self):
        """Update connection details when selection changes"""
        current_item = self.network_list.currentItem()
        if not current_item:
            return
        network = current_item.data(Qt.UserRole)
        if not network:
            return

        self.ssid_label.setText(network.get('ssid', '--'))
        self.signal_label.setText(f"{network.get('signal', '--')}%")
        self.security_label.setText(network.get('security', '--'))
        status = "Connected" if network.get('connected', False) else "Available"
        self.status_label.setText(status)
        # Show password input for secured networks
        is_secured = network.get('security') and network.get('security') != "Open"
        self.password_group.setVisible(is_secured and not network.get('connected', False))

    def connect_to_selected(self):
        """Connect to the selected network"""
        current_item = self.network_list.currentItem()
        if not current_item:
            return
        self.connect_to_network(current_item)

    def connect_to_network(self, item):
        """Connect to a wireless network"""
        network = item.data(Qt.UserRole)
        if not network:
            return
        ssid = network.get('ssid')
        if not ssid:
            return

        try:
            # Check if already connected
            if network.get('connected', False):
                return
            # Check if network requires password
            is_secured = network.get('security') and network.get('security') != "Open"
            if is_secured:
                password = self.password_input.text()
                if not password:
                    self.password_group.setVisible(True)
                    self.password_input.setFocus()
                    return
                # Try to connect with password using nmcli
                # Method 1: Direct connection
                result = subprocess.run(
                    f"nmcli dev wifi connect '{ssid}' password '{password}'",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode != 0:
                    # Method 2: Create connection first, then connect
                    connection_name = ssid.replace(' ', '_')
                    create_result = subprocess.run(
                        f"nmcli connection add type wifi con-name '{connection_name}' ifname wlan0 ssid '{ssid}' wifi-sec.key-mgmt wpa-psk wifi-sec.psk '{password}'",
                        shell=True, capture_output=True, text=True
                    )
                    if create_result.returncode == 0:
                        # Now connect to the created connection
                        result = subprocess.run(
                            f"nmcli connection up '{connection_name}'",
                            shell=True, capture_output=True, text=True
                        )
                    else:
                        # Method 3: Try with different interface
                        create_result = subprocess.run(
                            f"nmcli connection add type wifi con-name '{connection_name}' ssid '{ssid}' wifi-sec.key-mgmt wpa-psk wifi-sec.psk '{password}'",
                            shell=True, capture_output=True, text=True
                        )
                        if create_result.returncode == 0:
                            result = subprocess.run(
                                f"nmcli connection up '{connection_name}'",
                                shell=True, capture_output=True, text=True
                            )
                if result.returncode != 0:
                    print(f"Failed to connect: {result.stderr}")
                    # Show error message
                    error_msg = result.stderr.strip() if result.stderr else "Connection failed"
                    self.status_label.setText(f"Error: {error_msg}")
                    # Show a more user-friendly error dialog
                    QMessageBox.warning(
                        self, "Connection Failed",
                        f"Failed to connect to {ssid}.\nError: {error_msg}\nPlease check your password and try again."
                    )
                    return
            else:
                # Connect to open network
                result = subprocess.run(
                    f"nmcli dev wifi connect '{ssid}'",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode != 0:
                    print(f"Failed to connect: {result.stderr}")
                    self.status_label.setText(f"Error: {result.stderr.strip()}")
                    # Show a more user-friendly error dialog
                    QMessageBox.warning(
                        self, "Connection Failed",
                        f"Failed to connect to {ssid}.\nError: {result.stderr.strip()}"
                    )
                    return
            # Update status
            self.status_label.setText("Connecting...")
            # Refresh network list after a short delay
            QTimer.singleShot(3000, self.scan_networks)
        except Exception as e:
            print(f"Error connecting to network: {e}")
            self.status_label.setText(f"Error: {str(e)}")
            # Show a more user-friendly error dialog
            QMessageBox.warning(
                self, "Connection Error",
                f"An error occurred while connecting to {ssid}.\nError: {str(e)}"
            )

    def disconnect_current(self):
        """Disconnect from current network"""
        try:
            # Get the active WiFi connection
            result = subprocess.run(
                "nmcli -t -f NAME,TYPE connection show --active | grep wifi",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                connection_name = result.stdout.split(':')[0]
                # Disconnect the specific connection
                result = subprocess.run(
                    f"nmcli connection down '{connection_name}'",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    self.status_label.setText("Disconnected")
                    # Refresh network list after a short delay
                    QTimer.singleShot(2000, self.scan_networks)
                else:
                    print(f"Failed to disconnect: {result.stderr}")
                    self.status_label.setText(f"Error: {result.stderr.strip()}")
                    # Show a more user-friendly error dialog
                    QMessageBox.warning(
                        self, "Disconnection Failed",
                        f"Failed to disconnect from {connection_name}.\nError: {result.stderr.strip()}"
                    )
            else:
                # Try alternative method if no active WiFi connection found
                result = subprocess.run(
                    "nmcli dev disconnect $(nmcli dev status | grep wifi | head -1 | awk '{print $1}')",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    self.status_label.setText("Disconnected")
                    # Refresh network list after a short delay
                    QTimer.singleShot(2000, self.scan_networks)
                else:
                    print(f"Failed to disconnect: {result.stderr}")
                    self.status_label.setText(f"Error: {result.stderr.strip()}")
                    # Show a more user-friendly error dialog
                    QMessageBox.warning(
                        self, "Disconnection Failed",
                        f"Failed to disconnect from WiFi.\nError: {result.stderr.strip()}"
                    )
        except Exception as e:
            print(f"Error disconnecting: {e}")
            self.status_label.setText(f"Error: {str(e)}")
            # Show a more user-friendly error dialog
            QMessageBox.warning(
                self, "Disconnection Error",
                f"An error occurred while disconnecting from WiFi.\nError: {str(e)}"
            )

class NetworkManagerWidget(QWidget):
    """Widget for Network Manager control with wireless network dialog"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()

    def setup_ui(self):
        """Setup the network manager control UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        # Network manager button (clickable to launch network manager)
        self.network_button = QPushButton("Û∞§®")  # Network icon
        self.network_button.setFixedSize(32, 32)
        self.network_button.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        self.network_button.setCursor(Qt.PointingHandCursor)
        self.network_button.setToolTip("Left click: Wireless Networks\nRight click: Network Manager")
        self.network_button.clicked.connect(self.launch_wireless_dialog)
        self.network_button.setContextMenuPolicy(Qt.CustomContextMenu)
        self.network_button.customContextMenuRequested.connect(self.show_network_menu)
        layout.addWidget(self.network_button)

    def launch_wireless_dialog(self):
        """Launch wireless network dialog"""
        try:
            dialog = WirelessNetworkDialog(self)
            dialog.exec_()
        except Exception as e:
            print(f"Failed to launch wireless dialog: {e}")
            # Fallback to network manager
            self.launch_network_manager()

    def show_network_menu(self, position):
        """Show context menu for network options"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        wireless_action = QAction("Û∞ñ© Wireless Networks", self)
        wireless_action.triggered.connect(self.launch_wireless_dialog)
        menu.addAction(wireless_action)
        menu.addSeparator()
        manager_action = QAction("Û∞íì Network Manager", self)
        manager_action.triggered.connect(self.launch_network_manager)
        menu.addAction(manager_action)
        menu.exec_(self.network_button.mapToGlobal(position))

    def launch_network_manager(self):
        """Launch network manager when button is clicked"""
        try:
            # Try nm-connection-editor first (GUI version)
            result = subprocess.run(
                "which nm-connection-editor",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # Check if nm-connection-editor is already running
                result = subprocess.run(
                    "pgrep -f nm-connection-editor",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    # If running, focus it
                    subprocess.run(
                        "wmctrl -a 'Network Connections'",
                        shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                    )
                else:
                    # Launch nm-connection-editor
                    subprocess.Popen(
                        ["nm-connection-editor"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
            else:
                # Fallback to nm-applet
                subprocess.Popen(
                    ["nm-applet"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
        except Exception as e:
            print(f"Failed to launch network manager: {e}")
            # Try alternative command
            try:
                subprocess.Popen(
                    ["nm-applet"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except Exception as e2:
                print(f"Failed to launch nm-applet: {e2}")

class BluetoothManagerWidget(QWidget):
    """Widget for Bluetooth Manager control that launches blueman-manager"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()

    def setup_ui(self):
        """Setup the bluetooth manager control UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        # Bluetooth manager button (clickable to launch bluetooth manager)
        self.bluetooth_button = QPushButton("Û∞ÇØ")  # Bluetooth icon
        self.bluetooth_button.setFixedSize(32, 32)
        self.bluetooth_button.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        self.bluetooth_button.setCursor(Qt.PointingHandCursor)
        self.bluetooth_button.setToolTip("Click to open Bluetooth Manager")
        self.bluetooth_button.clicked.connect(self.launch_bluetooth_manager)
        layout.addWidget(self.bluetooth_button)

    def launch_bluetooth_manager(self):
        """Launch bluetooth manager when button is clicked"""
        try:
            # Check if blueman-manager is available
            result = subprocess.run(
                "which blueman-manager",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # Check if blueman-manager is already running
                result = subprocess.run(
                    "pgrep -f blueman-manager",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    # If running, focus it
                    subprocess.run(
                        "wmctrl -a 'Bluetooth Manager'",
                        shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                    )
                else:
                    # Launch blueman-manager
                    subprocess.Popen(
                        ["blueman-manager"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
            else:
                print("Blueman-manager not found. Please install it with: sudo apt install blueman")
                # Try alternative bluetooth managers
                try:
                    # Try blueberry (alternative)
                    subprocess.Popen(
                        ["blueberry"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                except:
                    # Try gnome-bluetooth
                    subprocess.Popen(
                        ["gnome-bluetooth"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
        except Exception as e:
            print(f"Failed to launch bluetooth manager: {e}")

class VolumeControlWidget(QWidget):
    """Widget for volume control with interactive slider, scroll wheel support, and global key bindings"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_volume = 50
        self.is_muted = False
        self.audio_backend = None
        self.default_sink = None
        self.global_key_handler = None
        self.setup_ui()
        self.detect_audio_backend()
        self.start_volume_monitor()
        # Add global key handler
        self.setup_global_key_handler()

    def setup_global_key_handler(self):
        """Setup global key handler for volume keys"""
        try:
            # Create global key handler
            self.global_key_handler = GlobalKeyHandler(self)
            print("Global volume key handler installed successfully")
        except Exception as e:
            print(f"Failed to setup global key handler: {e}")

    def start_volume_monitor(self):
        """Monitor for volume changes"""
        self.volume_timer = QTimer()
        self.volume_timer.timeout.connect(self.check_system_volume)
        self.volume_timer.start(500)  # Check every 500ms

    def check_system_volume(self):
        """Check current system volume and update display"""
        try:
            volume, muted = self.get_current_volume()
            if volume is not None and (volume != self.current_volume or muted != self.is_muted):
                self.current_volume = volume
                self.is_muted = muted
                self.update_volume_display(volume, muted)
                # Update slider
                self.volume_slider.blockSignals(True)
                self.volume_slider.setValue(volume)
                self.volume_slider.blockSignals(False)
        except Exception as e:
            print(f"Error checking system volume: {e}")

    def get_current_volume(self):
        """Get current volume using pactl"""
        try:
            # Get volume from default sink
            result = subprocess.run(
                ["pactl", "get-sink-volume", "@DEFAULT_SINK@"],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                # Parse volume from output
                import re
                volume_matches = re.findall(r'(\d+)%', result.stdout)
                if volume_matches:
                    volume = int(volume_matches[0])
                    # Check if muted
                    mute_result = subprocess.run(
                        ["pactl", "get-sink-mute", "@DEFAULT_SINK@"],
                        capture_output=True, text=True, timeout=2
                    )
                    muted = (mute_result.returncode == 0 and 
                           "yes" in mute_result.stdout.lower())
                    return volume, muted
        except Exception as e:
            print(f"Volume check error: {e}")
        return None, None

    def setup_ui(self):
        """Setup the volume control UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)

        # Volume icon (clickable to toggle mute)
        self.volume_icon = QLabel("Û∞ïæ")
        self.volume_icon.setStyleSheet(f"""
            padding: 4px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 12pt;
            color: {TokyoNight.FOREGROUND};
        """)
        self.volume_icon.setCursor(Qt.PointingHandCursor)
        self.volume_icon.mousePressEvent = self.volume_icon_mouse_press
        self.volume_icon.setToolTip("Click to toggle mute\nScroll to adjust volume\nVolume keys work globally")
        layout.addWidget(self.volume_icon)

        # Volume slider
        self.volume_slider = QSlider(Qt.Horizontal)
        self.volume_slider.setRange(0, 100)
        self.volume_slider.setValue(self.current_volume)
        self.volume_slider.setFixedWidth(80)
        self.volume_slider.valueChanged.connect(self.set_volume)
        self.volume_slider.setStyleSheet(f"""
            QSlider::groove:horizontal {{
                border: none;
                height: 4px;
                background: {TokyoNight.NEBULA};
                border-radius: 2px;
            }}
            QSlider::handle:horizontal {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                border: none;
                width: 12px;
                margin: -4px 0;
                border-radius: 6px;
            }}
            QSlider::handle:horizontal:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """)
        layout.addWidget(self.volume_slider)

        # Volume label (clickable to launch pavucontrol)
        self.volume_label = QLabel("50%")
        self.volume_label.setStyleSheet(f"""
            padding: 4px 8px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 9pt;
            color: {TokyoNight.FOREGROUND};
        """)
        self.volume_label.setCursor(Qt.PointingHandCursor)
        self.volume_label.mousePressEvent = self.volume_label_mouse_press
        self.volume_label.setToolTip("Click to open Volume Control")
        layout.addWidget(self.volume_label)

        # Enable mouse tracking for the whole widget
        self.setMouseTracking(True)

    def volume_icon_mouse_press(self, event):
        """Handle mouse press on volume icon"""
        if event.button() == Qt.LeftButton:
            self.toggle_mute()

    def volume_label_mouse_press(self, event):
        """Handle mouse press on volume label"""
        if event.button() == Qt.LeftButton:
            self.launch_pavucontrol()

    def mousePressEvent(self, event):
        """Handle mouse press events for the entire widget."""
        if event.button() == Qt.LeftButton:
            # Don't handle clicks on child widgets - let their handlers deal with it
            child_widget = self.childAt(event.pos())
            if child_widget in [self.volume_icon, self.volume_label, self.volume_slider]:
                # Let the child widget handle the click
                super().mousePressEvent(event)
                return
                
            # Handle click on empty space in the widget
            # Calculate the volume based on the click position relative to the widget
            widget_rect = self.rect()
            click_x = event.pos().x()
            
            # Calculate volume based on click position
            if widget_rect.width() > 0:
                volume = int((click_x / widget_rect.width()) * 100)
                volume = max(0, min(100, volume))
                self.set_volume(volume)
                
        super().mousePressEvent(event)

    def wheelEvent(self, event):
        """Handle mouse wheel events for the entire widget to change volume."""
        # Calculate volume change
        delta = event.angleDelta().y()
        if delta > 0:
            # Scroll up - increase volume
            new_volume = min(100, self.current_volume + 5)
        else:
            # Scroll down - decrease volume
            new_volume = max(0, self.current_volume - 5)
        # Set the new volume
        self.set_volume(new_volume)
        event.accept()

    def set_volume(self, volume):
        """Set system volume and update display"""
        # Update current volume
        self.current_volume = volume
        # Update slider position (block signals to avoid recursion)
        self.volume_slider.blockSignals(True)
        self.volume_slider.setValue(volume)
        self.volume_slider.blockSignals(False)
        # Set system volume using pactl
        success = self.set_volume_pactl(volume)
        if not success:
            print(f"Failed to set volume to {volume}%")
        # Update display
        self.update_volume_display(volume, self.is_muted)

    def set_volume_pactl(self, volume):
        """Set volume using pactl command"""
        try:
            result = subprocess.run(
                ["pactl", "set-sink-volume", "@DEFAULT_SINK@", f"{volume}%"],
                capture_output=True, text=True, timeout=2
            )
            return result.returncode == 0
        except Exception as e:
            print(f"Volume set error: {e}")
            return False

    def toggle_mute(self):
        """Toggle mute state"""
        success = self.toggle_mute_pactl()
        if not success:
            print("Failed to toggle mute")
        else:
            # Toggle mute state locally
            self.is_muted = not self.is_muted
            self.update_volume_display(self.current_volume, self.is_muted)

    def toggle_mute_event(self, event):
        """Toggle mute state (for key binding)"""
        success = self.toggle_mute_pactl()
        if not success:
            print("Failed to toggle mute")
        else:
            # Toggle mute state locally
            self.is_muted = not self.is_muted
            self.update_volume_display(self.current_volume, self.is_muted)

    def toggle_mute_pactl(self):
        """Toggle mute using pactl"""
        try:
            result = subprocess.run(
                ["pactl", "set-sink-mute", "@DEFAULT_SINK@", "toggle"],
                capture_output=True, text=True, timeout=2
            )
            return result.returncode == 0
        except Exception as e:
            print(f"Mute toggle error: {e}")
            return False

    def launch_pavucontrol(self):
        """Launch volume control when label is clicked"""
        try:
            # Try pavucontrol first (works with PipeWire)
            # Check if pavucontrol is already running
            result = subprocess.run(
                ["pgrep", "-f", "pavucontrol"],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                # If running, focus it
                subprocess.run(
                    ["wmctrl", "-a", "pavucontrol"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            else:
                # Launch pavucontrol
                subprocess.Popen(
                    ["pavucontrol"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
        except Exception as e:
            print(f"Failed to launch pavucontrol: {e}")

    def update_volume_display(self, volume, muted):
        """Update the volume label display"""
        self.current_volume = volume
        self.is_muted = muted
        icon = "Û∞ñÅ" if muted else "Û∞ïæ"  # Muted vs volume icon
        color = TokyoNight.RED if muted else TokyoNight.CYAN
        # Update icon
        self.volume_icon.setText(f"<font color='{color}'>{icon}</font>")
        # Update label
        self.volume_label.setText(f"<font color='{color}'>{volume}%</font>")

    def detect_audio_backend(self):
        """Detect which audio backend is available"""
        try:
            # Check if pactl works
            result = subprocess.run(
                ["pactl", "info"],
                capture_output=True, text=True, timeout=3
            )
            if result.returncode == 0:
                if "PipeWire" in result.stdout or "pipewire" in result.stdout.lower():
                    self.audio_backend = 'pipewire'
                    print("Using PipeWire backend")
                else:
                    self.audio_backend = 'pulse'
                    print("Using PulseAudio backend")
                return
        except Exception as e:
            print(f"PulseAudio/PipeWire check failed: {e}")

        # Fallback to ALSA
        try:
            result = subprocess.run(
                ["amixer", "scontrols"],
                capture_output=True, text=True, timeout=3
            )
            if result.returncode == 0 and "Master" in result.stdout:
                self.audio_backend = 'alsa'
                print("Using ALSA backend")
                return
        except:
            pass
        print("Warning: No supported audio backend found")
        self.audio_backend = None




class SystemMonitorThread(QThread):
    cpu_updated = pyqtSignal(float)
    memory_updated = pyqtSignal(float)
    battery_updated = pyqtSignal(int, str, str)  # capacity, status, time
    volume_updated = pyqtSignal(int, bool)
    network_updated = pyqtSignal(str, str)  # ssid, status
    brightness_updated = pyqtSignal(int)
    workspace_updated = pyqtSignal(int)  # Current workspace index
    active_window_updated = pyqtSignal(str)  # Active window ID

    def __init__(self):
        super().__init__()
        self.battery_path = self.find_battery_path()

    def find_battery_path(self):
        """Find the correct battery path"""
        battery_base = "/sys/class/power_supply"
        try:
            # List all power supply devices
            devices = os.listdir(battery_base)
            for device in devices:
                if device.startswith(('BAT', 'bat')):
                    # Check if capacity file exists
                    capacity_file = os.path.join(battery_base, device, 'capacity')
                    if os.path.exists(capacity_file):
                        return os.path.join(battery_base, device)
        except:
            pass
        return os.path.join(battery_base, 'BAT0')  # Default fallback

    def format_time(self, seconds):
        """Format seconds into hours and minutes"""
        if seconds <= 0:
            return ""
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        if hours > 0:
            return f"{hours}h{minutes:02d}m"
        else:
            return f"{minutes}m"

    def get_battery_time_upower(self, status):
        """Get battery time using upower command"""
        try:
            if status.lower() == "discharging":
                result = subprocess.run(
                    "upower -i $(upower -e | grep battery) 2>/dev/null | grep 'time to empty' | cut -d':' -f2 | tr -d ' ' | head -1",
                    shell=True, capture_output=True, text=True
                )
            elif status.lower() == "charging":
                result = subprocess.run(
                    "upower -i $(upower -e | grep battery) 2>/dev/null | grep 'time to full' | cut -d':' -f2 | tr -d ' ' | head -1",
                    shell=True, capture_output=True, text=True
                )
            else:
                return ""
            if result.returncode == 0 and result.stdout.strip():
                time_str = result.stdout.strip()
                # Parse time format like "1.5h" or "45min"
                if 'h' in time_str and 'min' in time_str:
                    # Format: "1.5h 30min"
                    hours_part = time_str.split('h')[0]
                    minutes_part = time_str.split('min')[0].split()[-1]
                    try:
                        hours = int(float(hours_part))
                        minutes = int(minutes_part)
                        return f"{hours}h{minutes:02d}m"
                    except:
                        return time_str
                elif 'h' in time_str:
                    return time_str.replace('h', 'h')
                elif 'min' in time_str:
                    return time_str.replace('min', 'm')
        except:
            pass
        return ""

    def get_battery_info(self):
        """Get comprehensive battery information"""
        capacity = 0
        status = "Unknown"
        time_str = ""
        try:
            # Get capacity
            capacity_file = os.path.join(self.battery_path, 'capacity')
            if os.path.exists(capacity_file):
                with open(capacity_file, 'r') as f:
                    capacity = int(f.read().strip())
            else:
                # Try alternative location
                capacity_result = subprocess.run(
                    "cat /sys/class/power_supply/BAT*/capacity 2>/dev/null | head -1 || echo 0",
                    shell=True, capture_output=True, text=True
                )
                capacity = int(capacity_result.stdout.strip()) if capacity_result.stdout.strip().isdigit() else 0

            # Get status
            status_file = os.path.join(self.battery_path, 'status')
            if os.path.exists(status_file):
                with open(status_file, 'r') as f:
                    status = f.read().strip()
            else:
                status_result = subprocess.run(
                    "cat /sys/class/power_supply/BAT*/status 2>/dev/null | head -1 || echo Unknown",
                    shell=True, capture_output=True, text=True
                )
                status = status_result.stdout.strip()

            # Get time information with multiple fallback methods
            time_str = self.get_battery_time(status, capacity)
        except Exception as e:
            print(f"Battery info error: {e}")
        return capacity, status, time_str

    def get_battery_time(self, status, capacity):
        """Get battery time with multiple fallback methods"""
        time_str = ""
        try:
            # Method 1: Direct kernel files (most accurate)
            if status.lower() == "discharging":
                time_file = os.path.join(self.battery_path, 'time_to_empty')
                if os.path.exists(time_file):
                    with open(time_file, 'r') as f:
                        time_value = f.read().strip()
                    if time_value and time_value.isdigit() and int(time_value) > 0:
                        seconds = int(time_value) * 60  # Convert minutes to seconds
                        time_str = self.format_time(seconds)
                else:
                    # Try alternative naming
                    time_file = os.path.join(self.battery_path, 'time_to_empty_now')
                    if os.path.exists(time_file):
                        with open(time_file, 'r') as f:
                            time_value = f.read().strip()
                        if time_value and time_value.isdigit() and int(time_value) > 0:
                            seconds = int(time_value)
                            time_str = self.format_time(seconds)

            elif status.lower() == "charging":
                time_file = os.path.join(self.battery_path, 'time_to_full')
                if os.path.exists(time_file):
                    with open(time_file, 'r') as f:
                        time_value = f.read().strip()
                    if time_value and time_value.isdigit() and int(time_value) > 0:
                        seconds = int(time_value) * 60  # Convert minutes to seconds
                        time_str = self.format_time(seconds)
                else:
                    # Try alternative naming
                    time_file = os.path.join(self.battery_path, 'time_to_full_now')
                    if os.path.exists(time_file):
                        with open(time_file, 'r') as f:
                            time_value = f.read().strip()
                        if time_value and time_value.isdigit() and int(time_value) > 0:
                            seconds = int(time_value)
                            time_str = self.format_time(seconds)

            # Method 2: Use upower if available (good fallback)
            if not time_str:
                time_str = self.get_battery_time_upower(status)

            # Method 3: Estimate based on capacity and average consumption
            if not time_str and status.lower() == "discharging":
                # Very rough estimate: assume 5 hours total battery life
                estimated_minutes = int((capacity / 100.0) * 300)  # 5 hours = 300 minutes
                if estimated_minutes > 60:
                    time_str = f"{estimated_minutes // 60}h{estimated_minutes % 60:02d}m"
                else:
                    time_str = f"{estimated_minutes}m"
            elif not time_str and status.lower() == "charging":
                # Rough estimate for charging
                remaining_percent = 100 - capacity
                estimated_minutes = int(remaining_percent * 1.5)  # ~1.5 minutes per percent
                if estimated_minutes > 60:
                    time_str = f"{estimated_minutes // 60}h{estimated_minutes % 60:02d}m"
                else:
                    time_str = f"{estimated_minutes}m"
            elif status.lower() == "full":
                time_str = "Full"
        except Exception as e:
            print(f"Battery time error: {e}")
        return time_str

    def get_volume_pulse(self):
        """Get volume using PipeWire/PulseAudio pactl commands"""
        try:
            # Get default sink
            sink_result = subprocess.run(
                ["pactl", "get-default-sink"],
                capture_output=True, text=True, timeout=2
            )
            default_sink = None
            if sink_result.returncode == 0:
                default_sink = sink_result.stdout.strip()
            # If no default sink, try to find one
            if not default_sink:
                list_result = subprocess.run(
                    ["pactl", "list", "sinks", "short"],
                    capture_output=True, text=True, timeout=2
                )
                if list_result.returncode == 0:
                    lines = list_result.stdout.splitlines()
                    if lines:
                        default_sink = lines[0].split()[1]

            if default_sink:
                # Get volume
                result = subprocess.run(
                    ["pactl", "get-sink-volume", default_sink],
                    capture_output=True, text=True, timeout=2
                )
                if result.returncode == 0:
                    # Parse volume from output (PipeWire/PulseAudio format)
                    import re
                    # Look for volume percentage in the output
                    volume_matches = re.findall(r'(\d+)%', result.stdout)
                    if volume_matches:
                        # Take the left channel volume (usually first match)
                        volume = int(volume_matches[0])
                        # Check if muted
                        mute_result = subprocess.run(
                            ["pactl", "get-sink-mute", default_sink],
                            capture_output=True, text=True, timeout=2
                        )
                        muted = (mute_result.returncode == 0 and 
                               "yes" in mute_result.stdout.lower())
                        return volume, muted
        except Exception as e:
            print(f"PipeWire/PulseAudio volume error: {e}")
        return None, None

    def get_volume_amixer(self):
        """Get volume using amixer"""
        try:
            result = subprocess.run(
                "amixer sget Master 2>/dev/null | grep -o '[0-9]*%' | head -1",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                volume_str = result.stdout.strip().rstrip('%')
                if volume_str.isdigit():
                    # Check if muted
                    muted_result = subprocess.run(
                        "amixer sget Master 2>/dev/null | grep -q '\\[off\\]'",
                        shell=True
                    )
                    muted = muted_result.returncode == 0
                    return int(volume_str), muted
        except:
            pass
        return None, None

    def get_current_workspace(self):
        """Get the current workspace index more reliably"""
        try:
            # Method 1: wmctrl
            result = subprocess.run(
                "wmctrl -d | grep '*' | awk '{print $1}'",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip().isdigit():
                return int(result.stdout.strip())
            
            # Method 2: xdotool
            result = subprocess.run(
                "xdotool get_desktop",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip().isdigit():
                return int(result.stdout.strip())
                
        except Exception as e:
            print(f"Error getting current workspace: {e}")
        
        return 0  # Fallback

    def get_active_window(self):
        """Get the ID of the currently active window"""
        try:
            result = subprocess.run(
                "xdotool getwindowfocus",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
        except:
            pass
        # Fallback to wmctrl
        try:
            result = subprocess.run(
                "wmctrl -l | grep ' *' | cut -d' ' -f1",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
        except:
            pass
        return ""

    def run(self):
        self.prev_cpu_total = 0
        self.prev_cpu_idle = 0
        while True:
            # CPU usage
            try:
                with open('/proc/stat', 'r') as f:
                    for line in f:
                        if line.startswith('cpu '):
                            parts = line.split()
                            user = int(parts[1])
                            nice = int(parts[2])
                            system = int(parts[3])
                            idle = int(parts[4])
                            total = user + nice + system + idle
                            if self.prev_cpu_total > 0:
                                usage = ((total - self.prev_cpu_total) - (idle - self.prev_cpu_idle)) / (total - self.prev_cpu_total) * 100
                                self.cpu_updated.emit(usage)
                            self.prev_cpu_total = total
                            self.prev_cpu_idle = idle
                            break
            except:
                self.cpu_updated.emit(0)

            # Memory usage
            try:
                with open('/proc/meminfo', 'r') as f:
                    meminfo = {}
                    for line in f:
                        key, value = line.split(':', 1)
                        meminfo[key] = value.strip().split(' ')[0]
                total = int(meminfo['MemTotal'])
                available = int(meminfo['MemAvailable'])
                used = total - available
                percent = (used / total) * 100
                self.memory_updated.emit(percent)
            except:
                self.memory_updated.emit(0)

            # Battery - Enhanced with time information
            try:
                capacity, status, time_str = self.get_battery_info()
                self.battery_updated.emit(capacity, status, time_str)
            except:
                self.battery_updated.emit(0, "Unknown", "")

            # Volume - try multiple methods with proper backend detection
            volume, muted = None, None
            # Try PipeWire/PulseAudio first
            volume, muted = self.get_volume_pulse()
            # If PipeWire/PulseAudio failed, try ALSA
            if volume is None:
                volume, muted = self.get_volume_amixer()
            # If all failed, emit default values
            if volume is None:
                volume, muted = 0, False
                print("Warning: Could not get volume - no audio tool found")
            self.volume_updated.emit(volume, muted)

            # Network
            try:
                ssid = subprocess.run(
                    "iwgetid -r 2>/dev/null || echo ''",
                    shell=True, capture_output=True, text=True
                ).stdout.strip()
                if ssid:
                    self.network_updated.emit(ssid, "connected")
                else:
                    # Check ethernet
                    ethernet = subprocess.run(
                        "ip route | grep default | head -1 | awk '{print $5}' 2>/dev/null || echo ''",
                        shell=True, capture_output=True, text=True
                    ).stdout.strip()
                    if ethernet:
                        self.network_updated.emit(ethernet, "connected")
                    else:
                        self.network_updated.emit("", "disconnected")
            except:
                self.network_updated.emit("", "disconnected")

            # Brightness
            try:
                result = subprocess.run(
                    "brightnessctl get && brightnessctl max",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    current, max_val = map(int, result.stdout.splitlines())
                    brightness = int((current / max_val) * 100)
                    self.brightness_updated.emit(brightness)
            except:
                pass

            # Current workspace
            current_workspace = self.get_current_workspace()
            self.workspace_updated.emit(current_workspace)

            # Active window
            active_window = self.get_active_window()
            self.active_window_updated.emit(active_window)

            time.sleep(2)

class SystemTrayWidget(QWidget):
    """Widget to host system tray icons"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(2)
        self.layout.setAlignment(Qt.AlignRight)
        # Set up system tray integration
        self.tray_icons = []
        self.setup_system_tray()

    def setup_system_tray(self):
        """Setup system tray integration using XEmbed"""
        try:
            # Try to find existing system tray
            if HAS_X11 and QX11Info.isPlatformX11():
                # Get the system tray selection atom
                import os
                os.environ['XDG_CURRENT_DESKTOP'] = 'XFCE'
                # Start sni-qt or similar if available
                subprocess.Popen(["which", "snid"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"System tray setup error: {e}")

    def add_tray_icon(self, icon_widget):
        """Add a tray icon widget to the tray area"""
        self.layout.addWidget(icon_widget)
        self.tray_icons.append(icon_widget)

    def clear_tray_icons(self):
        """Clear all tray icons"""
        for icon in self.tray_icons:
            icon.deleteLater()
        self.tray_icons.clear()

@dataclass
class PanelConfig:
    position: str = "top"
    height: int = 40
    opacity: float = 0.95
    blur_effect: bool = True
    show_date: bool = True
    show_battery: bool = True
    show_volume: bool = True
    show_network: bool = True
    show_tray: bool = True
    theme_variant: str = "tokyo_night"  # tokyo_night, tokyo_storm, tokyo_day
    rounded_corners: bool = True
    corner_radius: int = 10
    show_xfce_launchers: bool = True
    # New features
    show_workspace_switcher: bool = True
    show_brightness_control: bool = True
    show_weather: bool = True
    show_notifications: bool = True
    # NEW: Network and Bluetooth controls
    show_network_control: bool = True
    show_bluetooth_control: bool = True
    weather_location: str = ""  # Auto-detect if empty
    # Custom launchers
    launcher_customizations: List[Application] = None
    # Built-in launcher configurations
    terminal_command: str = "xfce4-terminal"
    file_manager_command: str = "thunar"
    browser_command: str = "firefox"
    text_editor_command: str = "mousepad"
    settings_command: str = "xfce4-settings-manager"
    calculator_command: str = "gnome-calculator"
    screenshot_command: str = "xfce4-screenshooter"
    image_viewer_command: str = "ristretto"
    music_player_command: str = "vlc"
    music_player_args: str = ""  # Additional arguments for music player
    # Auto-hide settings
    auto_hide: bool = False
    auto_hide_delay: int = 2000  # milliseconds
    show_on_edge: bool = True
    edge_size: int = 5  # pixels

class LauncherDialog(QDialog):
    """Dialog for adding/editing a launcher with system icon support and workspace targeting"""
    def __init__(self, parent=None, launcher=None):
        super().__init__(parent)
        self.launcher = launcher
        self.setup_ui()
        if self.launcher:
            # If editing, set the initial values
            self.name_edit.setText(self.launcher.name)
            self.command_edit.setText(self.launcher.command)
            self.args_edit.setText(self.launcher.args)
            self.icon_edit.setText(self.launcher.icon)
            self.workspace_combo.setCurrentIndex(self.launcher.workspace + 1)  # +1 because index 0 is "Current"

    def setup_ui(self):
        self.setWindowTitle("Add Launcher" if not self.launcher else "Edit Launcher")
        self.setFixedSize(450, 350)  # Increased height for workspace option
        self.setStyleSheet(f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QLabel {{
                color: {TokyoNight.FOREGROUND};
            }}
            QLineEdit, QComboBox {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                padding: 5px;
                border-radius: 3px;
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """)
        layout = QFormLayout()
        
        self.name_edit = QLineEdit()
        if self.launcher:
            self.name_edit.setText(self.launcher.name)
        layout.addRow("Name:", self.name_edit)
        
        self.command_edit = QLineEdit()
        if self.launcher:
            self.command_edit.setText(self.launcher.command)
        layout.addRow("Command:", self.command_edit)
        
        self.args_edit = QLineEdit()
        if self.launcher:
            self.args_edit.setText(self.launcher.args)
        self.args_edit.setPlaceholderText("Optional arguments")
        layout.addRow("Arguments:", self.args_edit)
        
        # Icon selection
        icon_selection_layout = QHBoxLayout()
        self.icon_edit = QLineEdit()
        self.icon_edit.setPlaceholderText("Enter system icon name (e.g., 'firefox', 'thunar') or path")
        if self.launcher:
            self.icon_edit.setText(self.launcher.icon)
        browse_icon_btn = QPushButton("Browse System Icon")
        browse_icon_btn.clicked.connect(self.browse_system_icon)
        icon_selection_layout.addWidget(self.icon_edit)
        icon_selection_layout.addWidget(browse_icon_btn)
        layout.addRow("Icon (name or path):", icon_selection_layout)
        
        # NEW: Workspace selection
        self.workspace_combo = QComboBox()
        # Get available workspaces
        workspaces = self.get_available_workspaces()
        self.workspace_combo.addItem("Current Workspace", -1)  # -1 means current
        for i, workspace_name in enumerate(workspaces):
            self.workspace_combo.addItem(f"Workspace {i+1}: {workspace_name}", i)
        layout.addRow("Open in Workspace:", self.workspace_combo)
        
        buttons_layout = QHBoxLayout()
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        buttons_layout.addWidget(save_btn)
        buttons_layout.addWidget(cancel_btn)
        layout.addRow(buttons_layout)
        
        self.setLayout(layout)

    def get_available_workspaces(self):
        """Get list of available workspace names"""
        workspaces = []
        try:
            result = subprocess.run("wmctrl -d", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    # Extract workspace name (the part after the resolution)
                    parts = line.split()
                    if len(parts) >= 9:
                        # Join the parts that form the workspace name
                        name_parts = parts[8:]
                        workspace_name = ' '.join(name_parts)
                        workspaces.append(workspace_name)
                    else:
                        workspaces.append(f"Workspace {len(workspaces)}")
        except Exception as e:
            print(f"Error getting workspaces: {e}")
            # Fallback: create generic workspace names
            workspaces = [f"Workspace {i+1}" for i in range(4)]
        return workspaces

    def browse_system_icon(self):
        """Open a simple dialog to enter a system icon name."""
        icon_name, ok = QInputDialog.getText(
            self, "System Icon Name", "Enter system icon name (e.g., 'firefox', 'thunar', 'terminal'):", 
            QLineEdit.Normal, self.icon_edit.text()
        )
        if ok:
            self.icon_edit.setText(icon_name)

    def get_launcher(self):
        """Get the launcher from the dialog."""
        workspace_index = self.workspace_combo.currentData()
        return Application(
            name=self.name_edit.text(),
            command=self.command_edit.text(),
            args=self.args_edit.text(),
            icon=self.icon_edit.text() or "üöÄ",
            workspace=workspace_index
        )
        
class SettingsDialog(QDialog):
    def __init__(self, config: PanelConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.setup_ui()

    def setup_ui(self):
        self.setWindowTitle("Panel Settings")
        self.setFixedSize(650, 950)
        self.setStyleSheet(self.get_stylesheet())

        layout = QVBoxLayout()
        # Create tabs
        tabs = QTabWidget()

        # Appearance tab
        appearance_tab = QWidget()
        appearance_layout = QFormLayout(appearance_tab)
        self.position_combo = QComboBox()
        self.position_combo.addItems(["top", "bottom"])
        self.position_combo.setCurrentText(self.config.position)
        appearance_layout.addRow("Position:", self.position_combo)
        self.height_spin = QSpinBox()
        self.height_spin.setRange(30, 100)
        self.height_spin.setValue(self.config.height)
        appearance_layout.addRow("Height:", self.height_spin)
        self.opacity_slider = QSlider(Qt.Horizontal)
        self.opacity_slider.setRange(50, 100)
        self.opacity_slider.setValue(int(self.config.opacity * 100))
        appearance_layout.addRow("Opacity:", self.opacity_slider)
        self.theme_combo = QComboBox()
        self.theme_combo.addItems(["tokyo_night", "tokyo_storm", "tokyo_day"])
        self.theme_combo.setCurrentText(self.config.theme_variant)
        appearance_layout.addRow("Theme:", self.theme_combo)
        # Rounded corners settings
        self.rounded_corners_check = QCheckBox("Enable Rounded Corners")
        self.rounded_corners_check.setChecked(self.config.rounded_corners)
        appearance_layout.addRow(self.rounded_corners_check)
        self.corner_radius_spin = QSpinBox()
        self.corner_radius_spin.setRange(0, 30)
        self.corner_radius_spin.setValue(self.config.corner_radius)
        appearance_layout.addRow("Corner Radius:", self.corner_radius_spin)

        # Auto-hide settings
        self.auto_hide_check = QCheckBox("Enable Auto-Hide")
        self.auto_hide_check.setChecked(self.config.auto_hide)
        appearance_layout.addRow(self.auto_hide_check)
        self.auto_hide_delay_spin = QSpinBox()
        self.auto_hide_delay_spin.setRange(500, 10000)
        self.auto_hide_delay_spin.setValue(self.config.auto_hide_delay)
        self.auto_hide_delay_spin.setSuffix(" ms")
        appearance_layout.addRow("Auto-Hide Delay:", self.auto_hide_delay_spin)
        self.show_on_edge_check = QCheckBox("Show on Edge Hover")
        self.show_on_edge_check.setChecked(self.config.show_on_edge)
        appearance_layout.addRow(self.show_on_edge_check)
        self.edge_size_spin = QSpinBox()
        self.edge_size_spin.setRange(1, 20)
        self.edge_size_spin.setValue(self.config.edge_size)
        self.edge_size_spin.setSuffix(" px")
        appearance_layout.addRow("Edge Detection Size:", self.edge_size_spin)

        # Modules tab
        modules_tab = QWidget()
        modules_layout = QVBoxLayout(modules_tab)
        self.show_date_check = QCheckBox("Show Date")
        self.show_date_check.setChecked(self.config.show_date)
        modules_layout.addWidget(self.show_date_check)
        self.show_battery_check = QCheckBox("Show Battery")
        self.show_battery_check.setChecked(self.config.show_battery)
        modules_layout.addWidget(self.show_battery_check)
        self.show_volume_check = QCheckBox("Show Volume")
        self.show_volume_check.setChecked(self.config.show_volume)
        modules_layout.addWidget(self.show_volume_check)
        self.show_network_check = QCheckBox("Show Network Status")
        self.show_network_check.setChecked(self.config.show_network)
        modules_layout.addWidget(self.show_network_check)
        # NEW: Network and Bluetooth controls
        self.show_network_control_check = QCheckBox("Show Network Manager Control")
        self.show_network_control_check.setChecked(self.config.show_network_control)
        modules_layout.addWidget(self.show_network_control_check)
        self.show_bluetooth_control_check = QCheckBox("Show Bluetooth Manager Control")
        self.show_bluetooth_control_check.setChecked(self.config.show_bluetooth_control)
        modules_layout.addWidget(self.show_bluetooth_control_check)
        self.show_tray_check = QCheckBox("Show System Tray")
        self.show_tray_check.setChecked(self.config.show_tray)
        modules_layout.addWidget(self.show_tray_check)
        self.show_xfce_launchers_check = QCheckBox("Show XFCE Panel Launchers")
        self.show_xfce_launchers_check.setChecked(self.config.show_xfce_launchers)
        modules_layout.addWidget(self.show_xfce_launchers_check)
        # New features
        self.show_workspace_switcher_check = QCheckBox("Show Workspace Switcher")
        self.show_workspace_switcher_check.setChecked(self.config.show_workspace_switcher)
        modules_layout.addWidget(self.show_workspace_switcher_check)
        self.show_brightness_control_check = QCheckBox("Show Brightness Control")
        self.show_brightness_control_check.setChecked(self.config.show_brightness_control)
        modules_layout.addWidget(self.show_brightness_control_check)
        self.show_weather_check = QCheckBox("Show Weather Widget")
        self.show_weather_check.setChecked(self.config.show_weather)
        modules_layout.addWidget(self.show_weather_check)
        self.show_notifications_check = QCheckBox("Show Notification Center")
        self.show_notifications_check.setChecked(self.config.show_notifications)
        modules_layout.addWidget(self.show_notifications_check)
        modules_layout.addStretch()

        # Weather settings tab
        weather_tab = QWidget()
        weather_layout = QFormLayout(weather_tab)
        self.weather_location_edit = QLineEdit()
        self.weather_location_edit.setPlaceholderText("Leave empty for auto-detection")
        self.weather_location_edit.setText(self.config.weather_location)
        weather_layout.addRow("Location (city,code):", self.weather_location_edit)
        weather_info = QLabel("Weather data from wttr.in")
        weather_info.setStyleSheet(f"color: {TokyoNight.COMMENT}; font-size: 8pt;")
        weather_layout.addRow(weather_info)

        # Launchers tab
        launchers_tab = QWidget()
        launchers_layout = QVBoxLayout(launchers_tab)
        # Instructions
        instructions = QLabel("Manage your application launchers:")
        instructions.setStyleSheet(f"color: {TokyoNight.FOREGROUND}; margin-bottom: 10px;")
        launchers_layout.addWidget(instructions)
        # List of launchers
        self.launchers_list = QListWidget()
        self.launchers_list.setStyleSheet(f"""
            QListWidget {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 4px;
                padding: 5px;
            }}
            QListWidget::item {{
                padding: 5px;
                border-radius: 3px;
            }}
            QListWidget::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        launchers_layout.addWidget(self.launchers_list)
        # Buttons for launcher management
        buttons_layout = QHBoxLayout()
        add_btn = QPushButton("Add")
        add_btn.clicked.connect(self.add_launcher)
        buttons_layout.addWidget(add_btn)
        edit_btn = QPushButton("Edit")
        edit_btn.clicked.connect(self.edit_launcher)
        buttons_layout.addWidget(edit_btn)
        remove_btn = QPushButton("Remove")
        remove_btn.clicked.connect(self.remove_launcher)
        buttons_layout.addWidget(remove_btn)
        buttons_layout.addStretch()
        launchers_layout.addLayout(buttons_layout)
        # Load existing launchers
        self.load_launchers()

        # Built-in launchers tab
        builtin_tab = QWidget()
        builtin_layout = QFormLayout(builtin_tab)
        builtin_title = QLabel("Configure built-in application launchers:")
        builtin_title.setStyleSheet(f"color: {TokyoNight.FOREGROUND}; font-weight: bold; margin-bottom: 10px;")
        builtin_layout.addRow(builtin_title)
        # Terminal
        self.terminal_edit = QLineEdit()
        self.terminal_edit.setText(self.config.terminal_command)
        self.terminal_edit.setPlaceholderText("e.g., xfce4-terminal, gnome-terminal, konsole")
        builtin_layout.addRow("Terminal:", self.terminal_edit)
        # File Manager
        self.file_manager_edit = QLineEdit()
        self.file_manager_edit.setText(self.config.file_manager_command)
        self.file_manager_edit.setPlaceholderText("e.g., thunar, nautilus, dolphin")
        builtin_layout.addRow("File Manager:", self.file_manager_edit)
        # Web Browser
        self.browser_edit = QLineEdit()
        self.browser_edit.setText(self.config.browser_command)
        self.browser_edit.setPlaceholderText("e.g., firefox, chromium, google-chrome")
        builtin_layout.addRow("Web Browser:", self.browser_edit)
        # Text Editor
        self.text_editor_edit = QLineEdit()
        self.text_editor_edit.setText(self.config.text_editor_command)
        self.text_editor_edit.setPlaceholderText("e.g., mousepad, gedit, kate")
        builtin_layout.addRow("Text Editor:", self.text_editor_edit)
        # Settings
        self.settings_edit = QLineEdit()
        self.settings_edit.setText(self.config.settings_command)
        self.settings_edit.setPlaceholderText("e.g., xfce4-settings-manager, gnome-control-center")
        builtin_layout.addRow("Settings:", self.settings_edit)
        # Calculator
        self.calculator_edit = QLineEdit()
        self.calculator_edit.setText(self.config.calculator_command)
        self.calculator_edit.setPlaceholderText("e.g., gnome-calculator, kcalc")
        builtin_layout.addRow("Calculator:", self.calculator_edit)
        # Screenshot
        self.screenshot_edit = QLineEdit()
        self.screenshot_edit.setText(self.config.screenshot_command)
        self.screenshot_edit.setPlaceholderText("e.g., xfce4-screenshooter, gnome-screenshot")
        builtin_layout.addRow("Screenshot:", self.screenshot_edit)
        # Image Viewer
        self.image_viewer_edit = QLineEdit()
        self.image_viewer_edit.setText(self.config.image_viewer_command)
        self.image_viewer_edit.setPlaceholderText("e.g., ristretto, eog, gwenview")
        builtin_layout.addRow("Image Viewer:", self.image_viewer_edit)
        # Music Player
        self.music_player_edit = QLineEdit()
        self.music_player_edit.setText(self.config.music_player_command)
        self.music_player_edit.setPlaceholderText("e.g., vlc, mpv, audacious")
        builtin_layout.addRow("Music Player:", self.music_player_edit)
        # Music Player Arguments
        self.music_player_args_edit = QLineEdit()
        self.music_player_args_edit.setText(self.config.music_player_args)
        self.music_player_args_edit.setPlaceholderText("Optional arguments for music player")
        builtin_layout.addRow("Music Player Args:", self.music_player_args_edit)

        # Add tabs
        tabs.addTab(appearance_tab, "Appearance")
        tabs.addTab(modules_tab, "Modules")
        tabs.addTab(weather_tab, "Weather")
        tabs.addTab(launchers_tab, "Custom Launchers")
        tabs.addTab(builtin_tab, "Built-in Launchers")

        layout.addWidget(tabs)

        # Buttons
        button_layout = QHBoxLayout()
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.save_settings)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(save_btn)
        button_layout.addWidget(cancel_btn)
        layout.addLayout(button_layout)

        self.setLayout(layout)

# ... (other methods in SettingsDialog remain the same)

    def load_launchers(self):
        """Load existing launchers into the list"""
        # This should load from the config passed to the dialog
        if self.config.launcher_customizations:
            for launcher in self.config.launcher_customizations:
                item = QListWidgetItem(f"{launcher.icon} {launcher.name}")
                item.setData(Qt.UserRole, launcher)
                self.launchers_list.addItem(item)



# ... (rest of SettingsDialog remains the same)

    def add_launcher(self):
        """Add a new launcher"""
        dialog = LauncherDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            launcher = dialog.get_launcher()
            item = QListWidgetItem(f"{launcher.icon} {launcher.name}")
            item.setData(Qt.UserRole, launcher)
            self.launchers_list.addItem(item)

    def edit_launcher(self):
        """Edit selected launcher"""
        current_item = self.launchers_list.currentItem()
        if current_item:
            launcher = current_item.data(Qt.UserRole)
            dialog = LauncherDialog(self, launcher)
            if dialog.exec_() == QDialog.Accepted:
                launcher = dialog.get_launcher()
                current_item.setText(f"{launcher.icon} {launcher.name}")
                current_item.setData(Qt.UserRole, launcher)

    def remove_launcher(self):
        """Remove selected launcher"""
        current_item = self.launchers_list.currentItem()
        if current_item:
            row = self.launchers_list.row(current_item)
            self.launchers_list.takeItem(row)

    def get_stylesheet(self):
        return f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QTabWidget::pane {{
                border: 1px solid {TokyoNight.SELECTION};
                background: {TokyoNight.NIGHT_BOTTOM};
                border-radius: 6px;
            }}
            QTabBar::tab {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                padding: 8px 16px;
                margin-right: 2px;
                border-top-left-radius: 6px;
                border-top-right-radius: 6px;
            }}
            QTabBar::tab:selected {{
                background: {TokyoNight.BLUE};
            }}
            QCheckBox {{
                color: {TokyoNight.FOREGROUND};
                spacing: 8px;
            }}
            QCheckBox::indicator {{
                width: 16px;
                height: 16px;
                border-radius: 3px;
            }}
            QCheckBox::indicator:unchecked {{
                background: {TokyoNight.SELECTION};
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QCheckBox::indicator:checked {{
                background: {TokyoNight.BLUE};
                border: 1px solid {TokyoNight.BLUE};
            }}
            QComboBox, QSpinBox, QSlider, QLineEdit {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                padding: 5px;
                border-radius: 3px;
            }}
            QLineEdit {{
                padding: 6px;
            }}
            QComboBox::drop-down {{
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 15px;
                border-left-width: 1px;
                border-left-color: {TokyoNight.NEBULA};
                border-left-style: solid;
                border-top-right-radius: 3px;
                border-bottom-right-radius: 3px;
                background-color: {TokyoNight.SELECTION};
            }}
            QComboBox::down-arrow {{
                image: none;
                border-left: 5px solid transparent;
                border-right: 5px solid transparent;
                border-top: 5px solid {TokyoNight.FOREGROUND};
                margin-right: 5px;
            }}
            QComboBox QAbstractItemView {{
                background: {TokyoNight.NIGHT_BOTTOM};
                color: {TokyoNight.FOREGROUND};
                selection-background-color: {TokyoNight.BLUE};
                selection-color: {TokyoNight.BACKGROUND};
                border: 1px solid {TokyoNight.SELECTION};
                border-radius: 4px;
            }}
            QSpinBox::up-button, QSpinBox::down-button {{
                subcontrol-origin: border;
                width: 16px;
                border-radius: 2px;
            }}
            QSpinBox::up-button {{
                subcontrol-position: top right;
            }}
            QSpinBox::down-button {{
                subcontrol-position: bottom right;
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
            QFormLayout {{
                color: {TokyoNight.FOREGROUND};
            }}
            QLabel {{
                color: {TokyoNight.FOREGROUND};
            }}
        """

    def save_settings(self):
        """Save all settings including built-in launcher commands and custom launchers"""
        # Save appearance settings
        self.config.position = self.position_combo.currentText()
        self.config.height = self.height_spin.value()
        self.config.opacity = self.opacity_slider.value() / 100.0
        self.config.theme_variant = self.theme_combo.currentText()
        self.config.rounded_corners = self.rounded_corners_check.isChecked()
        self.config.corner_radius = self.corner_radius_spin.value()
        
        # Save module visibility settings
        self.config.show_date = self.show_date_check.isChecked()
        self.config.show_battery = self.show_battery_check.isChecked()
        self.config.show_volume = self.show_volume_check.isChecked()
        self.config.show_network = self.show_network_check.isChecked()
        self.config.show_tray = self.show_tray_check.isChecked()
        self.config.show_xfce_launchers = self.show_xfce_launchers_check.isChecked()
        self.config.show_workspace_switcher = self.show_workspace_switcher_check.isChecked()
        self.config.show_brightness_control = self.show_brightness_control_check.isChecked()
        self.config.show_weather = self.show_weather_check.isChecked()
        self.config.show_notifications = self.show_notifications_check.isChecked()
        self.config.show_network_control = self.show_network_control_check.isChecked()
        self.config.show_bluetooth_control = self.show_bluetooth_control_check.isChecked()
        
        # Save weather settings
        self.config.weather_location = self.weather_location_edit.text()
        
        # Save auto-hide settings
        self.config.auto_hide = self.auto_hide_check.isChecked()
        self.config.auto_hide_delay = self.auto_hide_delay_spin.value()
        self.config.show_on_edge = self.show_on_edge_check.isChecked()
        self.config.edge_size = self.edge_size_spin.value()
        
        # Save built-in launcher commands
        self.config.terminal_command = self.terminal_edit.text()
        self.config.file_manager_command = self.file_manager_edit.text()
        self.config.browser_command = self.browser_edit.text()
        self.config.text_editor_command = self.text_editor_edit.text()
        self.config.settings_command = self.settings_edit.text()
        self.config.calculator_command = self.calculator_edit.text()
        self.config.screenshot_command = self.screenshot_edit.text()
        self.config.image_viewer_command = self.image_viewer_edit.text()
        self.config.music_player_command = self.music_player_edit.text()
        self.config.music_player_args = self.music_player_args_edit.text()
        
        # CRITICAL FIX: Save custom launchers properly
        custom_launchers = []
        for i in range(self.launchers_list.count()):
            item = self.launchers_list.item(i)
            if item:
                launcher = item.data(Qt.UserRole)
                if launcher:
                    custom_launchers.append(launcher)
        
        self.config.launcher_customizations = custom_launchers
        print(f"DEBUG: Saved {len(custom_launchers)} custom launchers")  # Debug line
        
        self.accept()

class TokyoNightPanelBar(QMainWindow):
    def __init__(self, config: PanelConfig):
        super().__init__()
        self.config = config
        self.applications = []
        self.window_buttons = {}
        self.xfce_launchers = []
        self.workspace_buttons = []
        self.notification_count = 0
        self.current_workspace = 0
        self.active_window_id = ""
        
        # Auto-hide properties
        self.auto_hide_timer = QTimer()
        self.auto_hide_timer.setSingleShot(True)
        self.auto_hide_timer.timeout.connect(self.hide_panel)
        self.is_hidden = False
        self.edge_detection_timer = QTimer()
        self.edge_detection_timer.timeout.connect(self.check_mouse_position)
        self.edge_detection_timer.start(100)  # Check every 100ms
        
        self.setup_ui()
        self.load_applications()
        self.load_xfce_launchers()
        self.setup_system_monitor()
        self.start_timers()
        self.setup_strut()
        # Enable context menu for the entire panel
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_panel_context_menu)
        
        # Set up mouse tracking for auto-hide
        self.setMouseTracking(True)
        QApplication.instance().installEventFilter(self)
        
        # Start auto-hide if enabled
        if self.config.auto_hide:
            self.auto_hide_timer.start(self.config.auto_hide_delay)

    def eventFilter(self, obj, event):
        """Filter events to detect mouse movement for auto-hide"""
        if event.type() == QEvent.MouseMove and self.config.auto_hide:
            # Get the current mouse position
            mouse_pos = QCursor.pos()
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()
            
            # Check if mouse is at the edge where panel is located
            at_edge = False
            
            if self.config.position == "top":
                if mouse_pos.y() <= self.config.edge_size:
                    at_edge = True
            else:  # bottom
                if mouse_pos.y() >= screen_rect.height() - self.config.edge_size:
                    at_edge = True
            
            # Show panel if mouse is at edge and show_on_edge is enabled
            if at_edge and self.config.show_on_edge and self.is_hidden:
                self.show_panel()
            
            # Reset auto-hide timer if mouse is over the panel
            if self.geometry().contains(mouse_pos) and not self.is_hidden:
                self.auto_hide_timer.stop()
                self.auto_hide_timer.start(self.config.auto_hide_delay)
        
        return super().eventFilter(obj, event)

    def check_mouse_position(self):
        """Check mouse position for edge detection"""
        if not self.config.auto_hide or not self.config.show_on_edge:
            return
            
        mouse_pos = QCursor.pos()
        screen = QApplication.primaryScreen()
        screen_rect = screen.geometry()
        
        # Check if mouse is at the edge where panel is located
        at_edge = False
        
        if self.config.position == "top":
            if mouse_pos.y() <= self.config.edge_size:
                at_edge = True
        else:  # bottom
            if mouse_pos.y() >= screen_rect.height() - self.config.edge_size:
                at_edge = True
        
        # Show panel if mouse is at edge and panel is hidden
        if at_edge and self.is_hidden:
            self.show_panel()

    def show_panel(self):
        """Show the panel with animation"""
        if self.is_hidden:
            self.is_hidden = False
            
            # Get the screen geometry
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()
            
            # Create animation
            self.animation = QPropertyAnimation(self, b"geometry")
            self.animation.setDuration(200)
            self.animation.setEasingCurve(QEasingCurve.OutCubic)
            
            # Set start and end positions based on panel position
            if self.config.position == "top":
                start_pos = QRect(0, -self.config.height, screen_rect.width(), self.config.height)
                end_pos = QRect(0, 0, screen_rect.width(), self.config.height)
            else:  # bottom
                start_pos = QRect(0, screen_rect.height(), screen_rect.width(), self.config.height)
                end_pos = QRect(0, screen_rect.height() - self.config.height, screen_rect.width(), self.config.height)
            
            self.animation.setStartValue(start_pos)
            self.animation.setEndValue(end_pos)
            self.animation.start()
            
            # Show the panel
            self.show()
            
            # Reset auto-hide timer
            self.auto_hide_timer.stop()
            self.auto_hide_timer.start(self.config.auto_hide_delay)

    def hide_panel(self):
        """Hide the panel with animation"""
        if not self.is_hidden and self.config.auto_hide:
            self.is_hidden = True
            
            # Get the screen geometry
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()
            
            # Create animation
            self.animation = QPropertyAnimation(self, b"geometry")
            self.animation.setDuration(200)
            self.animation.setEasingCurve(QEasingCurve.InCubic)
            
            # Set start and end positions based on panel position
            if self.config.position == "top":
                start_pos = QRect(0, 0, screen_rect.width(), self.config.height)
                end_pos = QRect(0, -self.config.height, screen_rect.width(), self.config.height)
            else:  # bottom
                start_pos = QRect(0, screen_rect.height() - self.config.height, screen_rect.width(), self.config.height)
                end_pos = QRect(0, screen_rect.height(), screen_rect.width(), self.config.height)
            
            self.animation.setStartValue(start_pos)
            self.animation.setEndValue(end_pos)
            self.animation.start()
            
            # Hide the panel after animation completes
            QTimer.singleShot(250, self.hide)

    def enterEvent(self, event):
        """Handle mouse enter event"""
        if self.config.auto_hide and self.is_hidden:
            self.show_panel()
        super().enterEvent(event)

    def leaveEvent(self, event):
        """Handle mouse leave event"""
        if self.config.auto_hide and not self.is_hidden:
            self.auto_hide_timer.stop()
            self.auto_hide_timer.start(self.config.auto_hide_delay)
        super().leaveEvent(event)

    def setup_ui(self):
        """Setup the main panel UI with enhanced dark night theme"""
        # Window configuration
        self.setWindowTitle("Tokyo Night Panel")
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Tool)
        # Set opacity
        self.setWindowOpacity(self.config.opacity)
        # Apply stylesheet
        self.setStyleSheet(self.get_stylesheet())
        # Central widget with night sky background
        central_widget = NightSkyWidget()
        central_widget.setObjectName("centralwidget")
        self.setCentralWidget(central_widget)
        # === NEW LAYOUT STRUCTURE FOR FULL WIDTH ===
        # Main layout - ensure it expands fully
        layout = QHBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)  # Remove margins for full width
        layout.setSpacing(0)  # Remove spacing
        # Left section - allow it to expand
        self.left_widget = QWidget()
        left_layout = QHBoxLayout(self.left_widget)
        left_layout.setContentsMargins(10, 5, 10, 5)  # Keep some internal padding
        left_layout.setSpacing(6)
        # Applications menu button
        self.apps_button = QToolButton()
        self.apps_button.setText("Û∞Äª")  # nf-linux-arch icon
        self.apps_button.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.apps_button.setPopupMode(QToolButton.InstantPopup)
        self.apps_button.setMenu(self.create_applications_menu())
        self.apps_button.setFixedSize(32, 32)
        left_layout.addWidget(self.apps_button)
        # Separator
        sep1 = QFrame()
        sep1.setFrameShape(QFrame.VLine)
        sep1.setFrameShadow(QFrame.Sunken)
        left_layout.addWidget(sep1)
        # Workspace switcher
        if self.config.show_workspace_switcher:
            self.setup_workspace_switcher(left_layout)
            sep_ws = QFrame()
            sep_ws.setFrameShape(QFrame.VLine)
            sep_ws.setFrameShadow(QFrame.Sunken)
            left_layout.addWidget(sep_ws)
        # XFCE Launchers area
        self.xfce_launchers_widget = QWidget()
        self.xfce_launchers_layout = QHBoxLayout(self.xfce_launchers_widget)
        self.xfce_launchers_layout.setContentsMargins(0, 0, 0, 0)
        self.xfce_launchers_layout.setSpacing(4)
        self.xfce_launchers_widget.setVisible(self.config.show_xfce_launchers)
        left_layout.addWidget(self.xfce_launchers_widget)
        # Separator
        sep2 = QFrame()
        sep2.setFrameShape(QFrame.VLine)
        sep2.setFrameShadow(QFrame.Sunken)
        sep2.setVisible(self.config.show_xfce_launchers)
        left_layout.addWidget(sep2)
        # === FIXED TASKBAR SECTION - NOW EXPANDS PROPERLY ===
        # Taskbar area with scroll support - NOW EXPANDS TO FILL AVAILABLE SPACE
        self.taskbar_container = QWidget()
        self.taskbar_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Changed to Expanding
        taskbar_container_layout = QHBoxLayout(self.taskbar_container)
        taskbar_container_layout.setContentsMargins(0, 0, 0, 0)
        taskbar_container_layout.setSpacing(0)
        # Create scroll area for taskbar
        self.taskbar_scroll = QScrollArea()
        self.taskbar_scroll.setWidgetResizable(True)
        self.taskbar_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.taskbar_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.taskbar_scroll.setFrameShape(QFrame.NoFrame)
        self.taskbar_scroll.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Added expanding policy
        self.taskbar_scroll.setStyleSheet(f"""
            QScrollArea {{
                background: transparent;
                border: none;
            }}
            QScrollBar:horizontal {{
                background: {TokyoNight.SELECTION};
                height: 6px;
                border-radius: 3px;
            }}
            QScrollBar::handle:horizontal {{
                background: {TokyoNight.BLUE};
                border-radius: 3px;
                min-width: 20px;
            }}
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
                border: none;
                background: none;
            }}
        """)
        # Create taskbar widget
        self.taskbar_widget = QWidget()
        self.taskbar_widget.setStyleSheet(f"background: transparent;")
        self.taskbar_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Added expanding policy
        self.taskbar_layout = QHBoxLayout(self.taskbar_widget)
        self.taskbar_layout.setContentsMargins(0, 0, 0, 0)
        self.taskbar_layout.setSpacing(4)
        self.taskbar_layout.setAlignment(Qt.AlignLeft)
        # Set the taskbar widget as the scroll area's widget
        self.taskbar_scroll.setWidget(self.taskbar_widget)
        taskbar_container_layout.addWidget(self.taskbar_scroll)
        # Add taskbar container to left layout WITH STRETCH FACTOR
        left_layout.addWidget(self.taskbar_container, 1)  # This makes it expand

        # Center section - fixed width
        self.center_widget = QWidget()
        center_layout = QVBoxLayout(self.center_widget)
        center_layout.setContentsMargins(15, 0, 15, 0)
        center_layout.setSpacing(0)
        self.clock_label = QLabel("00:00")
        self.clock_label.setAlignment(Qt.AlignCenter)
        self.clock_label.setStyleSheet(f"""
            font-weight: bold; 
            font-size: 11pt; 
            color: {TokyoNight.MOON_GLOW};
            background: transparent;
            text-shadow: 0px 0px 5px {TokyoNight.MOON_GLOW}40;
        """)
        self.date_label = QLabel("Mon Jan 1")
        self.date_label.setAlignment(Qt.AlignCenter)
        self.date_label.setStyleSheet(f"""
            font-size: 8pt; 
            color: {TokyoNight.FOREGROUND};
            background: transparent;
            opacity: 0.8;
        """)
        self.date_label.setVisible(self.config.show_date)
        center_layout.addWidget(self.clock_label)
        center_layout.addWidget(self.date_label)

        # Right section - fixed width
        self.right_widget = QWidget()
        right_layout = QHBoxLayout(self.right_widget)
        right_layout.setContentsMargins(0, 0, 10, 0)  # Right margin only
        right_layout.setSpacing(8)
        # Notification center
        if self.config.show_notifications:
            self.setup_notification_center(right_layout)
        # Weather widget
        if self.config.show_weather:
            self.setup_weather_widget(right_layout)
        # System monitors
        self.cpu_label = QLabel("Û∞çõ 0%")
        self.mem_label = QLabel("Û∞òö 0%")
        # Apply styling to labels
        for label in [self.cpu_label, self.mem_label]:
            label.setStyleSheet(f"""
                padding: 4px 8px;
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                border-radius: 6px;
                font-size: 9pt;
                color: {TokyoNight.FOREGROUND};
            """)
        right_layout.addWidget(self.cpu_label)
        right_layout.addWidget(self.mem_label)
        # Brightness control
        if self.config.show_brightness_control:
            self.setup_brightness_control(right_layout)
        # Volume control widget
        if self.config.show_volume:
            self.volume_control = VolumeControlWidget(self)
            right_layout.addWidget(self.volume_control)
        # Network Manager control
        if self.config.show_network_control:
            self.network_control = NetworkManagerWidget(self)
            right_layout.addWidget(self.network_control)
        # Bluetooth Manager control  
        if self.config.show_bluetooth_control:
            self.bluetooth_control = BluetoothManagerWidget(self)
            right_layout.addWidget(self.bluetooth_control)
        if self.config.show_battery:
            self.battery_label = QLabel("Û∞Åπ 0%")
            self.battery_label.setStyleSheet(f"""
                padding: 4px 8px;
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                border-radius: 6px;
                font-size: 9pt;
                color: {TokyoNight.FOREGROUND};
            """)
            right_layout.addWidget(self.battery_label)
        if self.config.show_network:
            self.network_label = QLabel("Û∞ñ© --")
            self.network_label.setStyleSheet(f"""
                padding: 4px 8px;
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                border-radius: 6px;
                font-size: 9pt;
                color: {TokyoNight.FOREGROUND};
            """)
            right_layout.addWidget(self.network_label)
        # System tray area
        if self.config.show_tray:
            self.tray_widget = SystemTrayWidget(self)
            self.tray_widget.setMaximumWidth(200)
            right_layout.addWidget(self.tray_widget)
            # Separator before system menu
            sep3 = QFrame()
            sep3.setFrameShape(QFrame.VLine)
            sep3.setFrameShadow(QFrame.Sunken)
            right_layout.addWidget(sep3)
        # System menu button
        self.sys_button = QToolButton()
        self.sys_button.setText("Û∞íì")  # Settings icon
        self.sys_button.setMenu(self.create_system_menu())
        self.sys_button.setPopupMode(QToolButton.InstantPopup)
        self.sys_button.setFixedSize(32, 32)
        right_layout.addWidget(self.sys_button)

        # Add widgets to main layout with stretch factors
        layout.addWidget(self.left_widget, 1)  # Left section expands
        layout.addWidget(self.center_widget, 0)  # Center section fixed
        layout.addWidget(self.right_widget, 0)  # Right section fixed

        # Set panel geometry
        self.update_panel_geometry()

    def showEvent(self, event):
        """Ensure panel uses full width when shown"""
        super().showEvent(event)
        self.update_panel_geometry()
        # Force full width - sometimes needed for multi-monitor setups
        QTimer.singleShot(100, self.force_full_width)

    def force_full_width(self):
        """Force the panel to use the full screen width"""
        screen = QApplication.primaryScreen()
        screen_rect = screen.geometry()
        current_geometry = self.geometry()
        if current_geometry.width() < screen_rect.width():
            self.setGeometry(0, current_geometry.y(), screen_rect.width(), current_geometry.height())

    def update_panel_geometry(self):
        """Update panel position and size - STRETCHED TO FULL SCREEN WIDTH"""
        screen = QApplication.primaryScreen()
        screen_rect = screen.availableGeometry()
        # Use full screen width, not just available geometry
        full_screen_rect = screen.geometry()
        if self.config.position == 'top':
            self.setGeometry(0, 0, full_screen_rect.width(), self.config.height)
        else:  # bottom
            y_pos = full_screen_rect.height() - self.config.height
            self.setGeometry(0, y_pos, full_screen_rect.width(), self.config.height)
        # Update strut after geometry change
        QTimer.singleShot(100, self.setup_strut)

    def setup_strut(self):
        """Setup window strut to reserve space for the panel - USING FULL WIDTH"""
        try:
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()  # Use full geometry, not available
            # Get the window ID
            window_id = int(self.winId())
            # Calculate strut values based on panel position
            if self.config.position == 'top':
                strut_left = 0
                strut_right = 0
                strut_top = self.config.height
                strut_bottom = 0
                # Partial strut values - use full screen width
                strut_partial = (
                    0, 0, self.config.height, 0,
                    0, 0, 0, 0,
                    0, screen_rect.width(),
                    0, 0
                )
            else:  # bottom
                strut_left = 0
                strut_right = 0
                strut_top = 0
                strut_bottom = self.config.height
                # Partial strut values - use full screen width
                strut_partial = (
                    0, 0, 0, self.config.height,
                    0, 0, 0, 0,
                    0, 0,
                    0, screen_rect.width()
                )
            # Set strut properties
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_STRUT", "32cccc",
                "-set", "_NET_WM_STRUT",
                f"{strut_left}, {strut_right}, {strut_top}, {strut_bottom}"
            ], check=False)
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_STRUT_PARTIAL", "32cccc",
                "-set", "_NET_WM_STRUT_PARTIAL",
                f"{strut_partial[0]}, {strut_partial[1]}, {strut_partial[2]}, {strut_partial[3]}, "
                f"{strut_partial[4]}, {strut_partial[5]}, {strut_partial[6]}, {strut_partial[7]}, "
                f"{strut_partial[8]}, {strut_partial[9]}, {strut_partial[10]}, {strut_partial[11]}"
            ], check=False)
            # Set window type to dock
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_WINDOW_TYPE", "32a",
                "-set", "_NET_WM_WINDOW_TYPE", "_NET_WM_WINDOW_TYPE_DOCK"
            ], check=False)
            # Set state to skip taskbar and pager
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_STATE", "32a",
                "-set", "_NET_WM_STATE", 
                "_NET_WM_STATE_SKIP_TASKBAR,_NET_WM_STATE_SKIP_PAGER"
            ], check=False)
        except Exception as e:
            print(f"Failed to set strut: {e}")

    def start_timers(self):
        """Start all timers for updating UI elements"""
        # Clock timer
        self.clock_timer = QTimer()
        self.clock_timer.timeout.connect(self.update_clock)
        self.clock_timer.start(1000)  # Update every second
        # Window list timer
        self.window_timer = QTimer()
        self.window_timer.timeout.connect(self.update_windows)
        self.window_timer.start(2000)  # Update every 2 seconds
        # Initial updates
        self.update_clock()
        self.update_windows()

    def show_panel_context_menu(self, position):
        """Show context menu when right-clicking on the panel"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        # Panel settings
        settings_action = QAction("Û∞íì Panel Settings", self)
        settings_action.triggered.connect(self.show_settings)
        menu.addAction(settings_action)
        menu.addSeparator()
        # Position submenu
        position_menu = QMenu("Û∞ñØ Position", self)
        position_menu.setStyleSheet(menu.styleSheet())
        top_action = QAction("Û∞ñù Top", self)
        top_action.setCheckable(True)
        top_action.setChecked(self.config.position == "top")
        top_action.triggered.connect(lambda: self.set_panel_position("top"))
        position_menu.addAction(top_action)
        bottom_action = QAction("Û∞ñî Bottom", self)
        bottom_action.setCheckable(True)
        bottom_action.setChecked(self.config.position == "bottom")
        bottom_action.triggered.connect(lambda: self.set_panel_position("bottom"))
        position_menu.addAction(bottom_action)
        menu.addMenu(position_menu)
        menu.addSeparator()
        # Panel height
        height_action = QAction("Û∞ñä Height", self)
        height_action.triggered.connect(self.show_height_dialog)
        menu.addAction(height_action)
        # Opacity
        opacity_action = QAction("Û∞óä Opacity", self)
        opacity_action.triggered.connect(self.show_opacity_dialog)
        menu.addAction(opacity_action)
        # Auto-hide toggle
        auto_hide_action = QAction("Û∞ñØ Auto-Hide", self)
        auto_hide_action.setCheckable(True)
        auto_hide_action.setChecked(self.config.auto_hide)
        auto_hide_action.triggered.connect(self.toggle_auto_hide)
        menu.addAction(auto_hide_action)
        menu.addSeparator()
        # Reload/Restart panel
        reload_action = QAction("Û∞ú∫ Reload Panel", self)
        reload_action.triggered.connect(self.reload_panel)
        menu.addAction(reload_action)
        # Quit panel
        quit_action = QAction("Û∞óº Quit Panel", self)
        quit_action.triggered.connect(self.quit_application)
        menu.addAction(quit_action)
        menu.exec_(self.mapToGlobal(position))

    def toggle_auto_hide(self):
        """Toggle auto-hide setting"""
        self.config.auto_hide = not self.config.auto_hide
        if self.config.auto_hide:
            self.auto_hide_timer.start(self.config.auto_hide_delay)
        else:
            self.auto_hide_timer.stop()
            if self.is_hidden:
                self.show_panel()
        # Save config
        config_manager = ConfigManager()
        config_manager.save_config(self.config)

    def set_panel_position(self, position):
        """Set panel position"""
        if position != self.config.position:
            self.config.position = position
            self.update_panel_geometry()
            # Save config
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def show_height_dialog(self):
        """Show dialog to change panel height"""
        height, ok = QInputDialog.getInt(
            self, "Panel Height",
            "Enter panel height (30-100):",
            self.config.height,
            30, 100
        )
        if ok and height != self.config.height:
            self.config.height = height
            self.update_panel_geometry()
            # Save config
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def show_opacity_dialog(self):
        """Show dialog to change panel opacity"""
        opacity, ok = QInputDialog.getDouble(
            self, "Panel Opacity",
            "Enter opacity (0.1-1.0):",
            self.config.opacity,
            0.1, 1.0, 2
        )
        if ok and abs(opacity - self.config.opacity) > 0.01:
            self.config.opacity = opacity
            self.setWindowOpacity(opacity)
            # Save config
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def reload_panel(self):
        """Reload the panel with current configuration"""
        self.setup_ui()
        self.load_xfce_launchers()
        self.setup_strut()

    def setup_workspace_switcher(self, layout):
        """Setup workspace/desktop switcher"""
        self.workspace_widget = QWidget()
        workspace_layout = QHBoxLayout(self.workspace_widget)
        workspace_layout.setContentsMargins(0, 0, 0, 0)
        workspace_layout.setSpacing(2)
        # Get current workspace count
        try:
            result = subprocess.run("wmctrl -d", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                workspaces = result.stdout.splitlines()
                current_workspace = 0
                for i, line in enumerate(workspaces):
                    if "*" in line:
                        current_workspace = i
                        break
                # Create workspace buttons
                self.workspace_buttons = []
                for i in range(len(workspaces)):
                    btn = QPushButton(str(i+1))
                    btn.setFixedSize(28, 28)
                    btn.setProperty("workspace_id", i)
                    # Set initial style based on current workspace
                    if i == current_workspace:
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.BLUE}, 
                                    stop:1 {TokyoNight.PURPLE});
                                color: {TokyoNight.BACKGROUND};
                                border: none;
                                border-radius: 6px;
                                font-weight: bold;
                                font-size: 10pt;
                            }}
                            QPushButton:hover {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.CYAN}, 
                                    stop:1 {TokyoNight.BLUE});
                            }}
                        """)
                    else:
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.SELECTION}, 
                                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                                color: {TokyoNight.FOREGROUND};
                                border: none;
                                border-radius: 6px;
                                font-size: 10pt;
                            }}
                            QPushButton:hover {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.BLUE}40, 
                                    stop:1 {TokyoNight.PURPLE}40);
                            }}
                        """)
                    btn.clicked.connect(lambda checked, w=i: self.switch_workspace(w))
                    workspace_layout.addWidget(btn)
                    self.workspace_buttons.append(btn)
                # Store current workspace
                self.current_workspace = current_workspace
        except Exception as e:
            print(f"Error setting up workspaces: {e}")
        layout.addWidget(self.workspace_widget)

    def switch_workspace(self, workspace_id):
        """Switch to the specified workspace"""
        try:
            subprocess.run(f"wmctrl -s {workspace_id}", shell=True)
            # Update button styles
            for i, btn in enumerate(self.workspace_buttons):
                if i == workspace_id:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.BLUE}, 
                                stop:1 {TokyoNight.PURPLE});
                            color: {TokyoNight.BACKGROUND};
                            border: none;
                            border-radius: 6px;
                            font-weight: bold;
                            font-size: 10pt;
                        }}
                        QPushButton:hover {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.CYAN}, 
                                stop:1 {TokyoNight.BLUE});
                        }}
                    """)
                else:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.SELECTION}, 
                                stop:1 {TokyoNight.NIGHT_BOTTOM});
                            color: {TokyoNight.FOREGROUND};
                            border: none;
                            border-radius: 6px;
                            font-size: 10pt;
                        }}
                        QPushButton:hover {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.BLUE}40, 
                                stop:1 {TokyoNight.PURPLE}40);
                        }}
                    """)
            # Update current workspace
            self.current_workspace = workspace_id
        except Exception as e:
            print(f"Error switching workspace: {e}")

    def update_workspace_display(self, workspace_id):
        """Update workspace display when workspace changes"""
        if hasattr(self, 'workspace_buttons') and workspace_id < len(self.workspace_buttons):
            # Update button styles
            for i, btn in enumerate(self.workspace_buttons):
                if i == workspace_id:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.BLUE}, 
                                stop:1 {TokyoNight.PURPLE});
                            color: {TokyoNight.BACKGROUND};
                            border: none;
                            border-radius: 6px;
                            font-weight: bold;
                            font-size: 10pt;
                        }}
                        QPushButton:hover {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.CYAN}, 
                                stop:1 {TokyoNight.BLUE});
                        }}
                    """)
                else:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.SELECTION}, 
                                stop:1 {TokyoNight.NIGHT_BOTTOM});
                            color: {TokyoNight.FOREGROUND};
                            border: none;
                            border-radius: 6px;
                            font-size: 10pt;
                        }}
                        QPushButton:hover {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.BLUE}40, 
                                stop:1 {TokyoNight.PURPLE}40);
                        }}
                    """)
            # Update current workspace
            self.current_workspace = workspace_id

    def setup_brightness_control(self, layout):
        """Setup brightness control slider"""
        # Brightness icon
        brightness_icon = QLabel("Û∞É†")
        brightness_icon.setStyleSheet(f"color: {TokyoNight.YELLOW}; font-size: 12pt;")
        layout.addWidget(brightness_icon)
        # Brightness slider
        self.brightness_slider = QSlider(Qt.Horizontal)
        self.brightness_slider.setRange(10, 100)
        self.brightness_slider.setFixedWidth(80)
        self.brightness_slider.valueChanged.connect(self.set_brightness)
        layout.addWidget(self.brightness_slider)

    def set_brightness(self, value):
        """Set screen brightness"""
        try:
            subprocess.run(f"brightnessctl set {value}%", shell=True,
                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"Failed to set brightness: {e}")

    def setup_weather_widget(self, layout):
        """Setup weather widget"""
        self.weather_label = QLabel("Û∞ñê --¬∞C")
        self.weather_label.setStyleSheet(f"""
            padding: 4px 8px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 9pt;
            color: {TokyoNight.FOREGROUND};
        """)
        layout.addWidget(self.weather_label)
        # Start weather update timer (update every 30 minutes)
        self.weather_timer = QTimer()
        self.weather_timer.timeout.connect(self.update_weather)
        self.weather_timer.start(1800000)  # 30 minutes
        # Initial weather update
        self.update_weather()

    def update_weather(self):
        """Update weather information"""
        # Check if weather_label exists
        if not hasattr(self, 'weather_label'):
            return
        try:
            # Build location parameter
            location = self.config.weather_location if self.config.weather_location else ""
            if location:
                location_url = f"{location}"
            else:
                location_url = ""
            # Using wttr.in for weather data
            result = subprocess.run(
                f"curl -s 'wttr.in/{location_url}?format=%C+%t'",
                shell=True, capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0 and result.stdout.strip():
                weather_data = result.stdout.strip()
                # Format: "Condition +temp"
                parts = weather_data.split('+')
                if len(parts) == 2:
                    condition = parts[0].strip()
                    temp = parts[1].strip()
                    # Map weather conditions to icons
                    weather_icons = {
                        "Clear": "Û∞ñô", "Sunny": "Û∞ñô", "Partly cloudy": "Û∞ñï",
                        "Cloudy": "Û∞ñê", "Overcast": "Û∞ñê", "Fog": "Û∞ñë",
                        "Rain": "Û∞ñó", "Drizzle": "Û∞ñó", "Snow": "Û∞ñò",
                        "Thunderstorm": "Û∞ñì", "Mist": "Û∞ñë", "Patchy rain": "Û∞ñó",
                        "Light rain": "Û∞ñó", "Moderate rain": "Û∞ñó", "Heavy rain": "Û∞ñó"
                    }
                    icon = weather_icons.get(condition, "Û∞ñê")
                    self.weather_label.setText(f"{icon} {temp}")
            else:
                self.weather_label.setText("Û∞ñê --¬∞C")
        except Exception as e:
            print(f"Error updating weather: {e}")
            self.weather_label.setText("Û∞ñê --¬∞C")

    def setup_notification_center(self, layout):
        """Setup notification center"""
        self.notification_btn = QPushButton("Û∞Çö")
        self.notification_btn.setFixedSize(32, 32)
        self.notification_btn.clicked.connect(self.show_notifications)
        self.notification_btn.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        layout.addWidget(self.notification_btn)
        # Track notification count
        self.update_notification_count()
        # Start notification monitoring
        self.notification_timer = QTimer()
        self.notification_timer.timeout.connect(self.update_notification_count)
        self.notification_timer.start(5000)  # Check every 5 seconds

    def update_notification_count(self):
        """Update notification count"""
        # Check if notification_btn exists
        if not hasattr(self, 'notification_btn'):
            return
        try:
            # Try different notification systems
            count = 0
            # Try dunst
            result = subprocess.run(
                "dunstctl count 2>/dev/null || echo 0",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # Parse the output to extract the waiting count
                output = result.stdout.strip()
                if output.isdigit():
                    count = int(output)
                else:
                    # Extract the waiting count from multi-line output
                    match = re.search(r'Waiting:\s+(\d+)', output)
                    if match:
                        count = int(match.group(1))
            else:
                # Try mako
                result = subprocess.run(
                    "makoctl list 2>/dev/null | grep -c 'app-name' || echo 0",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    count = int(result.stdout.strip())
            if count > 0:
                self.notification_btn.setText(f"Û∞Çö {count}")
                self.notification_btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}, 
                            stop:1 {TokyoNight.PURPLE});
                        color: {TokyoNight.BACKGROUND};
                        border: none;
                        border-radius: 6px;
                        font-size: 12pt;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.CYAN}, 
                            stop:1 {TokyoNight.BLUE});
                    }}
                """)
            else:
                self.notification_btn.setText("Û∞Çö")
                self.notification_btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.SELECTION}, 
                            stop:1 {TokyoNight.NIGHT_BOTTOM});
                        color: {TokyoNight.FOREGROUND};
                        border: none;
                        border-radius: 6px;
                        font-size: 12pt;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}40, 
                            stop:1 {TokyoNight.PURPLE}40);
                    }}
                """)
        except Exception as e:
            print(f"Error updating notification count: {e}")

    def show_notifications(self):
        """Show notification history"""
        try:
            # Try dunst
            subprocess.run("dunstctl history-pop 2>/dev/null", shell=True)
        except:
            try:
                # Try mako
                subprocess.run("makoctl restore 2>/dev/null", shell=True)
            except:
                print("No supported notification system found")

    def get_stylesheet(self):
        """Return enhanced dark night themed stylesheet"""
        corner_radius = f"{self.config.corner_radius}px" if self.config.rounded_corners else "0px"
        return f"""
            QMainWindow {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}CC, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM}CC,
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT}CC);
                border: 1px solid {TokyoNight.NEBULA}60;
                border-radius: {corner_radius};
            }}
            QWidget#centralwidget {{
                background: transparent;
                border-radius: {corner_radius};
            }}
            QToolButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QToolButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
            QToolButton:pressed {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}60, 
                    stop:1 {TokyoNight.PURPLE}60);
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                padding: 6px 12px;
                border-radius: 6px;
                font-family: "JetBrains Mono Nerd Font";
                font-size: 9pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
            QPushButton:pressed {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}60, 
                    stop:1 {TokyoNight.PURPLE}60);
            }}
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
            QFrame[frameShape="4"] {{
                background: {TokyoNight.NEBULA}40;
                max-width: 1px;
            }}
            QSlider::groove:horizontal {{
                border: none;
                height: 4px;
                background: {TokyoNight.NEBULA};
                border-radius: 2px;
            }}
            QSlider::handle:horizontal {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                border: none;
                width: 12px;
                margin: -4px 0;
                border-radius: 6px;
            }}
            QSlider::handle:horizontal:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """

    def create_applications_menu(self):
        """Create applications menu with Nerd Font icons and workspace options"""
        menu = QMenu(self)
        menu.setStyleSheet(self.get_stylesheet())
        
        # Common applications with Nerd Font icons
        apps = [
            ("Û∞Üç Terminal", self.config.terminal_command, "terminal"),
            ("Û∞âã File Manager", self.config.file_manager_command, "folder"),
            ("Û∞àπ Web Browser", self.config.browser_command, "browser"),
            ("Û∞à¨ Text Editor", self.config.text_editor_command, "text"),
            ("Û∞É§ Settings", self.config.settings_command, "settings"),
            ("Û∞éÅ Calculator", self.config.calculator_command, "calculator"),
            ("Û∞äì Screenshot", self.config.screenshot_command, "camera"),
            ("Û∞ª≠ Image Viewer", self.config.image_viewer_command, "image"),
            ("Û∞éÑ Music Player", self.config.music_player_command, "music", self.config.music_player_args),
        ]

        # Add workspace submenus for each app
        for name, command, icon, *args in apps:
            app_menu = QMenu(name, self)
            app_menu.setStyleSheet(menu.styleSheet())
            
            # Get workspace options
            workspaces = self.get_workspace_options()
            
            for ws_name, ws_id in workspaces:
                ws_action = QAction(ws_name, self)
                extra_args = args[0] if args else ""
                ws_action.triggered.connect(lambda checked, cmd=command, extra=extra_args, wid=ws_id: 
                                          self.launch_application(cmd, extra, wid))
                app_menu.addAction(ws_action)
            
            menu.addMenu(app_menu)

        menu.addSeparator()
        
        # Power menu (unchanged)
        power_menu = QMenu("Û∞ê• Power", self)
        power_menu.setStyleSheet(self.get_stylesheet())
        power_actions = [
            ("Û∞óΩ Log Out", "xfce4-session-logout"),
            ("Û∞úâ Reboot", "systemctl reboot"),
            ("Û∞ê• Shutdown", "systemctl poweroff"),
            ("Û∞í≤ Suspend", "systemctl suspend"),
        ]
        for name, command in power_actions:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, cmd=command: self.execute_command(cmd))
            power_menu.addAction(action)
        menu.addMenu(power_menu)
        
        return menu

    def get_workspace_options(self):
        """Get workspace options for menu"""
        options = [("Current Workspace", -1)]
        try:
            result = subprocess.run("wmctrl -d", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                for i, line in enumerate(result.stdout.splitlines()):
                    parts = line.split()
                    if len(parts) >= 9:
                        name_parts = parts[8:]
                        ws_name = ' '.join(name_parts)
                        options.append((f"Workspace {i+1}: {ws_name}", i))
                    else:
                        options.append((f"Workspace {i+1}", i))
        except:
            # Fallback options
            for i in range(4):
                options.append((f"Workspace {i+1}", i))
        return options

    def create_system_menu(self):
        """Create system menu"""
        menu = QMenu(self)
        menu.setStyleSheet(self.get_stylesheet())
        # Volume control - now launches pavucontrol
        vol_action = QAction("Û∞ïæ Volume Control", self)
        vol_action.triggered.connect(self.launch_pavucontrol)
        menu.addAction(vol_action)
        # Network Manager action
        net_action = QAction("Û∞§® Network Manager", self)
        net_action.triggered.connect(self.launch_network_manager)
        menu.addAction(net_action)
        # Bluetooth Manager action
        bt_action = QAction("Û∞ÇØ Bluetooth Manager", self)
        bt_action.triggered.connect(self.launch_bluetooth_manager)
        menu.addAction(bt_action)
        menu.addSeparator()
        # System tools
        tools_actions = [
            ("Û∞çõ System Monitor", "gnome-system-monitor"),
            ("Û∞íì Settings", "xfce4-settings-manager"),
        ]
        for name, command in tools_actions:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, cmd=command: self.launch_application(cmd))
            menu.addAction(action)
        menu.addSeparator()
        # Panel settings
        settings_action = QAction("Û∞íí Panel Settings", self)
        settings_action.triggered.connect(self.show_settings)
        menu.addAction(settings_action)
        return menu

    def show_settings(self):
        """Show settings dialog"""
        dialog = SettingsDialog(self.config, self)
        if dialog.exec_() == QDialog.Accepted:
            # Update panel configuration
            old_config = self.config
            self.config = dialog.config
            
            # Save configuration immediately
            config_manager = ConfigManager()
            config_manager.save_config(self.config)
            print("DEBUG: Settings saved immediately after dialog close")  # Debug line
            
            # Reload the panel with new settings
            self.setup_ui()
            self.load_xfce_launchers()  # This will reload both XFCE and custom launchers
            self.setup_strut()
            
            # Update applications menu with new commands
            self.apps_button.setMenu(self.create_applications_menu())
            
            # Update auto-hide settings
            if self.config.auto_hide:
                self.auto_hide_timer.start(self.config.auto_hide_delay)
            else:
                self.auto_hide_timer.stop()
                if self.is_hidden:
                    self.show_panel()

    def launch_pavucontrol(self):
        """Launch pavucontrol"""
        try:
            # Check if pavucontrol is already running
            result = subprocess.run(
                "pgrep -f pavucontrol",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # If running, focus it
                subprocess.run(
                    "wmctrl -a pavucontrol",
                    shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                )
            else:
                # Launch pavucontrol
                subprocess.Popen(
                    ["pavucontrol"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
        except Exception as e:
            print(f"Failed to launch pavucontrol: {e}")

    def launch_network_manager(self):
        """Launch network manager"""
        if hasattr(self, 'network_control'):
            self.network_control.launch_network_manager()
        else:
            # Fallback if widget not available
            try:
                subprocess.Popen(
                    ["nm-connection-editor"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except:
                subprocess.Popen(
                    ["nm-applet"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )

    def launch_bluetooth_manager(self):
        """Launch bluetooth manager"""
        if hasattr(self, 'bluetooth_control'):
            self.bluetooth_control.launch_bluetooth_manager()
        else:
            # Fallback if widget not available
            try:
                subprocess.Popen(
                    ["blueman-manager"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except:
                print("Bluetooth manager not available")

    def load_applications(self):
        """Load common applications"""
        self.applications = [
            Application("Web Browser", "firefox", "üåê"),
            Application("Text Editor", "mousepad", "üìù"),
            Application("Calculator", "gnome-calculator", "üßÆ"),
        ]



    def load_xfce_launchers(self):
        """Load XFCE panel launchers and custom launchers"""
        # Always load custom launchers first
        combined_launchers = []
        if self.config.launcher_customizations:
            combined_launchers.extend(self.config.launcher_customizations)
            print(f"DEBUG: Loaded {len(self.config.launcher_customizations)} custom launchers from config")  # Debug line

        # Then load XFCE launchers if the setting is enabled
        if self.config.show_xfce_launchers:
            try:
                reader = XfceLauncherReader()
                xfce_launchers = reader.get_xfce_launchers()
                combined_launchers.extend(xfce_launchers)
                print(f"DEBUG: Loaded {len(xfce_launchers)} XFCE launchers")  # Debug line
            except Exception as e:
                print(f"Error loading XFCE launchers: {e}")

        # Update the internal list
        self.xfce_launchers = combined_launchers
        # Update the display - always show if there are custom launchers
        should_show = self.config.show_xfce_launchers or bool(self.config.launcher_customizations)
        self.xfce_launchers_widget.setVisible(should_show)
        # Update the actual buttons displayed in the widget
        self.update_xfce_launchers_display()








    def update_xfce_launchers_display(self):
        """Update the XFCE launchers display - now handles system icons and workspace targeting."""
        # Clear existing launcher buttons
        for i in reversed(range(self.xfce_launchers_layout.count())):
            widget = self.xfce_launchers_layout.itemAt(i).widget()
            if widget:
                widget.deleteLater()
        
        # Add launcher buttons for the combined list
        for launcher in self.xfce_launchers: # Uses the combined list from load_xfce_launchers
            btn = QToolButton()
            
            # Set tooltip with workspace info
            workspace_info = "Current workspace" if launcher.workspace == -1 else f"Workspace {launcher.workspace + 1}"
            btn.setToolTip(f"{launcher.name}\nOpen in: {workspace_info}")
            
            btn.setFixedSize(32, 32)
            
            # Icon loading logic (existing code)
            icon_input = launcher.icon
            icon_set = False
            
            if icon_input and icon_input.startswith('/'):
                if os.path.isfile(icon_input):
                    try:
                        icon_from_file = QIcon(icon_input)
                        if not icon_from_file.isNull():
                            btn.setIcon(icon_from_file)
                            btn.setIconSize(QSize(24, 24))
                            icon_set = True
                    except:
                        pass

            if not icon_set and icon_input:
                system_icon = QIcon.fromTheme(icon_input)
                if not system_icon.isNull():
                    btn.setIcon(system_icon)
                    btn.setIconSize(QSize(24, 24))
                    icon_set = True

            if not icon_set:
                btn.setText(icon_input or "üöÄ")
            else:
                btn.setText("")
            
            # FIX: Connect with workspace parameter - THIS WAS MISSING
            btn.clicked.connect(lambda checked, cmd=launcher.command, args=launcher.args, ws=launcher.workspace: 
                               self.launch_application(cmd, args, ws))
            self.xfce_launchers_layout.addWidget(btn)
        
        print(f"Updated launcher display with {len(self.xfce_launchers)} buttons (XFCE + Custom)")


    def launch_application(self, command, args="", workspace=-1):
        """Launch an application with optional arguments and workspace targeting"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            
            print(f"Launching: {command} with workspace target: {workspace} (current: {current_workspace})")
            
            # Build the command list properly
            cmd_list = command.split() if ' ' in command else [command]
            if args:
                cmd_list.extend(args.split())
            
            # Launch the application
            process = subprocess.Popen(cmd_list, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # If workspace is specified and different from current, move the window
            if workspace >= 0 and workspace != current_workspace:
                print(f"Will move application to workspace {workspace}")
                
                # Use multiple methods to ensure window gets moved
                # Method 1: Try to move by PID after a delay
                QTimer.singleShot(1000, lambda: self.move_window_to_workspace(process.pid, workspace))
                
                # Method 2: Try to move by window title/class as backup
                app_name = os.path.basename(command.split()[0])  # Get app name from command
                QTimer.singleShot(2000, lambda: self.ensure_window_in_workspace(app_name, workspace))
                
            elif workspace >= 0:
                print(f"Application already on target workspace {workspace}")
                
        except Exception as e:
            print(f"Failed to launch {command}: {e}")

    def move_window_to_workspace(self, pid, workspace_id):
        """Move a window to a specific workspace by PID"""
        try:
            print(f"Attempting to move window with PID {pid} to workspace {workspace_id}")
            
            # Wait a bit more for the window to fully appear
            time.sleep(0.5)
            
            # Find window by PID and move it to target workspace
            result = subprocess.run(
                f"wmctrl -l -p | grep ' {pid} ' | head -1 | cut -d' ' -f1",
                shell=True, capture_output=True, text=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Found window {window_id} for PID {pid}, moving to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
                print(f"Window {window_id} moved to workspace {workspace_id}")
            else:
                print(f"No window found for PID {pid}, trying alternative methods")
                # Try alternative method
                self.move_recent_window_to_workspace(workspace_id)
                
        except Exception as e:
            print(f"Error moving window to workspace: {e}")

    def move_recent_window_to_workspace(self, workspace_id):
        """Move the most recent window to target workspace"""
        try:
            print(f"Moving most recent window to workspace {workspace_id}")
            
            # Get list of windows and move the most recent one
            result = subprocess.run("wmctrl -l | tail -1 | cut -d' ' -f1", 
                                  shell=True, capture_output=True, text=True)
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Moving recent window {window_id} to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
                print(f"Recent window moved to workspace {workspace_id}")
        except Exception as e:
            print(f"Error moving recent window: {e}")

    def ensure_window_in_workspace(self, app_name, workspace_id):
        """Ensure the application window ends up in the target workspace"""
        try:
            print(f"Ensuring {app_name} window is in workspace {workspace_id}")
            
            # Try to find window by application name
            result = subprocess.run(
                f"wmctrl -l | grep -i '{app_name}' | tail -1 | cut -d' ' -f1",
                shell=True, capture_output=True, text=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Found {app_name} window {window_id}, moving to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
                print(f"{app_name} window moved to workspace {workspace_id}")
            else:
                print(f"No {app_name} window found, trying to move most recent window")
                # Move the most recent window as fallback
                self.move_recent_window_to_workspace(workspace_id)
                
        except Exception as e:
            print(f"Error ensuring window in workspace: {e}")

    def move_window_to_workspace(self, pid, workspace_id):
        """Move a window to a specific workspace by PID"""
        try:
            # Wait a bit more for the window to fully appear
            time.sleep(0.5)
            
            # Find window by PID and move it to target workspace
            result = subprocess.run(
                f"wmctrl -l -p | grep {pid} | head -1 | cut -d' ' -f1",
                shell=True, capture_output=True, text=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Moving window {window_id} to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
            else:
                # Alternative method: find window by class name
                self.move_window_by_class_to_workspace(workspace_id)
                
        except Exception as e:
            print(f"Error moving window to workspace: {e}")

    def move_window_by_class_to_workspace(self, workspace_id):
        """Alternative method to move the most recent window to target workspace"""
        try:
            # Get list of windows and move the most recent one
            result = subprocess.run("wmctrl -l | tail -1 | cut -d' ' -f1", 
                                  shell=True, capture_output=True, text=True)
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Moving recent window {window_id} to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
        except Exception as e:
            print(f"Error moving recent window: {e}")

    def ensure_window_in_workspace(self, app_name, workspace_id):
        """Ensure the application window ends up in the target workspace"""
        try:
            # Try to find window by application name
            result = subprocess.run(
                f"wmctrl -l | grep -i '{app_name}' | tail -1 | cut -d' ' -f1",
                shell=True, capture_output=True, text=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Moving {app_name} window {window_id} to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
            else:
                # Move the most recent window as fallback
                result = subprocess.run("wmctrl -l | tail -1 | cut -d' ' -f1", 
                                      shell=True, capture_output=True, text=True)
                if result.returncode == 0 and result.stdout.strip():
                    window_id = result.stdout.strip()
                    print(f"Moving recent window {window_id} to workspace {workspace_id}")
                    subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
                    
        except Exception as e:
            print(f"Error ensuring window in workspace: {e}")

    def execute_command(self, command):
        """Execute a system command"""
        try:
            subprocess.Popen(command.split(), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"Failed to execute {command}: {e}")

    def setup_system_monitor(self):
        """Setup system monitoring thread"""
        self.monitor_thread = SystemMonitorThread()
        self.monitor_thread.cpu_updated.connect(self.update_cpu_display)
        self.monitor_thread.memory_updated.connect(self.update_memory_display)
        self.monitor_thread.battery_updated.connect(self.update_battery_display)
        self.monitor_thread.volume_updated.connect(self.update_volume_display)
        self.monitor_thread.network_updated.connect(self.update_network_display)
        self.monitor_thread.brightness_updated.connect(self.update_brightness_display)
        self.monitor_thread.workspace_updated.connect(self.update_workspace_display)
        self.monitor_thread.active_window_updated.connect(self.update_active_window)
        self.monitor_thread.start()

    def update_cpu_display(self, usage):
        """Update CPU display with color coding"""
        color = TokyoNight.GREEN if usage < 50 else TokyoNight.YELLOW if usage < 80 else TokyoNight.RED
        self.cpu_label.setText(f"Û∞çõ <font color='{color}'>{usage:.0f}%</font>")

    def update_memory_display(self, usage):
        """Update memory display with color coding"""
        color = TokyoNight.GREEN if usage < 60 else TokyoNight.YELLOW if usage < 85 else TokyoNight.RED
        self.mem_label.setText(f"Û∞òö <font color='{color}'>{usage:.0f}%</font>")

    def update_battery_display(self, capacity, status, time_str):
        """Update battery display with dynamic icons and time information"""
        # Check if battery_label exists
        if not hasattr(self, 'battery_label'):
            return
        # Battery icons based on level
        battery_icons = ["Û∞Çé", "Û∞Å∫", "Û∞Åª", "Û∞Åº", "Û∞ÅΩ", "Û∞Åæ", "Û∞Åø", "Û∞ÇÄ", "Û∞ÇÅ", "Û∞ÇÇ", "Û∞Åπ"]
        icon_index = min(len(battery_icons) - 1, capacity // 10)
        icon = battery_icons[icon_index]
        if status == "Charging":
            icon = "Û∞ÇÑ"  # Charging icon
        
        # Battery capacity color
        capacity_color = (TokyoNight.GREEN if capacity > 50
                         else TokyoNight.YELLOW if capacity > 20
                         else TokyoNight.RED)
        
        # Build display text with time information
        display_text = f"{icon} <font color='{capacity_color}'>{capacity}%</font>"
        
        # Add time information if available - CHANGED COLORS HERE
        if time_str:
            if status.lower() == "discharging":
                # Use yellow for discharging time to make it more visible
                display_text += f" <font color='{TokyoNight.YELLOW}'>({time_str})</font>"
            elif status.lower() == "charging":
                display_text += f" <font color='{TokyoNight.GREEN}'>({time_str})</font>"
            elif status.lower() == "full":
                display_text += f" <font color='{TokyoNight.GREEN}'>(Full)</font>"
        
        self.battery_label.setText(display_text)

    def update_volume_display(self, volume, muted):
        """Update volume display"""
        if hasattr(self, 'volume_control'):
            self.volume_control.update_volume_display(volume, muted)

    def update_network_display(self, ssid, status):
        """Update network display"""
        # Check if network_label exists
        if not hasattr(self, 'network_label'):
            return
        if status == "connected":
            icon = "Û∞ñ©" if ssid else "Û∞àÄ"  # WiFi vs Ethernet
            color = TokyoNight.GREEN
            text = ssid[:12] if ssid else "Ethernet"
        else:
            icon = "Û∞ñ™"
            color = TokyoNight.RED
            text = "Offline"
        self.network_label.setText(f"{icon} <font color='{color}'>{text}</font>")

    def update_brightness_display(self, brightness):
        """Update brightness slider position"""
        if hasattr(self, 'brightness_slider'):
            self.brightness_slider.blockSignals(True)
            self.brightness_slider.setValue(brightness)
            self.brightness_slider.blockSignals(False)

    def update_clock(self):
        """Update clock display"""
        now = datetime.now()
        time_str = now.strftime("%I:%M %p")
        date_str = now.strftime("%a %b %d")
        self.clock_label.setText(time_str)
        self.date_label.setText(date_str)

    def update_windows(self):
        """Update window list"""
        try:
            result = subprocess.run("wmctrl -l", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                self.update_taskbar(result.stdout)
        except Exception as e:
            print(f"Window update error: {e}")

    def update_taskbar(self, wmctrl_output):
        """Update taskbar with current windows"""
        # Clear existing window buttons
        for i in reversed(range(self.taskbar_layout.count())):
            widget = self.taskbar_layout.itemAt(i).widget()
            if widget and hasattr(widget, 'is_window_button'):
                widget.deleteLater()
        # Add new window buttons
        windows = []
        for line in wmctrl_output.splitlines():
            parts = line.split(None, 3)
            if len(parts) >= 4:
                window_id, desktop, host, title = parts
                if desktop != '-1':  # Skip sticky windows
                    windows.append({'id': window_id, 'title': title})

        # Add buttons for windows (limit to 6)
        for window in windows[:6]:
            btn = QPushButton(window['title'][:18])  # Truncate long titles
            btn.setFixedHeight(28)
            btn.is_window_button = True
            btn.setProperty("window_id", window['id'])
            btn.clicked.connect(lambda checked, wid=window['id']: self.focus_window(wid))
            # Check if this is the active window
            if window['id'] == self.active_window_id:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}, 
                            stop:1 {TokyoNight.PURPLE});
                        color: {TokyoNight.BACKGROUND};
                        border: none;
                        border-radius: 6px;
                        font-weight: bold;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.CYAN}, 
                            stop:1 {TokyoNight.BLUE});
                    }}
                """)
            else:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.SELECTION}, 
                            stop:1 {TokyoNight.NIGHT_BOTTOM});
                        color: {TokyoNight.FOREGROUND};
                        border: none;
                        border-radius: 6px;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}40, 
                            stop:1 {TokyoNight.PURPLE}40);
                    }}
                """)
            # Add context menu support
            btn.setContextMenuPolicy(Qt.CustomContextMenu)
            btn.customContextMenuRequested.connect(self.show_window_menu)
            self.taskbar_layout.addWidget(btn)

        # Update the taskbar widget size to ensure proper scrolling
        self.taskbar_widget.adjustSize()

    def show_window_menu(self, position):
        """Show context menu for window button"""
        btn = self.sender()
        window_id = btn.property('window_id')
        if window_id:
            self.show_window_menu_at_position(btn.mapToGlobal(position), window_id)

    def show_window_menu_at_position(self, position, window_id):
        """Show window context menu at specified position"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        # Window actions
        actions = [
            ("Û∞ñ© Focus", self.focus_window),
            ("Û∞ñ∞ Maximize", self.maximize_window),
            ("Û∞ñØ Minimize", self.minimize_window),
            ("Û∞ñ™ Close", self.close_window),
            ("Û∞íì Move", self.move_window),
            ("Û∞íç Always on Top", self.set_always_on_top),
            ("Û∞Ç∏ Unstick", self.unstick_window),
            ("Û∞òö Always Below", self.set_always_below),
            ("Û∞Ç∏ Pin to Workspace", self.pin_to_workspace),
            ("Û∞Çä Move to Workspace", self.move_to_workspace),
            ("Û∞îÅ Send to Workspace", self.send_to_workspace)
        ]
        for name, callback in actions:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, func=callback: func(window_id))
            menu.addAction(action)
        menu.exec_(position)

    def focus_window(self, window_id):
        """Focus a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -a {window_id}", shell=True)
        except Exception as e:
            print(f"Focus error: {e}")

    def minimize_window(self, window_id):
        """Minimize a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,hidden", shell=True)
        except Exception as e:
            print(f"Minimize error: {e}")

    def maximize_window(self, window_id):
        """Maximize a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,maximized_vert,maximized_horz", shell=True)
        except Exception as e:
            print(f"Maximize error: {e}")

    def close_window(self, window_id):
        """Close a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -c {window_id}", shell=True)
        except Exception as e:
            print(f"Close error: {e}")

    def move_window(self, window_id):
        """Move a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,move", shell=True)
        except Exception as e:
            print(f"Move error: {e}")

    def set_always_on_top(self, window_id):
        """Set window to always on top"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,above", shell=True)
        except Exception as e:
            print(f"Always on top error: {e}")

    def unstick_window(self, window_id):
        """Unstick a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b remove,sticky", shell=True)
        except Exception as e:
            print(f"Unstick error: {e}")

    def set_always_below(self, window_id):
        """Set window to always below"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,below", shell=True)
        except Exception as e:
            print(f"Always below error: {e}")

    def pin_to_workspace(self, window_id):
        """Pin window to current workspace"""
        try:
            current_workspace = self.current_workspace
            subprocess.run(f"wmctrl -i -r {window_id} -b add,sticky", shell=True)
        except Exception as e:
            print(f"Pin to workspace error: {e}")

    def move_to_workspace(self, window_id):
        """Move window to a specific workspace"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            # Show dialog to select workspace
            workspace_id, ok = QInputDialog.getInt(
                self, "Move to Workspace",
                f"Enter workspace number (0-{current_workspace + 10}):",
                current_workspace,
                0, current_workspace + 10
            )
            if ok:
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
        except Exception as e:
            print(f"Move to workspace error: {e}")

    def send_to_workspace(self, window_id):
        """Send window to a specific workspace"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            # Show dialog to select workspace
            workspace_id, ok = QInputDialog.getInt(
                self, "Send to Workspace",
                f"Enter workspace number (0-{current_workspace + 10}):",
                current_workspace,
                0, current_workspace + 10
            )
            if ok:
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
        except Exception as e:
            print(f"Send to workspace error: {e}")

    def update_active_window(self, window_id):
        """Update the active window indicator"""
        self.active_window_id = window_id
        # Update taskbar to highlight active window
        self.update_windows()

    def restart_panel(self):
        """Restart the panel"""
        # Save current config
        config_manager = ConfigManager()
        config_manager.save_config(self.config)
        # Restart the application
        QApplication.quit()
        subprocess.Popen([sys.executable] + sys.argv)

    def quit_application(self):
        """Quit the application"""
        QApplication.quit()



# ... (existing classes like TokyoNight, Application, GlobalKeyHandler, etc., remain the same)

class ConfigManager:
    """Configuration manager for saving/loading settings"""
    def __init__(self, config_file=None):
        if config_file is None:
            config_dir = Path.home() / ".config" / "tokyo-night-panel"
            config_dir.mkdir(parents=True, exist_ok=True)
            config_file = config_dir / "panel.conf"
        self.config_file = Path(config_file)
        self.settings = QSettings(str(self.config_file), QSettings.IniFormat)

    def save_config(self, config: PanelConfig):
        """Save configuration to file"""
        self.settings.setValue("position", config.position)
        self.settings.setValue("height", config.height)
        self.settings.setValue("opacity", config.opacity)
        self.settings.setValue("blur_effect", config.blur_effect)
        self.settings.setValue("show_date", config.show_date)
        self.settings.setValue("show_battery", config.show_battery)
        self.settings.setValue("show_volume", config.show_volume)
        self.settings.setValue("show_network", config.show_network)
        self.settings.setValue("show_tray", config.show_tray)
        self.settings.setValue("show_xfce_launchers", config.show_xfce_launchers)
        self.settings.setValue("theme_variant", config.theme_variant)
        self.settings.setValue("rounded_corners", config.rounded_corners)
        self.settings.setValue("corner_radius", config.corner_radius)
        # New features
        self.settings.setValue("show_workspace_switcher", config.show_workspace_switcher)
        self.settings.setValue("show_brightness_control", config.show_brightness_control)
        self.settings.setValue("show_weather", config.show_weather)
        self.settings.setValue("show_notifications", config.show_notifications)
        # NEW: Network and Bluetooth controls
        self.settings.setValue("show_network_control", config.show_network_control)
        self.settings.setValue("show_bluetooth_control", config.show_bluetooth_control)
        self.settings.setValue("weather_location", config.weather_location)
        # Auto-hide settings
        self.settings.setValue("auto_hide", config.auto_hide)
        self.settings.setValue("auto_hide_delay", config.auto_hide_delay)
        self.settings.setValue("show_on_edge", config.show_on_edge)
        self.settings.setValue("edge_size", config.edge_size)

        # Save built-in launcher commands
        self.settings.setValue("terminal_command", config.terminal_command)
        self.settings.setValue("file_manager_command", config.file_manager_command)
        self.settings.setValue("browser_command", config.browser_command)
        self.settings.setValue("text_editor_command", config.text_editor_command)
        self.settings.setValue("settings_command", config.settings_command)
        self.settings.setValue("calculator_command", config.calculator_command)
        self.settings.setValue("screenshot_command", config.screenshot_command)
        self.settings.setValue("image_viewer_command", config.image_viewer_command)
        self.settings.setValue("music_player_command", config.music_player_command)
        self.settings.setValue("music_player_args", config.music_player_args)

        # Save custom launchers
        if config.launcher_customizations:
            launchers_data = []
            for launcher in config.launcher_customizations:
                # Convert the Application dataclass to a dictionary
                launcher_dict = {
                    'name': launcher.name,
                    'command': launcher.command,
                    'icon': launcher.icon,
                    'args': launcher.args,
                    'workspace': launcher.workspace  # ADDED: Save workspace setting
                }
                launchers_data.append(launcher_dict)
            self.settings.setValue("launcher_customizations", launchers_data)
            print(f"DEBUG: ConfigManager saved {len(launchers_data)} custom launchers")
        else:
            self.settings.setValue("launcher_customizations", [])
            print("DEBUG: ConfigManager saved empty custom launchers list")
        
        self.settings.sync()

    def load_config(self) -> PanelConfig:
        """Load configuration from file"""
        config = PanelConfig()
        config.position = self.settings.value("position", "top", type=str)
        config.height = self.settings.value("height", 40, type=int)
        config.opacity = self.settings.value("opacity", 0.95, type=float)
        config.blur_effect = self.settings.value("blur_effect", True, type=bool)
        config.show_date = self.settings.value("show_date", True, type=bool)
        config.show_battery = self.settings.value("show_battery", True, type=bool)
        config.show_volume = self.settings.value("show_volume", True, type=bool)
        config.show_network = self.settings.value("show_network", False, type=bool)
        config.show_tray = self.settings.value("show_tray", True, type=bool)
        config.show_xfce_launchers = self.settings.value("show_xfce_launchers", True, type=bool)
        config.theme_variant = self.settings.value("theme_variant", "tokyo_night", type=str)
        config.rounded_corners = self.settings.value("rounded_corners", True, type=bool)
        config.corner_radius = self.settings.value("corner_radius", 10, type=int)
        # New features
        config.show_workspace_switcher = self.settings.value("show_workspace_switcher", True, type=bool)
        config.show_brightness_control = self.settings.value("show_brightness_control", True, type=bool)
        config.show_weather = self.settings.value("show_weather", True, type=bool)
        config.show_notifications = self.settings.value("show_notifications", True, type=bool)
        # NEW: Network and Bluetooth controls
        config.show_network_control = self.settings.value("show_network_control", True, type=bool)
        config.show_bluetooth_control = self.settings.value("show_bluetooth_control", True, type=bool)
        config.weather_location = self.settings.value("weather_location", "", type=str)
        # Auto-hide settings
        config.auto_hide = self.settings.value("auto_hide", False, type=bool)
        config.auto_hide_delay = self.settings.value("auto_hide_delay", 2000, type=int)
        config.show_on_edge = self.settings.value("show_on_edge", True, type=bool)
        config.edge_size = self.settings.value("edge_size", 5, type=int)

        # Load built-in launcher commands
        config.terminal_command = self.settings.value("terminal_command", "xfce4-terminal", type=str)
        config.file_manager_command = self.settings.value("file_manager_command", "thunar", type=str)
        config.browser_command = self.settings.value("browser_command", "firefox", type=str)
        config.text_editor_command = self.settings.value("text_editor_command", "mousepad", type=str)
        config.settings_command = self.settings.value("settings_command", "xfce4-settings-manager", type=str)
        config.calculator_command = self.settings.value("calculator_command", "gnome-calculator", type=str)
        config.screenshot_command = self.settings.value("screenshot_command", "xfce4-screenshooter", type=str)
        config.image_viewer_command = self.settings.value("image_viewer_command", "ristretto", type=str)
        config.music_player_command = self.settings.value("music_player_command", "vlc", type=str)
        config.music_player_args = self.settings.value("music_player_args", "", type=str)

        # Load custom launchers
        config.launcher_customizations = []
        launchers_data = self.settings.value("launcher_customizations", [])
        
        if launchers_data:
            for launcher_dict in launchers_data:
                try:
                    # Handle both string and dict formats
                    if isinstance(launcher_dict, str):
                        # Legacy format - skip or convert if needed
                        continue
                    elif isinstance(launcher_dict, dict):
                        # Create Application object from dictionary
                        launcher = Application(
                            name=launcher_dict.get('name', ''),
                            command=launcher_dict.get('command', ''),
                            icon=launcher_dict.get('icon', 'üöÄ'),
                            args=launcher_dict.get('args', ''),
                            workspace=launcher_dict.get('workspace', -1)  # ADDED: Load workspace setting
                        )
                        config.launcher_customizations.append(launcher)
                except Exception as e:
                    print(f"Error loading launcher: {e}")
        
        print(f"DEBUG: ConfigManager loaded {len(config.launcher_customizations)} custom launchers")
        
        return config

# ... (rest of the code remains the same)

class TrayIconManager:
    """System tray icon manager"""
    def __init__(self, panel):
        self.panel = panel
        self.tray_icon = QSystemTrayIcon(self.create_icon(), panel)
        self.setup_tray_menu()

    def create_icon(self):
        """Create tray icon with Tokyo Night colors"""
        pixmap = QPixmap(32, 32)
        pixmap.fill(QColor(TokyoNight.NIGHT_TOP))
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        # Draw Tokyo Night styled icon with moon theme
        gradient = QLinearGradient(0, 0, 32, 32)
        gradient.setColorAt(0, QColor(TokyoNight.MOON_GLOW))
        gradient.setColorAt(1, QColor(TokyoNight.BLUE))
        painter.setBrush(gradient)
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(4, 4, 24, 24, 6, 6)
        # Draw moon crescent
        painter.setBrush(QColor(TokyoNight.NIGHT_TOP))
        painter.drawEllipse(18, 8, 10, 10)
        painter.end()
        return QIcon(pixmap)

    def setup_tray_menu(self):
        """Setup tray icon context menu"""
        menu = QMenu()
        menu.setStyleSheet(self.panel.get_stylesheet())
        show_action = QAction("Û∞Äæ Show Panel", self.panel)
        show_action.triggered.connect(self.panel.show_panel)
        menu.addAction(show_action)
        hide_action = QAction("Û∞ñØ Hide Panel", self.panel)
        hide_action.triggered.connect(self.panel.hide_panel)
        menu.addAction(hide_action)
        menu.addSeparator()
        settings_action = QAction("Û∞íì Settings", self.panel)
        settings_action.triggered.connect(self.panel.show_settings)
        menu.addAction(settings_action)
        menu.addSeparator()
        restart_action = QAction("Û∞ú∫ Restart", self.panel)
        restart_action.triggered.connect(self.panel.restart_panel)
        menu.addAction(restart_action)
        quit_action = QAction("Û∞óº Quit", self.panel)
        quit_action.triggered.connect(self.panel.quit_application)
        menu.addAction(quit_action)
        self.tray_icon.setContextMenu(menu)
        self.tray_icon.activated.connect(self.tray_icon_activated)

    def tray_icon_activated(self, reason):
        """Handle tray icon activation"""
        if reason == QSystemTrayIcon.DoubleClick:
            if self.panel.isVisible():
                self.panel.hide_panel()
            else:
                self.panel.show_panel()

    def show(self):
        """Show tray icon"""
        self.tray_icon.show()

    def show_message(self, title, message, timeout=3000):
        """Show tray notification"""
        self.tray_icon.showMessage(title, message, QSystemTrayIcon.Information, timeout)

class XfceLauncherReader:
    """Read XFCE panel launchers from configuration files"""
    def __init__(self):
        self.config_dir = Path.home() / ".config" / "xfce4" / "panel"
        self.launchers_dir = Path.home() / ".config" / "xfce4" / "panel" / "launchers"

    def get_xfce_launchers(self):
        """Get XFCE panel launchers"""
        launchers = []
        try:
            # Find launcher directories
            if not self.launchers_dir.exists():
                return launchers
            
            # Read each launcher file
            for launcher_file in self.launchers_dir.glob("*.desktop"):
                launcher = self.parse_launcher_file(launcher_file)
                if launcher:
                    launchers.append(launcher)
        except Exception as e:
            print(f"Error reading XFCE launchers: {e}")
        return launchers

    def parse_launcher_file(self, file_path):
        """Parse a single launcher .desktop file"""
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Parse the desktop file
            name = ""
            command = ""
            icon = ""
            
            for line in content.splitlines():
                if line.startswith("Name="):
                    name = line.split("=", 1)[1]
                elif line.startswith("Exec="):
                    command = line.split("=", 1)[1]
                    # Remove %U, %F, etc. from command
                    command = re.sub(r'\s%[fFuU]', '', command)
                elif line.startswith("Icon="):
                    icon = line.split("=", 1)[1]
            
            if name and command:
                # Try to get icon from theme or use emoji fallback
                if icon:
                    # Check if it's a file path
                    if os.path.exists(icon):
                        # For file icons, we'll use a generic emoji
                        icon = "üöÄ"
                    else:
                        # For theme icons, we'll use a generic emoji
                        icon = "üöÄ"
                else:
                    # Fallback icon based on command
                    if "terminal" in command.lower():
                        icon = "Û∞Üç"
                    elif "browser" in command.lower() or "firefox" in command.lower():
                        icon = "Û∞àπ"
                    elif "file" in command.lower() or "thunar" in command.lower():
                        icon = "Û∞âã"
                    elif "text" in command.lower() or "editor" in command.lower():
                        icon = "Û∞à¨"
                    elif "settings" in command.lower():
                        icon = "Û∞É§"
                    elif "calculator" in command.lower():
                        icon = "Û∞éÅ"
                    elif "screenshot" in command.lower():
                        icon = "Û∞äì"
                    elif "image" in command.lower() or "viewer" in command.lower():
                        icon = "Û∞ª≠"
                    elif "music" in command.lower() or "vlc" in command.lower():
                        icon = "Û∞éÑ"
                    else:
                        icon = "üöÄ"
                
                return Application(name=name, command=command, icon=icon)
        except Exception as e:
            print(f"Error parsing launcher file {file_path}: {e}")
        return None

def main():
    """Main application entry point"""
    # Set up high DPI scaling
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)
    app = QApplication(sys.argv)
    app.setApplicationName("Tokyo Night Panel")
    app.setApplicationVersion("1.0.0")
    # Set up system tray with better error handling
    tray_available = QSystemTrayIcon.isSystemTrayAvailable()
    if not tray_available:
        print("System tray is not available, panel will run without tray icon")
        # Don't set quit on last window closed, so panel stays open
        app.setQuitOnLastWindowClosed(False)
    else:
        app.setQuitOnLastWindowClosed(False)
    # Load configuration
    config_manager = ConfigManager()
    config = config_manager.load_config()
    # Create and show panel
    panel = TokyoNightPanelBar(config)
    panel.show()
    # Setup system tray only if available
    if tray_available:
        try:
            tray_manager = TrayIconManager(panel)
            tray_manager.show()
            tray_manager.show_message("Tokyo Night Panel", "Panel started successfully")
        except Exception as e:
            print(f"Failed to create system tray icon: {e}")
    # Save config on exit
    def save_on_exit():
        config_manager.save_config(panel.config)
    app.aboutToQuit.connect(save_on_exit)
    # Handle SIGTERM for graceful shutdown
    def handle_signal(signum, frame):
        save_on_exit()
        QApplication.quit()
    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)
    return app.exec_()

if __name__ == "__main__":
    sys.exit(main())