#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
StormOS / Arch XFCE Easy Installer — PyQt5 (UEFI + BIOS) — No-Freeze Edition
FULL SINGLE-FILE CODE (Midnight Theme + Accent Colors)

Includes everything from the previous version:
✅ Multi-drive disk picker + refresh
✅ Install mode:
   - ERASE DISK (auto partitioning) — destructive
   - USE EXISTING PARTITIONS — pick root (+ EFI if UEFI), optional formatting
✅ Smart confirmation words:
   - ERASE mode -> type ERASE
   - Existing partitions + any formatting -> type FORMAT
   - Existing partitions no formatting -> type INSTALL
✅ 14" friendly (scroll pages)
✅ Wi-Fi status display
✅ Multilib enablement (live + target)
✅ GitHub wallpaper download + correct placement into /usr/share/backgrounds/xfce/xfce-x.svg
✅ StormOS wallpapers pack copy if present
✅ LightDM greeter background + theme/icon
✅ XFCE wallpaper + icon theme patch into /etc/skel
✅ yay best-effort
"""

import os
import re
import sys
import shlex
import time
import shutil
import socket
import subprocess
import urllib.request
import urllib.error
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Tuple, Callable

from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer, QUrl
from PyQt5.QtGui import QFont, QDesktopServices
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLabel, QLineEdit, QPushButton, QComboBox, QStackedWidget, QMessageBox,
    QPlainTextEdit, QProgressBar, QCheckBox, QGroupBox, QTextEdit, QScrollArea,
    QSizePolicy
)

# ============================================================
# Midnight theme palette + app-wide stylesheet
# ============================================================
MIDNIGHT_QSS = r"""
/* ---------- Base ---------- */
QWidget {
  background: #0b1020;
  color: #e7e9ff;
  font-family: "Sans";
  font-size: 11pt;
}
QMainWindow {
  background: #0b1020;
}
QToolTip {
  background: #111a2e;
  color: #e7e9ff;
  border: 1px solid #2a3760;
  padding: 6px;
  border-radius: 8px;
}

/* ---------- Containers ---------- */
QScrollArea, QStackedWidget {
  background: #0b1020;
  border: none;
}
QGroupBox {
  background: #0f1730;
  border: 1px solid #2a3760;
  border-radius: 14px;
  margin-top: 12px;
  padding: 12px;
}
QGroupBox::title {
  subcontrol-origin: margin;
  left: 12px;
  padding: 0 8px;
  color: #b8c2ff;
  font-weight: 700;
}

/* ---------- Inputs ---------- */
QLineEdit, QComboBox, QTextEdit, QPlainTextEdit {
  background: #101a34;
  border: 1px solid #2a3760;
  border-radius: 12px;
  padding: 8px 10px;
  selection-background-color: #2b77ff;
  selection-color: #ffffff;
}
QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QPlainTextEdit:focus {
  border: 1px solid #6aa9ff;
}
QComboBox::drop-down {
  border: none;
  width: 28px;
}
QComboBox::down-arrow {
  image: none;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 8px solid #b8c2ff;
  margin-right: 10px;
}

/* ---------- Checkboxes ---------- */
QCheckBox {
  spacing: 10px;
}
QCheckBox::indicator {
  width: 18px;
  height: 18px;
  border-radius: 5px;
  border: 1px solid #2a3760;
  background: #101a34;
}
QCheckBox::indicator:checked {
  background: #2b77ff;
  border: 1px solid #6aa9ff;
}

/* ---------- Buttons ---------- */
QPushButton {
  background: #17224a;
  border: 1px solid #2a3760;
  border-radius: 12px;
  padding: 10px 14px;
  font-weight: 700;
}
QPushButton:hover {
  background: #1b2a5e;
  border: 1px solid #3b4c83;
}
QPushButton:pressed {
  background: #132044;
}
QPushButton:disabled {
  background: #111829;
  border: 1px solid #1a2340;
  color: #7f87b8;
}

/* ---------- Progress ---------- */
QProgressBar {
  background: #101a34;
  border: 1px solid #2a3760;
  border-radius: 12px;
  text-align: center;
  padding: 2px;
}
QProgressBar::chunk {
  background: #2b77ff;
  border-radius: 10px;
}

/* ---------- Scrollbars ---------- */
QScrollBar:vertical {
  background: transparent;
  width: 12px;
  margin: 2px 2px 2px 2px;
}
QScrollBar::handle:vertical {
  background: #2a3760;
  border-radius: 6px;
  min-height: 22px;
}
QScrollBar::handle:vertical:hover {
  background: #3b4c83;
}
QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
  height: 0px;
}
QScrollBar:horizontal {
  background: transparent;
  height: 12px;
  margin: 2px 2px 2px 2px;
}
QScrollBar::handle:horizontal {
  background: #2a3760;
  border-radius: 6px;
  min-width: 22px;
}
QScrollBar::handle:horizontal:hover {
  background: #3b4c83;
}
QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
  width: 0px;
}
"""

# ============================================================
# GitHub sources (your links)
# ============================================================
GITHUB_PACKAGES_BLOB_URL = (
    "https://github.com/bfitzgit23/stormos-build-files/blob/main/install-stormos-xfce/packages.x86_64"
)

GITHUB_ZST_BLOB_URLS = [
    "https://github.com/bfitzgit23/stormos/blob/main/x86_64/adw-gtk-theme-git-5.7.r4.gf3ba1d7-1-any.pkg.tar.zst",
]

GITHUB_WALLPAPER_SVG_BLOB_URL = (
    "https://github.com/bfitzgit23/stormos-build-files/blob/main/install-stormos-xfce/airootfs/usr/share/backgrounds/xfce-x.svg"
)

# ============================================================
# Defaults (Wallpaper + paths)
# ============================================================
DEFAULT_WALLPAPER_DIR = "/usr/share/backgrounds/xfce"
DEFAULT_WALLPAPER_PATH = f"{DEFAULT_WALLPAPER_DIR}/xfce-x.svg"
COMPAT_WALLPAPER_SYMLINK = "/usr/share/backgrounds/xfce-x.svg"

# ============================================================
# Installer log file (always written)
# ============================================================
LOG_FILE = Path("/tmp/stormos_easy_installer.log")


def log_to_file(line: str) -> None:
    try:
        LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        with LOG_FILE.open("a", encoding="utf-8", errors="ignore") as f:
            f.write(line.rstrip("\n") + "\n")
    except Exception:
        pass


def reset_log_file() -> None:
    try:
        LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        LOG_FILE.write_text("", encoding="utf-8", errors="ignore")
    except Exception:
        pass


# ============================================================
# Helpers
# ============================================================
def is_root() -> bool:
    try:
        return os.geteuid() == 0
    except Exception:
        return False


def is_uefi() -> bool:
    return Path("/sys/firmware/efi/efivars").exists()


def which(cmd: str) -> Optional[str]:
    return shutil.which(cmd)


def cmd_ok(cmd: str) -> bool:
    return which(cmd) is not None


def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)


def read_text(p: Path) -> str:
    try:
        return p.read_text(errors="ignore")
    except Exception:
        return ""


def write_file(path: Path, content: str) -> None:
    ensure_dir(path.parent)
    path.write_text(content, encoding="utf-8", errors="ignore")


def sanitize_hostname(h: str) -> str:
    h = (h or "").strip().lower()
    h = re.sub(r"[^a-z0-9-]", "-", h)
    h = re.sub(r"-{2,}", "-", h).strip("-")
    return h[:63] if h else "arch"


def sanitize_username(u: str) -> str:
    u = (u or "").strip().lower()
    u = re.sub(r"[^a-z0-9_]", "", u)
    if not u or u[0].isdigit():
        u = "user"
    return u[:32]


def have_internet_fast() -> bool:
    try:
        s = socket.create_connection(("1.1.1.1", 53), timeout=1.0)
        s.close()
        return True
    except Exception:
        return False


def safe_umount_recursive(mountpoint: str) -> None:
    try:
        mounts = read_text(Path("/proc/mounts")).splitlines()
        mps = []
        for line in mounts:
            parts = line.split()
            if len(parts) >= 2:
                mps.append(parts[1])
        for m in sorted(mps, key=len, reverse=True):
            if m == mountpoint or m.startswith(mountpoint.rstrip("/") + "/"):
                subprocess.run(["umount", "-R", mountpoint],
                               stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                break
        subprocess.run(["umount", mountpoint],
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except Exception:
        pass


def partition_path(disk: str, n: int) -> str:
    if re.search(r"(nvme\d+n\d+|mmcblk\d+)$", disk):
        return f"{disk}p{n}"
    return f"{disk}{n}"


def detect_microcode_pkg() -> Optional[str]:
    cpuinfo = read_text(Path("/proc/cpuinfo")).lower()
    if "genuineintel" in cpuinfo:
        return "intel-ucode"
    if "authenticamd" in cpuinfo:
        return "amd-ucode"
    return None


def list_disks() -> List[Tuple[str, str, str]]:
    if not cmd_ok("lsblk"):
        return []
    cp = subprocess.run(
        ["lsblk", "-dn", "-o", "NAME,TYPE,SIZE,MODEL"],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
    )
    out = cp.stdout or ""
    disks = []
    for line in out.splitlines():
        line = line.strip()
        if not line:
            continue
        parts = line.split(None, 3)
        if len(parts) < 3:
            continue
        name, typ, size = parts[0], parts[1], parts[2]
        model = parts[3].strip() if len(parts) >= 4 else ""
        if typ != "disk":
            continue
        if name.startswith(("loop", "ram", "sr")):
            continue
        disks.append((f"/dev/{name}", size, model))
    return disks


def list_partitions_for_disk(disk: str) -> List[Tuple[str, str, str, str, str, str]]:
    """
    Returns: (dev, size, fstype, mountpoint, partlabel, parttype)
    Only TYPE=part under the selected disk.
    """
    if not cmd_ok("lsblk"):
        return []
    cp = subprocess.run(
        ["lsblk", "-prn", "-o", "NAME,TYPE,PKNAME,SIZE,FSTYPE,MOUNTPOINT,PARTLABEL,PARTTYPE"],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
    )
    out = (cp.stdout or "").strip()
    res: List[Tuple[str, str, str, str, str, str]] = []
    disk_base = Path(disk).name
    for line in out.splitlines():
        parts = line.split(None, 7)
        if len(parts) < 4:
            continue
        name = parts[0]
        typ = parts[1]
        pkname = parts[2] if len(parts) >= 3 else ""
        size = parts[3] if len(parts) >= 4 else ""
        fstype = parts[4] if len(parts) >= 5 else ""
        mnt = parts[5] if len(parts) >= 6 else ""
        plabel = parts[6] if len(parts) >= 7 else ""
        ptype = parts[7] if len(parts) >= 8 else ""

        fstype = "" if fstype == "-" else fstype
        mnt = "" if mnt == "-" else mnt
        plabel = "" if plabel == "-" else plabel
        ptype = "" if ptype == "-" else ptype

        if typ != "part":
            continue
        if pkname != disk_base:
            continue
        res.append((name, size, fstype, mnt, plabel, ptype))
    return res


def run_stream(cmd: List[str], on_line, timeout: Optional[int] = None, input_text: Optional[str] = None) -> int:
    p = subprocess.Popen(
        cmd,
        stdin=subprocess.PIPE if input_text is not None else None,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True
    )
    start = time.time()
    try:
        if input_text is not None and p.stdin is not None:
            try:
                p.stdin.write(input_text)
                p.stdin.close()
            except Exception:
                pass
        assert p.stdout is not None
        for line in p.stdout:
            on_line(line.rstrip("\n"))
            if timeout is not None and (time.time() - start) > timeout:
                on_line(f"!! Timeout ({timeout}s) reached, terminating: {' '.join(cmd)}")
                p.terminate()
                try:
                    p.wait(timeout=5)
                except Exception:
                    p.kill()
                return 124
        return p.wait()
    finally:
        try:
            if p.stdout:
                p.stdout.close()
        except Exception:
            pass


def arch_chroot(target_root: Path, cmd: str, log) -> None:
    full = ["arch-chroot", str(target_root), "bash", "-lc", cmd]
    log(f"$ arch-chroot {target_root} bash -lc {cmd}")
    rc = run_stream(full, log, timeout=None)
    if rc != 0:
        raise RuntimeError(f"arch-chroot failed (rc={rc}): {cmd}")


def arch_chroot_soft(target_root: Path, cmd: str, log) -> int:
    full = ["arch-chroot", str(target_root), "bash", "-lc", cmd]
    log(f"$ arch-chroot {target_root} bash -lc {cmd}")
    return run_stream(full, log, timeout=None)


def arch_chroot_input(target_root: Path, cmd: str, input_text: str, log) -> None:
    full = ["arch-chroot", str(target_root), "bash", "-lc", cmd]
    log(f"$ arch-chroot {target_root} bash -lc {cmd}  (stdin provided)")
    rc = run_stream(full, log, timeout=None, input_text=input_text)
    if rc != 0:
        raise RuntimeError(f"arch-chroot failed (rc={rc}): {cmd}")


def blkid_partuuid(dev: str) -> str:
    cp = subprocess.run(["blkid", "-s", "PARTUUID", "-o", "value", dev],
                        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    return (cp.stdout or "").strip()


def blkid_fstype(dev: str) -> str:
    cp = subprocess.run(["blkid", "-s", "TYPE", "-o", "value", dev],
                        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    return (cp.stdout or "").strip()


# ============================================================
# Wi-Fi status
# ============================================================
def wifi_status_line() -> str:
    if not cmd_ok("nmcli"):
        return "Wi-Fi: nmcli not available"
    try:
        cp = subprocess.run(["nmcli", "-t", "-f", "DEVICE,TYPE,STATE,CONNECTION", "device"],
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        out = (cp.stdout or "").strip()
        wifi_dev = None
        conn = None
        state = None
        for line in out.splitlines():
            parts = line.split(":")
            if len(parts) >= 4:
                dev, typ, st, con = parts[0], parts[1], parts[2], parts[3]
                if typ == "wifi":
                    wifi_dev = dev
                    state = st
                    conn = con
                    break
        if wifi_dev and state == "connected" and conn:
            return f"Wi-Fi: Connected to {conn} on {wifi_dev}"
        if wifi_dev:
            return f"Wi-Fi: {state or 'unknown'} on {wifi_dev}"
        return "Wi-Fi: Not detected"
    except Exception:
        return "Wi-Fi: Unknown"


# ============================================================
# GitHub download helpers
# ============================================================
def github_blob_to_raw(url: str) -> str:
    u = (url or "").strip()
    m = re.match(r"^https?://github\.com/([^/]+)/([^/]+)/blob/([^/]+)/(.*)$", u)
    if m:
        owner, repo, branch, path = m.group(1), m.group(2), m.group(3), m.group(4)
        return f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{path}"
    m2 = re.match(r"^https?://github\.com/([^/]+)/([^/]+)/raw/([^/]+)/(.*)$", u)
    if m2:
        owner, repo, branch, path = m2.group(1), m2.group(2), m2.group(3), m2.group(4)
        return f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{path}"
    return u


def _download_via_tool(url: str, dest: Optional[Path], want_text: bool) -> Optional[str]:
    ua = "StormOS-Installer/1.0"
    if cmd_ok("curl"):
        if want_text:
            cp = subprocess.run(["curl", "-fsSL", "-A", ua, url],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            if cp.returncode == 0:
                return cp.stdout or ""
            raise RuntimeError((cp.stdout or "curl failed").strip())
        else:
            assert dest is not None
            ensure_dir(dest.parent)
            cp = subprocess.run(["curl", "-fL", "-A", ua, "-o", str(dest), url],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            if cp.returncode == 0 and dest.exists() and dest.stat().st_size > 0:
                return None
            raise RuntimeError((cp.stdout or "curl download failed").strip())

    if cmd_ok("wget"):
        if want_text:
            cp = subprocess.run(["wget", "-qO-", "--user-agent", ua, url],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            if cp.returncode == 0:
                return cp.stdout or ""
            raise RuntimeError((cp.stdout or "wget failed").strip())
        else:
            assert dest is not None
            ensure_dir(dest.parent)
            cp = subprocess.run(["wget", "-qO", str(dest), "--user-agent", ua, url],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            if cp.returncode == 0 and dest.exists() and dest.stat().st_size > 0:
                return None
            raise RuntimeError((cp.stdout or "wget download failed").strip())
    return None


def download_text(url: str, log: Callable[[str], None], timeout: int = 45) -> str:
    raw = github_blob_to_raw(url)
    log(f"Downloading text: {raw}")
    try:
        t = _download_via_tool(raw, None, want_text=True)
        if t is not None:
            return t
    except Exception as e:
        log(f"!! curl/wget text fetch failed (will try python): {e}")
    req = urllib.request.Request(raw, headers={"User-Agent": "StormOS-Installer/1.0"})
    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            data = resp.read()
        return data.decode("utf-8", errors="ignore")
    except urllib.error.URLError as e:
        raise RuntimeError(f"Failed to download text from {raw}: {e}") from e


def download_file(url: str, dest: Path, log: Callable[[str], None], timeout: int = 180) -> None:
    raw = github_blob_to_raw(url)
    log(f"Downloading file: {raw} -> {dest}")
    try:
        _download_via_tool(raw, dest, want_text=False)
        if dest.exists() and dest.stat().st_size > 0:
            return
    except Exception as e:
        log(f"!! curl/wget file download failed (will try python): {e}")
    ensure_dir(dest.parent)
    req = urllib.request.Request(raw, headers={"User-Agent": "StormOS-Installer/1.0"})
    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            with dest.open("wb") as f:
                shutil.copyfileobj(resp, f)
        if not dest.exists() or dest.stat().st_size == 0:
            raise RuntimeError("Downloaded file is empty.")
    except Exception as e:
        raise RuntimeError(f"Failed to download file from {raw}: {e}") from e


# ============================================================
# pacman.conf repo helpers (MULTILIB FIX)
# ============================================================
def enable_repo_in_pacman_conf(conf_path: Path, repo_name: str, log) -> bool:
    txt = read_text(conf_path)
    if not txt.strip():
        raise RuntimeError(f"pacman.conf missing/empty: {conf_path}")

    changed = False

    header_re = re.compile(rf"(?m)^\s*#?\s*\[{re.escape(repo_name)}\]\s*$")
    m = header_re.search(txt)

    if not m:
        txt = txt.rstrip() + f"\n[{repo_name}]\nInclude = /etc/pacman.d/mirrorlist\n"
        changed = True
    else:
        txt2 = re.sub(rf"(?m)^\s*#\s*\[{re.escape(repo_name)}\]\s*$",
                      f"[{repo_name}]",
                      txt)
        if txt2 != txt:
            txt = txt2
            changed = True

        block_re = re.compile(rf"(?ms)^\s*\[{re.escape(repo_name)}\]\s*$.*?(?=^\s*\[|\Z)")
        bm = block_re.search(txt)
        if bm:
            block = bm.group(0)
            block2 = re.sub(r"(?m)^\s*#\s*(Include\s*=\s*/etc/pacman\.d/mirrorlist)\s*$",
                            r"\1",
                            block)
            if block2 != block:
                txt = txt[:bm.start()] + block2 + txt[bm.end():]
                changed = True

            bm2 = block_re.search(txt)
            if bm2:
                block_now = bm2.group(0)
                if not re.search(r"(?m)^\s*Include\s*=\s*/etc/pacman\.d/mirrorlist\s*$", block_now):
                    block_now2 = block_now.rstrip() + "\nInclude = /etc/pacman.d/mirrorlist\n"
                    txt = txt[:bm2.start()] + block_now2 + txt[bm2.end():]
                    changed = True

    if changed:
        write_file(conf_path, txt if txt.endswith("\n") else (txt + "\n"))
        log(f"Enabled repo [{repo_name}] in {conf_path}")
    else:
        log(f"Repo [{repo_name}] already enabled in {conf_path}")
    return changed


def ensure_multilib_enabled_live(log) -> None:
    live_conf = Path("/etc/pacman.conf")
    enable_repo_in_pacman_conf(live_conf, "multilib", log)
    if cmd_ok("pacman"):
        run_stream(["pacman", "-Syy", "--noconfirm"], log, timeout=None)


def ensure_multilib_enabled_target(target_root: Path, log) -> None:
    tgt_conf = target_root / "etc" / "pacman.conf"
    if tgt_conf.exists():
        enable_repo_in_pacman_conf(tgt_conf, "multilib", log)


# ============================================================
# Copy helpers
# ============================================================
def copy_tree_merge(src: Path, dst: Path, log) -> None:
    if not src.exists():
        log(f"-- Missing: {src}")
        return
    ensure_dir(dst)
    if cmd_ok("rsync"):
        rc = subprocess.run(["rsync", "-a", f"{str(src)}/", f"{str(dst)}/"],
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True).returncode
        if rc != 0:
            log(f"!! rsync returned non-zero for {src} -> {dst} (continuing)")
    else:
        for root, dirs, files in os.walk(str(src), followlinks=False):
            rp = Path(root)
            rel = rp.relative_to(src)
            out_root = dst / rel
            ensure_dir(out_root)
            for d in dirs:
                ensure_dir(out_root / d)
            for f in files:
                s = rp / f
                o = out_root / f
                try:
                    if o.exists() or o.is_symlink():
                        try:
                            o.unlink()
                        except Exception:
                            pass
                    if s.is_symlink():
                        try:
                            o.symlink_to(os.readlink(str(s)))
                        except Exception:
                            pass
                    else:
                        shutil.copy2(str(s), str(o))
                except Exception as e:
                    log(f"!! copy warn: {s} -> {o}: {e}")


def migrate_usr_local_bin(target_root: Path, log) -> None:
    src = Path("/usr/local/bin")
    dst = target_root / "usr" / "local" / "bin"
    if not src.exists():
        log("Migration: LIVE /usr/local/bin not present — skipping.")
        return
    log(f"Migration: copying {src} -> {dst}")
    copy_tree_merge(src, dst, log)

    try:
        count = 0
        for p in dst.iterdir():
            if p.is_file() and not p.is_symlink():
                st = p.stat()
                mode = st.st_mode
                new_mode = mode | 0o111
                if new_mode != mode:
                    os.chmod(str(p), new_mode)
                count += 1
        log(f"Migration: ensured executability on {count} files in {dst}")
    except Exception as e:
        log(f"!! Migration: chmod pass failed: {e}")


# ============================================================
# Live presets
# ============================================================
LIVE_SKEL = Path("/etc/skel")
LIVE_PKG_LIST = Path("/etc/stormos/packages.txt")


def apply_skel_preset(target_root: Path, log) -> None:
    if not LIVE_SKEL.exists():
        log("Preset: /etc/skel not found on Live ISO — skipping.")
        return
    log(f"Preset: merging Live ISO {LIVE_SKEL} -> target {target_root/'etc/skel'}")
    copy_tree_merge(LIVE_SKEL, target_root / "etc" / "skel", log)


def copy_stormos_wallpapers_into_backgrounds(target_root: Path, log) -> None:
    live = Path("/usr/share/backgrounds/StormOS")
    dst = target_root / "usr" / "share" / "backgrounds" / "StormOS"
    if not live.exists():
        log("Wallpapers: live /usr/share/backgrounds/StormOS not found — skipping StormOS wallpaper pack copy.")
        return
    log(f"Wallpapers: copying {live} -> {dst}")
    copy_tree_merge(live, dst, log)


# ============================================================
# Wallpaper + Theme + Icon defaults
# ============================================================
def ensure_default_wallpaper_svg(target_root: Path, log) -> str:
    dest_dir = target_root / "usr" / "share" / "backgrounds" / "xfce"
    dest = dest_dir / "xfce-x.svg"
    compat = target_root / "usr" / "share" / "backgrounds" / "xfce-x.svg"

    if dest.exists() and dest.stat().st_size > 0:
        log(f"Wallpaper: already present: {dest} ({dest.stat().st_size} bytes)")
    else:
        log("Wallpaper: installing default xfce-x.svg from GitHub…")
        ensure_dir(dest.parent)
        try:
            if dest.exists():
                dest.unlink()
        except Exception:
            pass
        download_file(GITHUB_WALLPAPER_SVG_BLOB_URL, dest, log, timeout=240)
        if not dest.exists() or dest.stat().st_size == 0:
            raise RuntimeError("Wallpaper download failed: file missing or empty after download.")

    try:
        if compat.exists() or compat.is_symlink():
            compat.unlink()
        compat.symlink_to(Path("xfce") / "xfce-x.svg")
        log(f"Wallpaper: created symlink {compat} -> {Path('xfce')/'xfce-x.svg'}")
    except Exception as e:
        log(f"!! Wallpaper: symlink create failed (not fatal): {e}")

    return str(dest)


def patch_xfce_wallpaper_in_skel(target_root: Path, wallpaper_path: str, log) -> None:
    xml = target_root / "etc" / "skel" / ".config" / "xfce4" / "xfconf" / "xfce-perchannel-xml" / "xfce4-desktop.xml"
    if not xml.exists():
        log("XFCE wallpaper: skel xfce4-desktop.xml not found; skipping patch.")
        return
    txt = read_text(xml)
    if not txt:
        log("XFCE wallpaper: unable to read xfce4-desktop.xml; skipping.")
        return

    new = re.sub(
        r'(<property\s+name="last-image"\s+type="string"\s+value=")([^"]*)(")',
        rf'\1{wallpaper_path}\3',
        txt
    )
    new = re.sub(
        r'(<property\s+name="image-path"\s+type="string"\s+value=")([^"]*)(")',
        rf'\1{wallpaper_path}\3',
        new
    )
    if new != txt:
        write_file(xml, new)
        log(f"XFCE wallpaper: patched {xml} -> {wallpaper_path}")
    else:
        log("XFCE wallpaper: no matching wallpaper properties found to patch (OK).")


def configure_lightdm_greeter(target_root: Path, background_path: Optional[str], log, theme_name: Optional[str], icon_theme: Optional[str]) -> None:
    conf = target_root / "etc" / "lightdm" / "lightdm-gtk-greeter.conf"
    ensure_dir(conf.parent)
    lines = ["[greeter]"]
    if background_path:
        lines.append(f"background={background_path}")
    if theme_name:
        lines.append(f"theme-name={theme_name}")
    if icon_theme:
        lines.append(f"icon-theme-name={icon_theme}")
    lines.append("font-name=Sans 10")
    lines.append("xft-antialias=true")
    lines.append("xft-hintstyle=hintfull")
    lines.append("xft-rgba=rgb")
    write_file(conf, "\n".join(lines) + "\n")
    log(f"LightDM: wrote {conf}")


def list_installed_theme_dirs(target_root: Path) -> List[str]:
    themes_dir = target_root / "usr" / "share" / "themes"
    if not themes_dir.exists():
        return []
    out = []
    for d in themes_dir.iterdir():
        if d.is_dir():
            out.append(d.name)
    return sorted(out)


def choose_best_theme_name(target_root: Path, preferred: str = "adw-gtk-dark") -> str:
    themes = set(list_installed_theme_dirs(target_root))
    pref_order = [
        preferred,
        "adw-gtk-dark",
        "adw-gtk",
        "adw-gtk3-dark",
        "adw-gtk3",
        "Adwaita-dark",
        "Adwaita",
    ]
    for p in pref_order:
        if p in themes:
            return p
    return next(iter(themes), preferred)


def list_installed_icon_dirs(target_root: Path) -> List[str]:
    icons_dir = target_root / "usr" / "share" / "icons"
    if not icons_dir.exists():
        return []
    out = []
    for d in icons_dir.iterdir():
        if d.is_dir():
            out.append(d.name)
    return sorted(out)


def choose_best_icon_theme(target_root: Path) -> str:
    icons = set(list_installed_icon_dirs(target_root))
    pref_order = [
        "Tela-circle-dark",
        "Tela-circle-black",
        "Tela-circle-grey",
        "Tela-circle",
        "Tela",
        "Adwaita",
        "hicolor",
    ]
    for p in pref_order:
        if p in icons:
            return p
    return next(iter(icons), "Tela-circle-black")


def write_default_gtk_settings_to_skel(
    target_root: Path,
    theme_name: str,
    icon_theme: str,
    log,
    cursor_theme: str = "Adwaita"
) -> None:
    ini = target_root / "etc" / "skel" / ".config" / "gtk-3.0" / "settings.ini"
    ensure_dir(ini.parent)
    content = (
        "[Settings]\n"
        f'gtk-theme-name="{theme_name}"\n'
        f'gtk-icon-theme-name="{icon_theme}"\n'
        f'gtk-cursor-theme-name="{cursor_theme}"\n'
        'gtk-font-name="Sans 10"\n'
    )
    write_file(ini, content)
    log(f"GTK default: wrote {ini} (theme={theme_name}, icons={icon_theme})")


def patch_xfce_icon_theme_in_skel(target_root: Path, icon_theme: str, log) -> None:
    xml = target_root / "etc" / "skel" / ".config" / "xfce4" / "xfconf" / "xfce-perchannel-xml" / "xsettings.xml"
    if not xml.exists():
        log("XFCE icons: skel xsettings.xml not found; skipping XFCE icon patch.")
        return
    txt = read_text(xml)
    if not txt.strip():
        log("XFCE icons: unable to read xsettings.xml; skipping.")
        return

    new = re.sub(
        r'(<property\s+name="IconThemeName"\s+type="string"\s+value=")([^"]*)(")',
        rf'\1{icon_theme}\3',
        txt
    )

    if new == txt:
        if 'name="IconThemeName"' not in txt:
            insert = f'  <property name="IconThemeName" type="string" value="{icon_theme}"/>\n'
            new2 = re.sub(r"(</channel>\s*)\Z", insert + r"\1", txt, flags=re.S)
            if new2 != txt:
                new = new2

    if new != txt:
        write_file(xml, new)
        log(f"XFCE icons: patched {xml} -> IconThemeName={icon_theme}")
    else:
        log("XFCE icons: no change needed (OK).")


# ============================================================
# Boot mode / filesystem / install mode
# ============================================================
BOOT_AUTO = "Auto (recommended)"
BOOT_UEFI = "UEFI"
BOOT_BIOS = "BIOS / Legacy"

FS_EXT4 = "ext4 (recommended)"
FS_BTRFS = "btrfs (snapshots-ready)"
FS_XFS = "xfs (fast, stable)"

MODE_ERASE = "ERASE DISK (automatic partitioning) — DESTRUCTIVE"
MODE_EXISTING = "USE EXISTING PARTITIONS (manual selection) — NO DISK WIPE"


def effective_boot_mode(selection: str) -> str:
    if selection == BOOT_UEFI:
        return "UEFI"
    if selection == BOOT_BIOS:
        return "BIOS"
    return "UEFI" if is_uefi() else "BIOS"


def effective_fs(selection: str) -> str:
    if selection.startswith("btrfs"):
        return "btrfs"
    if selection.startswith("xfs"):
        return "xfs"
    return "ext4"


# ============================================================
# Packages
# ============================================================
DEFAULT_PACKAGES = [
    "base", "linux", "linux-firmware",
    "networkmanager", "sudo", "vim",
    "xorg-server",
    "xfce4",
    "xfce4-session",
    "xfce4-panel",
    "xfdesktop",
    "xfwm4",
    "xfce4-settings",
    "xfconf",
    "thunar",
    "tumbler",
    "gvfs",
    "xfce4-terminal",
    "file-roller",
    "pavucontrol",
    "xfce4-power-manager",
    "lightdm", "lightdm-gtk-greeter",
]

XFCE_PLUGIN_PACKAGES = [
    "xfce4-goodies",
    "xfce4-whiskermenu-plugin",
    "xfce4-pulseaudio-plugin",
    "xfce4-weather-plugin",
    "xfce4-netload-plugin",
    "xfce4-systemload-plugin",
    "xfce4-cpugraph-plugin",
    "xfce4-sensors-plugin",
    "xfce4-battery-plugin",
    "xfce4-clipman-plugin",
    "xfce4-datetime-plugin",
    "xfce4-mount-plugin",
    "xfce4-notifyd",
    "xfce4-screenshooter",
    "xfce4-taskmanager",
    "thunar-archive-plugin",
    "thunar-volman",
    "ffmpegthumbnailer",
]

ICON_PACKAGES = [
    "tela-circle-icon-theme-standard",
    "tela-circle-icon-theme-black",
    "tela-circle-icon-theme-grey",
]

AUR_PREREQS = ["base-devel", "git"]

PACKAGE_BLACKLIST = {
    "archiso", "mkarchiso", "calamares", "calamares-config", "calamares-config-xfce",
    "squashfs-tools", "zram-generator", "reflector", "clonezilla", "memtest86+",
}


def parse_packages_text(txt: str) -> List[str]:
    pkgs: List[str] = []
    for line in (txt or "").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "#" in line:
            line = line.split("#", 1)[0].strip()
        for part in line.split():
            if part:
                pkgs.append(part)
    return pkgs


def read_packages_txt(path: Path) -> List[str]:
    if not path.exists():
        return []
    return parse_packages_text(read_text(path))


def normalize_package_set(pkgs: List[str]) -> List[str]:
    out = []
    seen = set()
    for p in pkgs:
        p = (p or "").strip()
        if not p:
            continue
        if p in PACKAGE_BLACKLIST:
            continue
        if p not in seen:
            seen.add(p)
            out.append(p)
    return out


def build_base_packages(mode: str, want_yay: bool, fs: str) -> List[str]:
    micro = detect_microcode_pkg()
    base = list(DEFAULT_PACKAGES)
    base += XFCE_PLUGIN_PACKAGES
    base += ICON_PACKAGES

    if fs == "btrfs":
        base += ["btrfs-progs"]
    elif fs == "xfs":
        base += ["xfsprogs"]

    if want_yay:
        base += AUR_PREREQS

    if micro:
        base.append(micro)
    if mode == "UEFI":
        base.append("efibootmgr")
    else:
        base.append("grub")

    return normalize_package_set(base)


def choose_package_list(
    mode: str,
    want_yay: bool,
    fs: str,
    use_local_packages_txt: bool,
    use_github_packages_list: bool,
    log: Callable[[str], None]
) -> Tuple[List[str], str]:
    base = build_base_packages(mode, want_yay, fs)

    if use_local_packages_txt and LIVE_PKG_LIST.exists():
        custom = normalize_package_set(read_packages_txt(LIVE_PKG_LIST))
        combined = normalize_package_set(custom + base)
        return combined, f"Local list: {LIVE_PKG_LIST}"

    if use_github_packages_list:
        try:
            txt = download_text(GITHUB_PACKAGES_BLOB_URL, log, timeout=45)
            custom = normalize_package_set(parse_packages_text(txt))
            combined = normalize_package_set(custom + base)
            return combined, f"GitHub list: {GITHUB_PACKAGES_BLOB_URL}"
        except Exception as e:
            log(f"!! GitHub packages list failed, falling back to base: {e}")

    return base, "Default safe package set (+XFCE plugin hardening + icons)"


def pacman_sync_live(log) -> None:
    if not cmd_ok("pacman"):
        log("!! pacman not found on Live ISO; cannot sync DB.")
        return
    log("Updating pacman databases on Live ISO (pacman -Syy)…")
    rc = run_stream(["pacman", "-Syy", "--noconfirm"], log, timeout=None)
    if rc != 0:
        log("!! pacman -Syy failed on Live ISO (continuing)")


def filter_available_repo_packages(pkgs: List[str], log, chunk: int = 60) -> Tuple[List[str], List[str]]:
    if not cmd_ok("pacman"):
        log("!! pacman not found on Live ISO; cannot pre-check packages.")
        return pkgs, []

    available: List[str] = []
    missing: List[str] = []
    to_check = [p for p in pkgs if p]

    for i in range(0, len(to_check), chunk):
        batch = to_check[i:i + chunk]
        cp = subprocess.run(
            ["pacman", "-Si"] + batch,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True
        )
        out = cp.stdout or ""
        if cp.returncode == 0:
            available.extend(batch)
            continue

        missing_in_batch = set(re.findall(r"error:\s+package\s+'([^']+)'\s+was\s+not\s+found", out))
        for p in batch:
            if p in missing_in_batch:
                missing.append(p)
            else:
                cp2 = subprocess.run(["pacman", "-Si", p],
                                     stdout=subprocess.DEVNULL,
                                     stderr=subprocess.DEVNULL,
                                     text=True)
                if cp2.returncode == 0:
                    available.append(p)
                else:
                    missing.append(p)

    def dedupe(seq: List[str]) -> List[str]:
        s = set()
        out2 = []
        for x in seq:
            if x not in s:
                s.add(x)
                out2.append(x)
        return out2

    return dedupe(available), dedupe(missing)


# ============================================================
# LightDM helpers
# ============================================================
def enable_lightdm_autologin(target_root: Path, username: str, log) -> None:
    conf = target_root / "etc" / "lightdm" / "lightdm.conf"
    ensure_dir(conf.parent)
    txt = read_text(conf) if conf.exists() else ""
    if not txt.strip():
        txt = "[LightDM]\n[Seat:*]\n"
    if "[Seat:*]" not in txt:
        txt += "\n[Seat:*]\n"
    txt = re.sub(r"(?m)^\s*autologin-user\s*=.*\n?", "", txt)
    txt = re.sub(r"(?m)^\s*autologin-user-timeout\s*=.*\n?", "", txt)
    parts = txt.split("[Seat:*]", 1)
    head = parts[0]
    seat = "[Seat:*]" + (parts[1] if len(parts) > 1 else "\n")
    if not seat.endswith("\n"):
        seat += "\n"
    seat += f"autologin-user={username}\n"
    seat += "autologin-user-timeout=0\n"
    write_file(conf, head + seat)
    log(f"LightDM: enabled autologin for user '{username}' in {conf}")


# ============================================================
# AUR: yay (best-effort)
# ============================================================
def enforce_makepkg_no_debug(target_root: Path, log) -> str:
    p = target_root / "etc" / "makepkg.conf"
    orig = read_text(p) if p.exists() else ""
    if not orig.strip():
        log("AUR: /etc/makepkg.conf missing/empty; skipping debug enforcement.")
        return orig

    new = orig
    m = re.search(r'(?m)^\s*OPTIONS=\(([^)]*)\)\s*$', new)
    if m:
        inside = m.group(1).strip()
        tokens = inside.split()
        if "!debug" not in tokens:
            tokens.append("!debug")
        tokens = [t for t in tokens if t != "debug"]
        repl = "OPTIONS=(" + " ".join(tokens) + ")"
        new = re.sub(r'(?m)^\s*OPTIONS=\(([^)]*)\)\s*$', repl, new)
    else:
        new = new.rstrip() + "\nOPTIONS=(!debug)\n"

    if new != orig:
        write_file(p, new)
        log("AUR: enforced !debug in /etc/makepkg.conf to avoid long debug-symbol source copy.")
    return orig


def restore_makepkg_conf(target_root: Path, original: str, log) -> None:
    p = target_root / "etc" / "makepkg.conf"
    if original:
        write_file(p, original)
        log("AUR: restored original /etc/makepkg.conf.")


def install_yay_best_effort(target_root: Path, log) -> None:
    log("AUR: attempting to install yay (best-effort)…")
    arch_chroot_soft(target_root, "install -d -m 1777 /tmp", log)

    rc = arch_chroot_soft(target_root, "pacman -S --noconfirm --needed base-devel git sudo", log)
    if rc != 0:
        log("!! AUR: failed to install base-devel/git/sudo. Skipping yay.")
        return

    arch_chroot_soft(target_root, "id -u aurbuilder >/dev/null 2>&1 || useradd -m -s /bin/bash aurbuilder", log)

    orig = enforce_makepkg_no_debug(target_root, log)

    try:
        arch_chroot_soft(target_root, "rm -rf /tmp/aur-yay", log)

        rc = arch_chroot_soft(
            target_root,
            "sudo -u aurbuilder bash -lc 'git clone --depth 1 https://aur.archlinux.org/yay.git /tmp/aur-yay'",
            log
        )
        if rc != 0:
            log("!! AUR: git clone yay failed. Skipping yay.")
            return

        build_cmd = (
            "sudo -u aurbuilder bash -lc '"
            "set -e; "
            "cd /tmp/aur-yay; "
            "makepkg -s --noconfirm --needed --skippgpcheck; "
            "'"
        )
        rc = arch_chroot_soft(target_root, build_cmd, log)
        if rc != 0:
            log("!! AUR: makepkg build failed. Skipping yay.")
            return

        install_cmd = "bash -lc 'set -e; ls -1 /tmp/aur-yay/yay-*.pkg.tar.* | head -n1 | xargs -r pacman -U --noconfirm'"
        rc = arch_chroot_soft(target_root, install_cmd, log)
        if rc != 0:
            log("!! AUR: pacman -U yay failed. Skipping yay.")
            return

        log("AUR: yay installed successfully.")
    finally:
        restore_makepkg_conf(target_root, orig, log)


# ============================================================
# Timezone / keymap helpers
# ============================================================
def guess_live_timezone() -> str:
    try:
        lt = Path("/etc/localtime")
        if lt.is_symlink():
            target = os.readlink(str(lt))
            if "/usr/share/zoneinfo/" in target:
                return target.split("/usr/share/zoneinfo/", 1)[1]
    except Exception:
        pass
    return "America/New_York"


def list_timezones_lite(max_items: int = 2000) -> List[str]:
    base = Path("/usr/share/zoneinfo")
    if not base.exists():
        return ["UTC", "America/New_York"]
    out = []
    for root, dirs, files in os.walk(str(base)):
        rp = Path(root)
        rel = rp.relative_to(base)
        if rel.parts and rel.parts[0] in {"posix", "right"}:
            continue
        for f in files:
            p = rp / f
            if f in {"zone.tab", "zone1970.tab", "leapseconds", "tzdata.zi"}:
                continue
            if p.is_symlink():
                continue
            relp = p.relative_to(base)
            if len(relp.parts) >= 2:
                out.append("/".join(relp.parts))
    out = sorted(set(out))
    if len(out) > max_items:
        preferred = [z for z in out if z.startswith(("America/", "Europe/", "Asia/", "Australia/", "Africa/"))]
        out2 = ["UTC"] + preferred[:max_items - 1]
        return sorted(set(out2))
    return ["UTC"] + out


def guess_live_keymap() -> str:
    if cmd_ok("localectl"):
        try:
            cp = subprocess.run(["localectl", "status"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            t = cp.stdout or ""
            m = re.search(r"VC Keymap:\s*([A-Za-z0-9_-]+)", t)
            if m:
                return m.group(1).strip()
        except Exception:
            pass
    return "us"


def common_keymaps() -> List[str]:
    return [
        "us", "uk", "de", "fr", "es", "it", "pt", "br-abnt2", "ca", "dvorak", "colemak",
        "ru", "ua", "pl", "nl", "se", "no", "fi", "dk", "cz", "sk", "hu", "tr",
        "jp106", "kr", "cn", "in", "latam"
    ]


# ============================================================
# Threads
# ============================================================
@dataclass
class PreflightResult:
    root_ok: bool
    uefi_detected: bool
    internet_ok: bool
    disks: List[Tuple[str, str, str]]
    missing_base_tools: List[str]
    missing_uefi_tools: List[str]
    skel_found: bool
    stormos_wallpapers_found: bool
    packages_found: bool
    wifi_line: str


class PreflightThread(QThread):
    log = pyqtSignal(str)
    done = pyqtSignal(object)

    def run(self) -> None:
        def L(s: str):
            self.log.emit(s)

        L("Checking environment…")
        time.sleep(0.05)
        root_ok = is_root()
        uefi_detected = is_uefi()
        internet_ok = have_internet_fast()
        L("Checking required tools…")
        base_required = [
            "lsblk", "wipefs", "sfdisk", "mkfs.ext4", "mount", "umount",
            "pacstrap", "genfstab", "arch-chroot", "blkid", "partprobe", "udevadm", "sync", "pacman"
        ]
        missing_base = [c for c in base_required if not cmd_ok(c)]
        uefi_required = ["sgdisk", "mkfs.fat", "bootctl"]
        missing_uefi = [c for c in uefi_required if not cmd_ok(c)]
        L("Detecting disks…")
        disks = list_disks()
        self.done.emit(PreflightResult(
            root_ok=root_ok,
            uefi_detected=uefi_detected,
            internet_ok=internet_ok,
            disks=disks,
            missing_base_tools=missing_base,
            missing_uefi_tools=missing_uefi,
            skel_found=LIVE_SKEL.exists(),
            stormos_wallpapers_found=Path("/usr/share/backgrounds/StormOS").exists(),
            packages_found=LIVE_PKG_LIST.exists(),
            wifi_line=wifi_status_line(),
        ))


@dataclass
class InstallPlan:
    install_mode: str  # MODE_ERASE or MODE_EXISTING

    disk: str
    boot_mode_choice: str
    fs_choice: str

    # For MODE_EXISTING:
    root_part: str = ""
    esp_part: str = ""
    format_root: bool = True
    format_esp: bool = False

    hostname: str = "stormos"
    username: str = "user"
    password: str = ""

    timezone: str = "UTC"
    locale: str = "en_US"
    keymap: str = "us"

    set_root_password: bool = False
    root_password: str = ""
    mountpoint: str = "/mnt"

    # personalization toggles
    do_skel: bool = True
    do_copy_stormos_wallpapers: bool = True
    do_lightdm: bool = True
    do_patch_xfce_wall: bool = True
    do_migrate_usr_local_bin: bool = True

    # packages toggles
    use_local_packages_txt: bool = True
    use_github_packages_list: bool = True
    install_github_zst_packages: bool = True

    # lightdm failsafe
    enable_autologin: bool = False

    # theme default
    default_theme_preferred: str = "adw-gtk-dark"

    # yay best-effort
    install_yay: bool = True


class InstallThread(QThread):
    log = pyqtSignal(str)
    progress = pyqtSignal(int)
    ok = pyqtSignal()
    fail = pyqtSignal(str)

    def __init__(self, plan: InstallPlan, parent=None):
        super().__init__(parent)
        self.plan = plan

    def run(self) -> None:
        try:
            self._run_impl()
            self.ok.emit()
        except Exception as e:
            import traceback
            self.fail.emit(f"{type(e).__name__}: {e}\n{traceback.format_exc()}")

    def _run_impl(self) -> None:
        reset_log_file()
        p = self.plan
        mode = effective_boot_mode(p.boot_mode_choice)

        def L(s: str):
            self.log.emit(s)
            log_to_file(s)

        def P(n: int):
            self.progress.emit(max(0, min(100, n)))

        if not is_root():
            raise RuntimeError("Must run as root.")
        if p.boot_mode_choice == BOOT_UEFI and not is_uefi():
            raise RuntimeError("UEFI selected but the machine is booted in BIOS mode.")

        base_required = [
            "wipefs", "sfdisk", "mount", "umount",
            "pacstrap", "genfstab", "arch-chroot", "blkid", "partprobe", "udevadm", "pacman"
        ]
        missing = [c for c in base_required if not cmd_ok(c)]
        if missing:
            raise RuntimeError("Missing required commands on Live ISO:\n" + "\n".join(missing))
        if mode == "UEFI":
            for c in ["sgdisk", "mkfs.fat", "bootctl"]:
                if not cmd_ok(c):
                    raise RuntimeError(f"UEFI mode missing required command on Live ISO: {c}")

        L("== StormOS / Arch XFCE Easy Installer ==")
        L(f"Install mode: {p.install_mode}")
        L(f"Boot mode: {mode} (selection: {p.boot_mode_choice})")
        L(f"Disk: {p.disk}")
        if p.install_mode == MODE_EXISTING:
            L(f"Root partition: {p.root_part}")
            if mode == "UEFI":
                L(f"EFI partition: {p.esp_part}")
            L(f"Format root: {'YES' if p.format_root else 'NO'}")
            if mode == "UEFI":
                L(f"Format EFI: {'YES' if p.format_esp else 'NO'}")
        L(f"Saved log: {LOG_FILE}")
        L("")
        P(2)

        # Step 0: multilib in live
        L("== Step 0/14: Enabling multilib on Live ISO ==")
        ensure_multilib_enabled_live(L)
        P(4)

        # Step 1: prep /mnt
        L("== Step 1/14: Preparing mountpoint ==")
        safe_umount_recursive(p.mountpoint)
        ensure_dir(Path(p.mountpoint))
        P(6)

        # Decide effective filesystem used for ROOT:
        fs_selected = effective_fs(p.fs_choice)

        # If using existing and NOT formatting root, detect fstype from blkid:
        if p.install_mode == MODE_EXISTING and not p.format_root:
            detected = blkid_fstype(p.root_part)
            if not detected:
                raise RuntimeError("Could not detect existing root partition filesystem (blkid TYPE is empty).")
            fs_root = detected
        else:
            fs_root = fs_selected

        # Sanity: required tools for formatting chosen FS
        if p.install_mode == MODE_ERASE or (p.install_mode == MODE_EXISTING and p.format_root):
            if fs_root == "btrfs" and not cmd_ok("mkfs.btrfs"):
                raise RuntimeError("Selected btrfs, but mkfs.btrfs is missing on the Live ISO.")
            if fs_root == "xfs" and not cmd_ok("mkfs.xfs"):
                raise RuntimeError("Selected xfs, but mkfs.xfs is missing on the Live ISO.")

        target_root = Path(p.mountpoint)

        # ============================================================
        # STORAGE: ERASE DISK MODE
        # ============================================================
        if p.install_mode == MODE_ERASE:
            L("== Step 2/14: Partitioning disk (ERASE MODE) ==")
            subprocess.run(["wipefs", "-a", p.disk], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

            if mode == "UEFI":
                L("$ sgdisk --zap-all DISK")
                rc = run_stream(["sgdisk", "--zap-all", p.disk], L, timeout=60)
                if rc != 0:
                    raise RuntimeError(f"sgdisk --zap-all failed (rc={rc})")
                L("Creating GPT partitions: EFI (1GiB) + ROOT (rest)")
                rc = run_stream(["sgdisk", "-n", "1:0:+1G", "-t", "1:EF00", "-c", "1:EFI", p.disk], L, timeout=60)
                if rc != 0:
                    raise RuntimeError(f"sgdisk create EFI failed (rc={rc})")
                rc = run_stream(["sgdisk", "-n", "2:0:0", "-t", "2:8300", "-c", "2:ROOT", p.disk], L, timeout=60)
                if rc != 0:
                    raise RuntimeError(f"sgdisk create ROOT failed (rc={rc})")
            else:
                L("Creating MBR partition table: 1x Linux partition (bootable)")
                sfdisk_script = "label: dos\nunit: sectors\n"
                sfdisk_script += f"{p.disk}1 : start=2048, type=83, bootable\n"
                rc = run_stream(["sfdisk", p.disk], L, timeout=60, input_text=sfdisk_script)
                if rc != 0:
                    raise RuntimeError(f"sfdisk failed (rc={rc})")

            subprocess.run(["partprobe", p.disk], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            subprocess.run(["udevadm", "settle"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            time.sleep(1.0)

            if mode == "UEFI":
                esp = partition_path(p.disk, 1)
                rootp = partition_path(p.disk, 2)
            else:
                esp = ""
                rootp = partition_path(p.disk, 1)

            if not Path(rootp).exists():
                subprocess.run(["udevadm", "settle"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                time.sleep(1.0)
            if not Path(rootp).exists():
                raise RuntimeError(f"Partition device not found: {rootp}")
            if mode == "UEFI" and (not esp or not Path(esp).exists()):
                subprocess.run(["udevadm", "settle"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                time.sleep(1.0)
            if mode == "UEFI" and (not esp or not Path(esp).exists()):
                raise RuntimeError(f"EFI partition device not found: {esp}")

            P(14)

            # Step 3: format
            L("== Step 3/14: Formatting filesystems ==")
            if mode == "UEFI":
                rc = run_stream(["mkfs.fat", "-F32", "-n", "EFI", esp], L, timeout=120)
                if rc != 0:
                    raise RuntimeError(f"mkfs.fat failed (rc={rc})")

            if fs_root == "ext4":
                rc = run_stream(["mkfs.ext4", "-F", "-L", "ROOT", rootp], L, timeout=300)
            elif fs_root == "btrfs":
                rc = run_stream(["mkfs.btrfs", "-f", "-L", "ROOT", rootp], L, timeout=300)
            else:
                rc = run_stream(["mkfs.xfs", "-f", "-L", "ROOT", rootp], L, timeout=300)

            if rc != 0:
                raise RuntimeError(f"mkfs for {fs_root} failed (rc={rc})")

            P(24)

            # Step 4: mount
            L("== Step 4/14: Mounting target ==")
            if fs_root == "btrfs":
                rc = run_stream(["mount", rootp, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs temp) failed")
                run_stream(["btrfs", "subvolume", "create", f"{p.mountpoint}/@"], L, timeout=60)
                run_stream(["btrfs", "subvolume", "create", f"{p.mountpoint}/@home"], L, timeout=60)
                run_stream(["umount", p.mountpoint], L, timeout=60)

                ensure_dir(Path(p.mountpoint))
                rc = run_stream(["mount", "-o", "subvol=@,compress=zstd:1", rootp, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs @) failed")
                ensure_dir(Path(p.mountpoint) / "home")
                rc = run_stream(["mount", "-o", "subvol=@home,compress=zstd:1", rootp, f"{p.mountpoint}/home"], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs @home) failed")
            else:
                rc = run_stream(["mount", rootp, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount root failed")

            ensure_dir(Path(p.mountpoint) / "boot")
            if mode == "UEFI":
                rc = run_stream(["mount", esp, f"{p.mountpoint}/boot"], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount EFI failed")

            P(32)

        # ============================================================
        # STORAGE: USE EXISTING PARTITIONS MODE
        # ============================================================
        else:
            L("== Step 2/14: Using existing partitions (NO disk wipe) ==")

            if not p.root_part or not Path(p.root_part).exists():
                raise RuntimeError("Root partition not selected or does not exist.")
            if mode == "UEFI":
                if not p.esp_part or not Path(p.esp_part).exists():
                    raise RuntimeError("UEFI install requires selecting an EFI partition (FAT32).")

            P(10)

            L("== Step 3/14: Optional formatting (existing partitions) ==")
            if p.format_root:
                L(f"Formatting ROOT {p.root_part} as {fs_root}…")
                if fs_root == "ext4":
                    rc = run_stream(["mkfs.ext4", "-F", "-L", "ROOT", p.root_part], L, timeout=300)
                elif fs_root == "btrfs":
                    rc = run_stream(["mkfs.btrfs", "-f", "-L", "ROOT", p.root_part], L, timeout=300)
                else:
                    rc = run_stream(["mkfs.xfs", "-f", "-L", "ROOT", p.root_part], L, timeout=300)
                if rc != 0:
                    raise RuntimeError(f"mkfs for {fs_root} failed (rc={rc})")
            else:
                L("Keeping existing ROOT filesystem (no format).")

            if mode == "UEFI":
                if p.format_esp:
                    L(f"Formatting EFI {p.esp_part} as FAT32…")
                    rc = run_stream(["mkfs.fat", "-F32", "-n", "EFI", p.esp_part], L, timeout=120)
                    if rc != 0:
                        raise RuntimeError(f"mkfs.fat failed (rc={rc})")
                else:
                    L("Keeping existing EFI filesystem (no format).")

            P(24)

            L("== Step 4/14: Mounting existing partitions ==")

            if fs_root == "btrfs" and p.format_root:
                rc = run_stream(["mount", p.root_part, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs temp) failed")
                run_stream(["btrfs", "subvolume", "create", f"{p.mountpoint}/@"], L, timeout=60)
                run_stream(["btrfs", "subvolume", "create", f"{p.mountpoint}/@home"], L, timeout=60)
                run_stream(["umount", p.mountpoint], L, timeout=60)

                ensure_dir(Path(p.mountpoint))
                rc = run_stream(["mount", "-o", "subvol=@,compress=zstd:1", p.root_part, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs @) failed")
                ensure_dir(Path(p.mountpoint) / "home")
                rc = run_stream(["mount", "-o", "subvol=@home,compress=zstd:1", p.root_part, f"{p.mountpoint}/home"], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs @home) failed")
            else:
                rc = run_stream(["mount", p.root_part, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount root failed")

            ensure_dir(Path(p.mountpoint) / "boot")
            if mode == "UEFI":
                rc = run_stream(["mount", p.esp_part, f"{p.mountpoint}/boot"], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount EFI failed")

            P(32)

        # ============================================================
        # COMMON INSTALL STEPS FROM HERE
        # ============================================================
        L("== Step 5/14: Installing packages (pacstrap) ==")
        pkgs, src_desc = choose_package_list(
            mode=mode,
            want_yay=p.install_yay,
            fs=fs_root,
            use_local_packages_txt=p.use_local_packages_txt,
            use_github_packages_list=p.use_github_packages_list,
            log=L
        )
        L(f"Package source: {src_desc}")

        pacman_sync_live(L)

        pkgs_ok, pkgs_missing = filter_available_repo_packages(pkgs, L)
        if pkgs_missing:
            L("")
            L("!! Packages NOT available in current repos and will be skipped (prevents pacstrap failure):")
            for m in pkgs_missing[:250]:
                L(f"   - {m}")
            if len(pkgs_missing) > 250:
                L(f"   ... and {len(pkgs_missing) - 250} more")
            L("")

        pkgs = pkgs_ok
        if not pkgs:
            raise RuntimeError("After filtering, package list is empty. Check your repos/internet.")

        L("Packages to pacstrap:")
        L("  " + " ".join(pkgs))

        rc = run_stream(["pacstrap", "-K", p.mountpoint, "--needed"] + pkgs, L, timeout=None)
        if rc != 0:
            raise RuntimeError(f"pacstrap failed (rc={rc}). Check internet/mirrors.")

        P(58)

        # Enable multilib in target
        L("== Step 5.5/14: Enabling multilib in installed system ==")
        ensure_multilib_enabled_target(target_root, L)
        arch_chroot(target_root, "pacman -Syy --noconfirm", L)
        P(62)

        # ZST extras
        L("== Step 6/14: Installing StormOS extra .pkg.tar.zst packages (your theme) ==")
        if p.install_github_zst_packages and GITHUB_ZST_BLOB_URLS:
            stash = target_root / "root" / "stormos-zst"
            ensure_dir(stash)
            downloaded = []
            for u in GITHUB_ZST_BLOB_URLS:
                name = Path(u.split("?", 1)[0]).name
                dest = stash / name
                download_file(u, dest, L, timeout=240)
                downloaded.append("/root/stormos-zst/" + name)
            arch_chroot(target_root, "pacman -Sy --noconfirm", L)
            arch_chroot(target_root, "pacman -U --noconfirm " + " ".join(shlex.quote(x) for x in downloaded), L)
            L("Extra .zst packages installed.")
        else:
            L("Skipping extra .zst packages.")
        P(70)

        # fstab
        L("== Step 7/14: Generating fstab ==")
        cp = subprocess.run(["genfstab", "-U", p.mountpoint],
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        if cp.returncode != 0:
            raise RuntimeError("genfstab failed:\n" + (cp.stdout or ""))

        fstab_path = target_root / "etc" / "fstab"
        ensure_dir(fstab_path.parent)
        fstab_path.write_text((cp.stdout or ""), encoding="utf-8", errors="ignore")
        P(74)

        # personalization
        L("== Step 8/14: Personalization (defaults) ==")
        if p.do_skel:
            apply_skel_preset(target_root, L)
        else:
            ensure_dir(target_root / "etc" / "skel")

        if p.do_migrate_usr_local_bin:
            migrate_usr_local_bin(target_root, L)

        ensure_default_wallpaper_svg(target_root, L)

        if p.do_copy_stormos_wallpapers:
            copy_stormos_wallpapers_into_backgrounds(target_root, L)

        theme_name = choose_best_theme_name(target_root, preferred=p.default_theme_preferred)
        icon_theme = choose_best_icon_theme(target_root)

        write_default_gtk_settings_to_skel(target_root, theme_name=theme_name, icon_theme=icon_theme, log=L)
        patch_xfce_icon_theme_in_skel(target_root, icon_theme=icon_theme, log=L)

        if p.do_patch_xfce_wall:
            patch_xfce_wallpaper_in_skel(target_root, DEFAULT_WALLPAPER_PATH, L)

        if p.do_lightdm:
            configure_lightdm_greeter(target_root, DEFAULT_WALLPAPER_PATH, L, theme_name=theme_name, icon_theme=icon_theme)

        P(80)

        # system config
        L("== Step 9/14: System configuration ==")
        hostname = sanitize_hostname(p.hostname)
        write_file(target_root / "etc" / "hostname", hostname + "\n")

        hosts = (
            "127.0.0.1\tlocalhost\n"
            "::1\t\tlocalhost\n"
            f"127.0.1.1\t{hostname}.localdomain\t{hostname}\n"
        )
        write_file(target_root / "etc" / "hosts", hosts)

        locale_gen = target_root / "etc" / "locale.gen"
        lg = read_text(locale_gen)
        if lg:
            loc = p.locale.strip()
            lg2 = re.sub(rf"^#\s*({re.escape(loc)}\.UTF-8)\s*$", r"\1", lg, flags=re.M)
            lg2 = re.sub(rf"^#\s*({re.escape(loc)}\s+UTF-8)\s*$", r"\1", lg2, flags=re.M)
            write_file(locale_gen, lg2)

        write_file(target_root / "etc" / "locale.conf", f"LANG={p.locale}.UTF-8\n")
        write_file(target_root / "etc" / "vconsole.conf", f"KEYMAP={p.keymap}\n")

        arch_chroot(target_root, f"ln -sf /usr/share/zoneinfo/{shlex.quote(p.timezone)} /etc/localtime", L)
        arch_chroot(target_root, "hwclock --systohc", L)
        arch_chroot(target_root, "locale-gen", L)

        arch_chroot(target_root, "systemctl enable NetworkManager", L)
        arch_chroot(target_root, "systemctl enable lightdm", L)
        arch_chroot(target_root, r"sed -i 's/^# %wheel ALL=(ALL:ALL) ALL/%wheel ALL=(ALL:ALL) ALL/' /etc/sudoers", L)

        P(86)

        # create user
        L("== Step 10/14: Creating user ==")
        user = sanitize_username(p.username)
        arch_chroot(target_root, f"useradd -m -G wheel -s /bin/bash {shlex.quote(user)}", L)

        arch_chroot_input(target_root, "chpasswd", f"{user}:{p.password}\n", L)
        if p.set_root_password and p.root_password.strip():
            arch_chroot_input(target_root, "chpasswd", f"root:{p.root_password}\n", L)
        else:
            arch_chroot(target_root, "passwd -l root || true", L)

        if p.enable_autologin:
            enable_lightdm_autologin(target_root, user, L)

        P(90)

        # yay
        L("== Step 10.5/14: AUR helper (yay) (best-effort) ==")
        if p.install_yay:
            try:
                install_yay_best_effort(target_root, L)
            except Exception as e:
                L(f"!! AUR: yay install failed (continuing): {e}")
        else:
            L("Skipping yay (disabled).")

        P(92)

        # bootloader
        L("== Step 11/14: Installing bootloader ==")
        micro = detect_microcode_pkg()

        if mode == "UEFI":
            root_dev_for_partuuid = partition_path(p.disk, 2) if p.install_mode == MODE_ERASE else p.root_part

            arch_chroot(target_root, "bootctl --path=/boot install", L)

            loader_conf = (
                "default arch\n"
                "timeout 3\n"
                "console-mode max\n"
                "editor no\n"
            )
            write_file(target_root / "boot" / "loader" / "loader.conf", loader_conf)

            root_partuuid = blkid_partuuid(root_dev_for_partuuid)
            if not root_partuuid:
                raise RuntimeError("Failed to read PARTUUID for root partition.")

            initrd_lines = ""
            if micro == "intel-ucode":
                initrd_lines += "initrd  /intel-ucode.img\n"
            elif micro == "amd-ucode":
                initrd_lines += "initrd  /amd-ucode.img\n"
            initrd_lines += "initrd  /initramfs-linux.img\n"

            entry = (
                "title   Arch Linux (StormOS XFCE)\n"
                "linux   /vmlinuz-linux\n"
                f"{initrd_lines}"
                f"options root=PARTUUID={root_partuuid} rw quiet loglevel=3\n"
            )
            write_file(target_root / "boot" / "loader" / "entries" / "arch.conf", entry)

        else:
            arch_chroot(target_root, f"grub-install --target=i386-pc --recheck {shlex.quote(p.disk)}", L)
            arch_chroot(target_root, "grub-mkconfig -o /boot/grub/grub.cfg", L)

        P(98)

        # finish
        L("== Step 12/14: Finalizing ==")
        subprocess.run(["sync"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        P(100)
        L("")
        L("✅ INSTALL COMPLETE. You can reboot now.")


# ============================================================
# GUI helpers (scroll pages)
# ============================================================
def make_scroll_page(content_widget: QWidget) -> QWidget:
    outer = QWidget()
    v = QVBoxLayout(outer)
    v.setContentsMargins(8, 8, 8, 8)

    scroll = QScrollArea()
    scroll.setWidgetResizable(True)
    scroll.setFrameShape(QScrollArea.NoFrame)

    inner = QWidget()
    inner_l = QVBoxLayout(inner)
    inner_l.setContentsMargins(6, 6, 6, 6)
    inner_l.addWidget(content_widget)
    inner_l.addStretch(1)

    scroll.setWidget(inner)
    v.addWidget(scroll, 1)
    return outer


# ============================================================
# GUI
# ============================================================
class Wizard(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("StormOS / Arch XFCE Easy Installer — Midnight Edition (UEFI + BIOS)")
        self.resize(980, 740)

        self.stack = QStackedWidget()
        self.setCentralWidget(self.stack)
        self.preflight: Optional[PreflightResult] = None
        self.preflight_thread: Optional[PreflightThread] = None
        self.install_thread: Optional[InstallThread] = None

        self.page_welcome = self._build_welcome()
        self.page_checks = self._build_checks()
        self.page_config = self._build_config()
        self.page_personalize = self._build_personalize()
        self.page_confirm = self._build_confirm()
        self.page_install = self._build_install()
        self.page_done = self._build_done()

        for pg in [self.page_welcome, self.page_checks, self.page_config, self.page_personalize,
                   self.page_confirm, self.page_install, self.page_done]:
            self.stack.addWidget(pg)

        QTimer.singleShot(0, self._go_welcome)

    def _title(self, text: str) -> QLabel:
        lab = QLabel(text)
        lab.setFont(QFont("Sans", 16, QFont.Bold))
        lab.setWordWrap(True)
        # subtle glow-ish accent
        lab.setStyleSheet("QLabel { color: #dbe3ff; }")
        return lab

    def _danger_banner(self, text: str) -> QLabel:
        lab = QLabel(text)
        lab.setWordWrap(True)
        # midnight-danger panel (red accent)
        lab.setStyleSheet(
            "QLabel { background: #2a0c17; color: #ffd7e1; border: 2px solid #ff3b6b; "
            "border-radius: 14px; padding: 12px; font-weight: 900; }"
        )
        return lab

    def _accent_banner(self, text: str) -> QLabel:
        lab = QLabel(text)
        lab.setWordWrap(True)
        lab.setStyleSheet(
            "QLabel { background: #0f2144; color: #d7e8ff; border: 1px solid #2b77ff; "
            "border-radius: 14px; padding: 12px; font-weight: 800; }"
        )
        return lab

    # ----------------------------
    # Welcome
    # ----------------------------
    def _build_welcome(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("StormOS / Arch XFCE Easy Installer"))

        warn = QTextEdit()
        warn.setReadOnly(True)
        warn.setPlainText(
            "⚠️ WARNING — POTENTIALLY DESTRUCTIVE INSTALLER\n\n"
            "You can choose:\n"
            "• ERASE DISK (auto partition + format)  — DESTROYS DATA\n"
            "• USE EXISTING PARTITIONS (pick root/EFI) — no wipe\n\n"
            "Saved installer log:\n"
            f"  {LOG_FILE}\n"
        )
        warn.setMinimumHeight(220)
        lay.addWidget(warn, 1)

        self.lbl_env = self._accent_banner("")
        lay.addWidget(self.lbl_env)

        row = QHBoxLayout()
        row.addStretch(1)
        btn_next = QPushButton("Next →")
        btn_next.setMinimumHeight(40)
        btn_next.setStyleSheet(
            "QPushButton { background: #2b77ff; border: 1px solid #6aa9ff; color: white; "
            "font-weight: 900; border-radius: 12px; padding: 10px 14px; }"
            "QPushButton:hover { background: #3a86ff; }"
            "QPushButton:pressed { background: #1e5fe0; }"
        )
        btn_next.clicked.connect(self._go_checks)
        row.addWidget(btn_next)
        lay.addLayout(row)

        return make_scroll_page(content)

    # ----------------------------
    # Preflight
    # ----------------------------
    def _build_checks(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Preflight Checks (no freezing)"))

        self.chk_log = QPlainTextEdit()
        self.chk_log.setReadOnly(True)
        self.chk_log.setMinimumHeight(280)
        lay.addWidget(self.chk_log, 1)

        row = QHBoxLayout()
        self.btn_checks_back = QPushButton("← Back")
        self.btn_checks_back.setMinimumHeight(40)
        self.btn_checks_back.clicked.connect(lambda: self.stack.setCurrentWidget(self.page_welcome))

        self.btn_checks_next = QPushButton("Continue →")
        self.btn_checks_next.setMinimumHeight(40)
        self.btn_checks_next.setEnabled(False)
        self.btn_checks_next.setStyleSheet(
            "QPushButton { background: #2b77ff; border: 1px solid #6aa9ff; color: white; font-weight: 900; }"
            "QPushButton:hover { background: #3a86ff; }"
            "QPushButton:disabled { background: #111829; border: 1px solid #1a2340; color: #7f87b8; }"
        )
        self.btn_checks_next.clicked.connect(self._go_config)

        row.addWidget(self.btn_checks_back)
        row.addStretch(1)
        row.addWidget(self.btn_checks_next)
        lay.addLayout(row)

        return make_scroll_page(content)

    def _append_checks(self, s: str):
        self.chk_log.appendPlainText(s)
        sb = self.chk_log.verticalScrollBar()
        sb.setValue(sb.maximum())

    def _go_checks(self):
        self.chk_log.clear()
        self.btn_checks_next.setEnabled(False)
        self.stack.setCurrentWidget(self.page_checks)
        self.preflight_thread = PreflightThread()
        self.preflight_thread.log.connect(self._append_checks)
        self.preflight_thread.done.connect(self._on_preflight_done)
        self.preflight_thread.start()

    def _on_preflight_done(self, res: PreflightResult):
        self.preflight = res
        self._append_checks("")
        self._append_checks("=== Results ===")
        self._append_checks(f"Root: {'OK' if res.root_ok else 'NO'}")
        self._append_checks(f"UEFI detected: {'YES' if res.uefi_detected else 'NO'}")
        self._append_checks(f"Internet: {'OK' if res.internet_ok else 'NOT detected'}")
        self._append_checks(res.wifi_line)

        if res.missing_base_tools:
            self._append_checks("")
            self._append_checks("Missing REQUIRED tools on the Live ISO:")
            for c in res.missing_base_tools:
                self._append_checks(f"  - {c}")
            self._append_checks("")
            self._append_checks("Fix the ISO contents, then try again.")
            self.btn_checks_next.setEnabled(False)
            return

        if not res.root_ok:
            self._append_checks("\nRun this installer with sudo/pkexec.")
            self.btn_checks_next.setEnabled(False)
            return

        if not res.disks:
            self._append_checks("\nNo disks found.")
            self.btn_checks_next.setEnabled(False)
            return

        self._append_checks("")
        self._append_checks(f"Disks found: {len(res.disks)}")
        for dev, size, model in res.disks:
            self._append_checks(f"  - {dev} {size} {model}".strip())

        self.btn_checks_next.setEnabled(True)

    # ----------------------------
    # Config page (install mode + disk + partitions)
    # ----------------------------
    def _build_config(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Install Configuration"))

        box = QGroupBox("Basics")
        form = QFormLayout(box)

        self.cmb_install_mode = QComboBox()
        self.cmb_install_mode.addItems([MODE_ERASE, MODE_EXISTING])

        self.cmb_boot = QComboBox()
        self.cmb_boot.addItems([BOOT_AUTO, BOOT_UEFI, BOOT_BIOS])

        self.cmb_fs = QComboBox()
        self.cmb_fs.addItems([FS_EXT4, FS_BTRFS, FS_XFS])

        # Disk selection + refresh
        disk_row = QHBoxLayout()
        self.cmb_disk = QComboBox()
        self.btn_refresh_disks = QPushButton("Refresh")
        self.btn_refresh_disks.setMinimumHeight(36)
        self.btn_refresh_disks.clicked.connect(self._refresh_disks)
        disk_row.addWidget(self.cmb_disk, 1)
        disk_row.addWidget(self.btn_refresh_disks)

        # Existing partitions (shown/hidden)
        self.cmb_root_part = QComboBox()
        self.cmb_esp_part = QComboBox()

        self.chk_format_root = QCheckBox("Format ROOT partition")
        self.chk_format_root.setChecked(True)

        self.chk_format_esp = QCheckBox("Format EFI partition (FAT32)")
        self.chk_format_esp.setChecked(False)

        # user info
        self.ed_hostname = QLineEdit("stormos")
        self.ed_user = QLineEdit("seeker")
        self.ed_pass = QLineEdit("")
        self.ed_pass.setEchoMode(QLineEdit.Password)

        self.chk_root = QCheckBox("Set root password (optional)")
        self.ed_rootpass = QLineEdit("")
        self.ed_rootpass.setEchoMode(QLineEdit.Password)
        self.ed_rootpass.setEnabled(False)
        self.chk_root.stateChanged.connect(lambda st: self.ed_rootpass.setEnabled(st == Qt.Checked))

        # Locale/timezone/keymap
        self.cmb_tz = QComboBox()
        self.cmb_tz.setEditable(True)
        tz_list = list_timezones_lite()
        self.cmb_tz.addItems(tz_list)
        self.cmb_tz.setCurrentText(guess_live_timezone())
        btn_tz_detect = QPushButton("Detect")
        btn_tz_detect.setMinimumHeight(36)
        btn_tz_detect.clicked.connect(lambda: self.cmb_tz.setCurrentText(guess_live_timezone()))
        tz_row = QHBoxLayout()
        tz_row.addWidget(self.cmb_tz, 1)
        tz_row.addWidget(btn_tz_detect)

        self.cmb_locale = QComboBox()
        self.cmb_locale.setEditable(True)
        self.cmb_locale.addItems(["en_US", "en_GB", "es_ES", "fr_FR", "de_DE", "it_IT", "pt_BR", "ru_RU", "pl_PL", "nl_NL"])
        self.cmb_locale.setCurrentText("en_US")

        self.cmb_keymap = QComboBox()
        self.cmb_keymap.setEditable(True)
        self.cmb_keymap.addItems(common_keymaps())
        self.cmb_keymap.setCurrentText(guess_live_keymap())
        btn_km_detect = QPushButton("Detect")
        btn_km_detect.setMinimumHeight(36)
        btn_km_detect.clicked.connect(lambda: self.cmb_keymap.setCurrentText(guess_live_keymap()))
        km_row = QHBoxLayout()
        km_row.addWidget(self.cmb_keymap, 1)
        km_row.addWidget(btn_km_detect)

        form.addRow("Install mode:", self.cmb_install_mode)
        form.addRow("Boot mode:", self.cmb_boot)
        form.addRow("Filesystem (used when formatting ROOT):", self.cmb_fs)
        form.addRow("Target disk:", disk_row)

        form.addRow("ROOT partition (existing):", self.cmb_root_part)
        form.addRow("EFI partition (existing, UEFI only):", self.cmb_esp_part)
        form.addRow("", self.chk_format_root)
        form.addRow("", self.chk_format_esp)

        form.addRow("Hostname:", self.ed_hostname)
        form.addRow("Username:", self.ed_user)
        form.addRow("User password:", self.ed_pass)

        row_root = QHBoxLayout()
        row_root.addWidget(self.chk_root)
        row_root.addWidget(self.ed_rootpass, 1)
        form.addRow("Root:", row_root)

        form.addRow("Timezone:", tz_row)
        form.addRow("Locale (no .UTF-8):", self.cmb_locale)
        form.addRow("Keymap:", km_row)

        lay.addWidget(box)

        self.lbl_config_hint = QLabel("")
        self.lbl_config_hint.setWordWrap(True)
        self.lbl_config_hint.setStyleSheet("QLabel { color: #b8c2ff; }")
        lay.addWidget(self.lbl_config_hint)

        # wiring: mode changes update visibility; disk changes update partition lists
        self.cmb_install_mode.currentIndexChanged.connect(self._update_mode_visibility)
        self.cmb_disk.currentIndexChanged.connect(self._refresh_partitions_for_selected_disk)
        self.cmb_boot.currentIndexChanged.connect(self._update_mode_visibility)
        self.chk_format_root.stateChanged.connect(self._update_fs_enabled)

        row = QHBoxLayout()
        btn_back = QPushButton("← Back")
        btn_back.setMinimumHeight(40)
        btn_back.clicked.connect(lambda: self.stack.setCurrentWidget(self.page_checks))
        btn_next = QPushButton("Next →")
        btn_next.setMinimumHeight(40)
        btn_next.setStyleSheet(
            "QPushButton { background: #2b77ff; border: 1px solid #6aa9ff; color: white; font-weight: 900; }"
            "QPushButton:hover { background: #3a86ff; }"
        )
        btn_next.clicked.connect(self._go_personalize)
        row.addWidget(btn_back)
        row.addStretch(1)
        row.addWidget(btn_next)
        lay.addLayout(row)

        return make_scroll_page(content)

    def _refresh_disks(self):
        disks = list_disks()
        cur = self.cmb_disk.currentData()
        self.cmb_disk.blockSignals(True)
        self.cmb_disk.clear()
        for dev, size, model in disks:
            self.cmb_disk.addItem(f"{dev} — {size} — {model}".strip(" —"), dev)
        if cur:
            idx = self.cmb_disk.findData(cur)
            if idx >= 0:
                self.cmb_disk.setCurrentIndex(idx)
        self.cmb_disk.blockSignals(False)
        self._refresh_partitions_for_selected_disk()
        self._update_mode_visibility()

    def _update_fs_enabled(self):
        is_existing = (self.cmb_install_mode.currentText() == MODE_EXISTING)
        if is_existing:
            self.cmb_fs.setEnabled(self.chk_format_root.isChecked())
        else:
            self.cmb_fs.setEnabled(True)

    def _update_mode_visibility(self):
        is_existing = (self.cmb_install_mode.currentText() == MODE_EXISTING)
        eff_mode = effective_boot_mode(self.cmb_boot.currentText())

        self.cmb_root_part.setVisible(is_existing)
        self.chk_format_root.setVisible(is_existing)
        self.cmb_esp_part.setVisible(is_existing and eff_mode == "UEFI")
        self.chk_format_esp.setVisible(is_existing and eff_mode == "UEFI")

        if not (is_existing and eff_mode == "UEFI"):
            self.cmb_esp_part.setCurrentIndex(-1)

        self._update_fs_enabled()

        if is_existing:
            self.lbl_config_hint.setText(
                "Existing partitions mode:\n"
                "• Select ROOT (required)\n"
                "• If UEFI: select EFI partition (required) mounted to /boot\n"
                "• Formatting is optional (but recommended if you want a clean install)."
            )
        else:
            self.lbl_config_hint.setText(
                "Erase disk mode:\n"
                "• The installer will wipe the entire disk and create partitions automatically."
            )

    def _refresh_partitions_for_selected_disk(self):
        disk = self.cmb_disk.currentData()
        if not disk:
            return
        parts = list_partitions_for_disk(disk)

        def label_for(p):
            dev, size, fstype, mnt, plabel, ptype = p
            pieces = [dev, size]
            if fstype:
                pieces.append(fstype)
            if plabel:
                pieces.append(f"label={plabel}")
            if mnt:
                pieces.append(f"mnt={mnt}")
            if ptype:
                pieces.append(f"type={ptype}")
            return " — ".join(pieces)

        self.cmb_root_part.blockSignals(True)
        self.cmb_root_part.clear()
        for p in parts:
            dev = p[0]
            self.cmb_root_part.addItem(label_for(p), dev)
        self.cmb_root_part.blockSignals(False)

        self.cmb_esp_part.blockSignals(True)
        self.cmb_esp_part.clear()
        for p in parts:
            dev, size, fstype, mnt, plabel, ptype = p
            is_efi = (fstype.lower() == "vfat") or ("ef00" in (ptype or "").lower()) or ("efi" in (plabel or "").lower())
            if is_efi:
                self.cmb_esp_part.addItem(label_for(p), dev)
        self.cmb_esp_part.blockSignals(False)

        idx_root = -1
        for i, p in enumerate(parts):
            if not p[3]:
                idx_root = i
                break
        if idx_root >= 0:
            self.cmb_root_part.setCurrentIndex(idx_root)

        if self.cmb_esp_part.count() > 0:
            self.cmb_esp_part.setCurrentIndex(0)

        self._update_mode_visibility()

    def _go_config(self):
        if not self.preflight:
            return
        self._refresh_disks()

        if self.preflight.uefi_detected:
            self.lbl_config_hint.setText("Tip: This machine booted in UEFI mode. Auto will install UEFI + systemd-boot.")
        else:
            self.lbl_config_hint.setText("Tip: This machine booted in BIOS/Legacy mode. Auto will install BIOS + GRUB.")

        self._update_mode_visibility()
        self.stack.setCurrentWidget(self.page_config)

    # ----------------------------
    # Personalize page
    # ----------------------------
    def _build_personalize(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Personalization + Packages"))

        box = QGroupBox("Carry these to the installed system")
        v = QVBoxLayout(box)

        self.chk_skel = QCheckBox("Copy my XFCE settings + appearance preset (/etc/skel)")
        self.chk_skel.setChecked(True)

        self.chk_copy_storm_walls = QCheckBox("Copy StormOS wallpapers pack into /usr/share/backgrounds/StormOS (if present)")
        self.chk_copy_storm_walls.setChecked(True)

        self.chk_patch_wall = QCheckBox(f"Force default wallpaper in skel to {DEFAULT_WALLPAPER_PATH}")
        self.chk_patch_wall.setChecked(True)

        self.chk_lightdm = QCheckBox("Set LightDM login background + theme + icons (best-effort)")
        self.chk_lightdm.setChecked(True)

        self.chk_migrate_localbin = QCheckBox("Migrate LIVE /usr/local/bin -> installed system /usr/local/bin (and ensure executable)")
        self.chk_migrate_localbin.setChecked(True)

        v.addWidget(self.chk_skel)
        v.addWidget(self.chk_copy_storm_walls)
        v.addWidget(self.chk_patch_wall)
        v.addWidget(self.chk_lightdm)
        v.addWidget(self.chk_migrate_localbin)

        lay.addWidget(box)

        pkgbox = QGroupBox("Programs / Packages")
        pv = QVBoxLayout(pkgbox)

        self.chk_pkgs_local = QCheckBox("Use local /etc/stormos/packages.txt (if present)")
        self.chk_pkgs_local.setChecked(True)

        self.chk_pkgs_github = QCheckBox("Use GitHub packages.x86_64 if local list is missing (recommended)")
        self.chk_pkgs_github.setChecked(True)

        self.chk_zst = QCheckBox("Install adw-gtk-theme-git .pkg.tar.zst from GitHub (required)")
        self.chk_zst.setChecked(True)

        self.chk_yay = QCheckBox("Install yay (AUR helper) (best-effort; if it fails install still completes)")
        self.chk_yay.setChecked(True)

        self.chk_autologin = QCheckBox("LightDM FAILSAFE: Enable autologin (bypass password prompt) — for testing")
        self.chk_autologin.setChecked(False)

        pv.addWidget(self.chk_pkgs_local)
        pv.addWidget(self.chk_pkgs_github)
        pv.addWidget(self.chk_zst)
        pv.addSpacing(8)
        pv.addWidget(self.chk_yay)
        pv.addSpacing(8)
        pv.addWidget(self.chk_autologin)

        lay.addWidget(pkgbox)

        self.lbl_personalize_status = QLabel("")
        self.lbl_personalize_status.setWordWrap(True)
        self.lbl_personalize_status.setStyleSheet("QLabel { color: #b8c2ff; }")
        lay.addWidget(self.lbl_personalize_status)

        row = QHBoxLayout()
        btn_back = QPushButton("← Back")
        btn_back.setMinimumHeight(40)
        btn_back.clicked.connect(lambda: self.stack.setCurrentWidget(self.page_config))
        btn_next = QPushButton("Next →")
        btn_next.setMinimumHeight(40)
        btn_next.setStyleSheet(
            "QPushButton { background: #2b77ff; border: 1px solid #6aa9ff; color: white; font-weight: 900; }"
            "QPushButton:hover { background: #3a86ff; }"
        )
        btn_next.clicked.connect(self._go_confirm)
        row.addWidget(btn_back)
        row.addStretch(1)
        row.addWidget(btn_next)
        lay.addLayout(row)

        return make_scroll_page(content)

    def _go_personalize(self):
        status = []
        status.append(f"/etc/skel: {'FOUND' if LIVE_SKEL.exists() else 'NOT FOUND'}")
        status.append(f"Live pack /usr/share/backgrounds/StormOS: {'FOUND' if Path('/usr/share/backgrounds/StormOS').exists() else 'NOT FOUND'}")
        status.append(f"/etc/stormos/packages.txt: {'FOUND' if LIVE_PKG_LIST.exists() else 'NOT FOUND'}")
        status.append("GitHub wallpaper + GitHub theme pkg: requires internet")
        status.append("multilib: enabled in live+target")
        status.append(wifi_status_line())
        self.lbl_personalize_status.setText("Detected: " + " | ".join(status))

        if not LIVE_SKEL.exists():
            self.chk_skel.setChecked(False)
            self.chk_skel.setEnabled(False)
        else:
            self.chk_skel.setEnabled(True)

        self.stack.setCurrentWidget(self.page_personalize)

    # ----------------------------
    # Confirm page (adapts to mode)
    # ----------------------------
    def _build_confirm(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Confirm (LAST CHANCE)"))

        self.banner = self._danger_banner("DANGER: Confirm your action.")
        lay.addWidget(self.banner)

        self.summary = QPlainTextEdit()
        self.summary.setReadOnly(True)
        self.summary.setMinimumHeight(220)
        lay.addWidget(self.summary, 1)

        self.chk_confirm_1 = QCheckBox("I understand the selected action may DESTROY data.")
        self.chk_confirm_2 = QCheckBox("I backed up everything important.")
        self.chk_confirm_3 = QCheckBox("I am selecting the correct disk/partitions and accept the consequences.")
        for c in (self.chk_confirm_1, self.chk_confirm_2, self.chk_confirm_3):
            c.setStyleSheet("QCheckBox { font-weight: 900; }")
            lay.addWidget(c)

        lay.addSpacing(8)
        self.lbl_type = QLabel("Type the required word to unlock INSTALL:")
        self.lbl_type.setStyleSheet("QLabel { color: #ffd7e1; font-weight: 800; }")
        lay.addWidget(self.lbl_type)

        self.ed_type = QLineEdit("")
        self.ed_type.setPlaceholderText("ERASE / FORMAT / INSTALL")
        # big input with red accent ring
        self.ed_type.setStyleSheet(
            "QLineEdit { font-size: 20px; padding: 12px; background: #101a34; "
            "border: 2px solid #ff3b6b; border-radius: 14px; color: #ffffff; }"
            "QLineEdit:focus { border: 2px solid #ff6b9a; }"
        )
        lay.addWidget(self.ed_type)

        row = QHBoxLayout()
        btn_back = QPushButton("← Back")
        btn_back.setMinimumHeight(44)
        btn_back.clicked.connect(lambda: self.stack.setCurrentWidget(self.page_personalize))

        self.btn_install = QPushButton("INSTALL")
        self.btn_install.setMinimumHeight(48)
        self.btn_install.setEnabled(False)
        # extra-danger big button
        self.btn_install.setStyleSheet(
            "QPushButton { background: #c1121f; color: white; font-weight: 900; font-size: 16px; "
            "border: 1px solid #ff3b6b; border-radius: 14px; padding: 12px 16px; }"
            "QPushButton:hover { background: #d01a28; }"
            "QPushButton:pressed { background: #a80f19; }"
            "QPushButton:disabled { background: #3a1017; border: 1px solid #4a1a22; color: #b58b93; }"
        )
        self.btn_install.clicked.connect(self._start_install)

        row.addWidget(btn_back)
        row.addStretch(1)
        row.addWidget(self.btn_install)
        lay.addLayout(row)

        def _force_upper(s: str):
            u = s.upper()
            if u != s:
                pos = self.ed_type.cursorPosition()
                self.ed_type.blockSignals(True)
                self.ed_type.setText(u)
                self.ed_type.setCursorPosition(pos)
                self.ed_type.blockSignals(False)
            self._validate_confirm()

        self.ed_type.textChanged.connect(_force_upper)
        self.chk_confirm_1.stateChanged.connect(self._validate_confirm)
        self.chk_confirm_2.stateChanged.connect(self._validate_confirm)
        self.chk_confirm_3.stateChanged.connect(self._validate_confirm)

        return make_scroll_page(content)

    def _required_confirm_word(self) -> str:
        install_mode = self.cmb_install_mode.currentText()
        eff_boot = effective_boot_mode(self.cmb_boot.currentText())
        if install_mode == MODE_ERASE:
            return "ERASE"
        fmt_root = self.chk_format_root.isChecked()
        fmt_efi = self.chk_format_esp.isChecked() if eff_boot == "UEFI" else False
        if fmt_root or fmt_efi:
            return "FORMAT"
        return "INSTALL"

    def _validate_confirm(self):
        ok_checks = self.chk_confirm_1.isChecked() and self.chk_confirm_2.isChecked() and self.chk_confirm_3.isChecked()
        required = self._required_confirm_word()
        ok_word = self.ed_type.text().strip().upper() == required
        self.btn_install.setEnabled(ok_checks and ok_word)

    def _build_plan(self) -> InstallPlan:
        disk = self.cmb_disk.currentData()
        if not disk:
            raise RuntimeError("No disk selected.")

        install_mode = self.cmb_install_mode.currentText()
        boot_choice = self.cmb_boot.currentText()
        fs_choice = self.cmb_fs.currentText()
        eff_boot = effective_boot_mode(boot_choice)

        root_part = ""
        esp_part = ""
        format_root = True
        format_esp = False

        if install_mode == MODE_EXISTING:
            root_part = self.cmb_root_part.currentData() or ""
            if not root_part:
                raise RuntimeError("Existing partitions mode: you must select a ROOT partition.")
            if eff_boot == "UEFI":
                esp_part = self.cmb_esp_part.currentData() or ""
                if not esp_part:
                    raise RuntimeError("Existing partitions mode (UEFI): you must select an EFI partition.")
            format_root = self.chk_format_root.isChecked()
            format_esp = self.chk_format_esp.isChecked() if eff_boot == "UEFI" else False

        hostname = sanitize_hostname(self.ed_hostname.text())
        user = sanitize_username(self.ed_user.text())
        pw = self.ed_pass.text()
        if len(pw) < 4:
            raise RuntimeError("Password too short (minimum 4 characters).")

        tz = (self.cmb_tz.currentText() or "").strip() or "UTC"
        loc = (self.cmb_locale.currentText() or "").strip() or "en_US"
        keymap = (self.cmb_keymap.currentText() or "").strip() or "us"

        set_root = self.chk_root.isChecked()
        rootpw = self.ed_rootpass.text() if set_root else ""

        return InstallPlan(
            install_mode=install_mode,
            disk=disk,
            boot_mode_choice=boot_choice,
            fs_choice=fs_choice,
            root_part=root_part,
            esp_part=esp_part,
            format_root=format_root,
            format_esp=format_esp,
            hostname=hostname,
            username=user,
            password=pw,
            timezone=tz,
            locale=loc,
            keymap=keymap,
            set_root_password=set_root,
            root_password=rootpw,
            do_skel=self.chk_skel.isChecked(),
            do_copy_stormos_wallpapers=self.chk_copy_storm_walls.isChecked(),
            do_lightdm=self.chk_lightdm.isChecked(),
            do_patch_xfce_wall=self.chk_patch_wall.isChecked(),
            do_migrate_usr_local_bin=self.chk_migrate_localbin.isChecked(),
            use_local_packages_txt=self.chk_pkgs_local.isChecked(),
            use_github_packages_list=self.chk_pkgs_github.isChecked(),
            install_github_zst_packages=self.chk_zst.isChecked(),
            enable_autologin=self.chk_autologin.isChecked(),
            default_theme_preferred="adw-gtk-dark",
            install_yay=self.chk_yay.isChecked(),
        )

    def _go_confirm(self):
        try:
            p = self._build_plan()
        except Exception as e:
            QMessageBox.critical(self, "Invalid settings", str(e))
            return

        mode = effective_boot_mode(p.boot_mode_choice)
        required_word = self._required_confirm_word()

        if p.install_mode == MODE_ERASE:
            self.banner.setText(
                "DANGER: This WILL ERASE the selected disk.\n"
                "There is NO undo.\n\n"
                "To enable INSTALL:\n"
                "• Check all confirmations\n"
                f"• Type {required_word}"
            )
            self.btn_install.setText("INSTALL (ERASE DISK)")
        else:
            if required_word == "FORMAT":
                self.banner.setText(
                    "WARNING: You selected existing partitions, but formatting is ENABLED.\n"
                    "Formatting DESTROYS data on the selected partition(s).\n\n"
                    "To enable INSTALL:\n"
                    "• Check all confirmations\n"
                    f"• Type {required_word}"
                )
                self.btn_install.setText("INSTALL (FORMAT PARTITIONS)")
            else:
                self.banner.setText(
                    "You selected existing partitions with NO formatting.\n"
                    "The installer will mount and install the OS, but will not wipe/format.\n\n"
                    "To enable INSTALL:\n"
                    "• Check all confirmations\n"
                    f"• Type {required_word}"
                )
                self.btn_install.setText("INSTALL (NO FORMAT)")

        fs = effective_fs(p.fs_choice)
        summary = []
        summary.append("INSTALL SUMMARY\n")
        summary.append(f"Install mode: {p.install_mode}")
        summary.append(f"Boot mode: {mode} (selection: {p.boot_mode_choice})")
        summary.append(f"Disk: {p.disk}")
        summary.append(f"Filesystem choice: {fs} (used only if formatting ROOT)")
        if p.install_mode == MODE_EXISTING:
            summary.append("")
            summary.append(f"ROOT: {p.root_part}")
            summary.append(f"Format ROOT: {'YES' if p.format_root else 'NO'}")
            if mode == "UEFI":
                summary.append(f"EFI: {p.esp_part}")
                summary.append(f"Format EFI: {'YES' if p.format_esp else 'NO'}")
        summary.append("")
        summary.append(f"Hostname: {p.hostname}")
        summary.append(f"User: {p.username}")
        summary.append(f"Timezone: {p.timezone}")
        summary.append(f"Locale: {p.locale}.UTF-8")
        summary.append(f"Keymap: {p.keymap}")
        summary.append("")
        summary.append(f"Required confirmation word: {required_word}")
        summary.append("")
        summary.append(f"Wi-Fi status: {wifi_status_line()}")
        summary.append("")
        summary.append(f"Saved installer log: {LOG_FILE}")

        self.summary.setPlainText("\n".join(summary))

        self.chk_confirm_1.setChecked(False)
        self.chk_confirm_2.setChecked(False)
        self.chk_confirm_3.setChecked(False)
        self.ed_type.setText("")
        self.btn_install.setEnabled(False)

        self.stack.setCurrentWidget(self.page_confirm)

    # ----------------------------
    # Install page
    # ----------------------------
    def _build_install(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Installing…"))

        self.prog = QProgressBar()
        self.prog.setRange(0, 100)
        lay.addWidget(self.prog)

        self.log = QPlainTextEdit()
        self.log.setReadOnly(True)
        self.log.setMinimumHeight(300)
        lay.addWidget(self.log, 1)

        self.btn_close = QPushButton("Close")
        self.btn_close.setMinimumHeight(40)
        self.btn_close.setEnabled(False)
        self.btn_close.clicked.connect(self.close)
        lay.addWidget(self.btn_close)

        return make_scroll_page(content)

    def _append_log(self, s: str):
        self.log.appendPlainText(s)
        sb = self.log.verticalScrollBar()
        sb.setValue(sb.maximum())

    def _start_install(self):
        install_mode = self.cmb_install_mode.currentText()
        required = self._required_confirm_word()
        if install_mode == MODE_ERASE:
            msg = "This will ERASE the selected disk and install StormOS.\n\nDo you want to continue?"
        elif required == "FORMAT":
            msg = "This will FORMAT selected partition(s) and install StormOS.\n\nDo you want to continue?"
        else:
            msg = "This will install StormOS onto the selected partitions WITHOUT formatting.\n\nDo you want to continue?"

        r = QMessageBox.warning(
            self,
            "LAST CHANCE",
            msg,
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        if r != QMessageBox.Yes:
            return

        try:
            plan = self._build_plan()
        except Exception as e:
            QMessageBox.critical(self, "Invalid settings", str(e))
            return

        self.stack.setCurrentWidget(self.page_install)
        self.prog.setValue(0)
        self.log.clear()
        self.btn_close.setEnabled(False)

        self.install_thread = InstallThread(plan)
        self.install_thread.log.connect(self._append_log)
        self.install_thread.progress.connect(self.prog.setValue)
        self.install_thread.ok.connect(self._install_ok)
        self.install_thread.fail.connect(self._install_fail)
        self.install_thread.start()

    # ----------------------------
    # Done page
    # ----------------------------
    def _build_done(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Done"))

        self.done_msg = QLabel("")
        self.done_msg.setWordWrap(True)
        self.done_msg.setStyleSheet("QLabel { color: #dbe3ff; }")
        lay.addWidget(self.done_msg)

        row = QHBoxLayout()
        btn_exit = QPushButton("Exit")
        btn_exit.setMinimumHeight(40)
        btn_exit.clicked.connect(self.close)

        btn_view_log = QPushButton("View Saved Log")
        btn_view_log.setMinimumHeight(40)
        btn_view_log.setStyleSheet(
            "QPushButton { background: #2b77ff; border: 1px solid #6aa9ff; color: white; font-weight: 900; }"
            "QPushButton:hover { background: #3a86ff; }"
        )
        btn_view_log.clicked.connect(self._view_saved_log)

        btn_reboot = QPushButton("Reboot Now")
        btn_reboot.setMinimumHeight(40)
        btn_reboot.setStyleSheet(
            "QPushButton { background: #19a974; border: 1px solid #34d399; color: #062016; font-weight: 900; }"
            "QPushButton:hover { background: #22c55e; }"
            "QPushButton:pressed { background: #16a34a; }"
        )
        btn_reboot.clicked.connect(self._reboot)

        row.addWidget(btn_exit)
        row.addWidget(btn_view_log)
        row.addStretch(1)
        row.addWidget(btn_reboot)
        lay.addLayout(row)

        return make_scroll_page(content)

    def _install_ok(self):
        self.btn_close.setEnabled(True)
        self.done_msg.setText(
            "Install finished successfully.\n\n"
            "Next:\n"
            "1) Reboot\n"
            "2) Remove the ISO\n"
            "3) Boot the installed system\n\n"
            f"Saved log:\n{LOG_FILE}\n"
        )
        self.stack.setCurrentWidget(self.page_done)

    def _install_fail(self, err: str):
        self.btn_close.setEnabled(True)
        self._append_log("\n!! INSTALL FAILED\n" + err)
        self.done_msg.setText(
            "Install failed.\n"
            "Scroll the log for the error, or click “View Saved Log”.\n\n"
            f"Saved log:\n{LOG_FILE}\n"
        )
        self.stack.setCurrentWidget(self.page_done)

    def _view_saved_log(self):
        path = str(LOG_FILE)
        if not Path(path).exists():
            QMessageBox.information(self, "Log not found", f"No saved log found at:\n{path}")
            return
        ok = QDesktopServices.openUrl(QUrl.fromLocalFile(path))
        if not ok:
            try:
                subprocess.run(["xdg-open", path], check=False)
            except Exception:
                QMessageBox.information(self, "Open failed", f"Couldn't open the log automatically.\nOpen it manually:\n{path}")

    def _reboot(self):
        try:
            subprocess.run(["sync"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            if cmd_ok("systemctl"):
                subprocess.run(["systemctl", "reboot"], check=False)
            else:
                subprocess.run(["reboot"], check=False)
        except Exception:
            pass

    # ----------------------------
    # Welcome info
    # ----------------------------
    def _go_welcome(self):
        env = []
        env.append(f"Root: {'YES' if is_root() else 'NO'}")
        env.append(f"UEFI detected: {'YES' if is_uefi() else 'NO'}")
        env.append(f"Internet: {'YES' if have_internet_fast() else 'NO/UNKNOWN'}")
        env.append(wifi_status_line())
        env.append(f"/etc/skel: {'FOUND' if LIVE_SKEL.exists() else 'NOT FOUND'}")
        env.append(f"Live StormOS wallpaper pack: {'FOUND' if Path('/usr/share/backgrounds/StormOS').exists() else 'NOT FOUND'}")
        env.append(f"packages.txt: {'FOUND' if LIVE_PKG_LIST.exists() else 'NOT FOUND'}")
        env.append(f"Saved log: {LOG_FILE}")
        self.lbl_env.setText(" | ".join(env))
        self.stack.setCurrentWidget(self.page_welcome)


def main():
    app = QApplication(sys.argv)
    app.setStyleSheet(MIDNIGHT_QSS)
    w = Wizard()
    w.show()
    sys.exit(app.exec_())


if __name__ == "__main__":
    main()
