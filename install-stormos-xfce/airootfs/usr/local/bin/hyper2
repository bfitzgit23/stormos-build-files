#!/usr/bin/env python3
"""
Tokyo Night Qt5 Panel Bar - Dark Night Edition with Integrated STILE Tiling
Complete Xfce4 panel replacement with enhanced dark night theme and built-in window tiling
Featuring subtle animations, night sky gradients, and improved visual effects
"""
import sys
import os
import time
import subprocess
import threading
import re
import json
import signal
import math
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict
from PyQt5.QtWidgets import (QApplication, QMainWindow, QWidget, QHBoxLayout, 
                            QVBoxLayout, QLabel, QPushButton, QMenu, QSystemTrayIcon,
                            QFrame, QToolButton, QStyle, QAction, QScrollArea,
                            QDialog, QSlider, QCheckBox, QComboBox, QGroupBox,
                            QFormLayout, QSpinBox, QColorDialog, QTabWidget,
                            QSystemTrayIcon, QSizePolicy, QListWidget, QListWidgetItem,
                            QLineEdit, QMessageBox, QInputDialog, QGridLayout)  # Added QGridLayout here
from PyQt5.QtCore import Qt, QTimer, QPoint, QSize, pyqtSignal, QThread, QSettings, QEvent, QPropertyAnimation, QEasingCurve, QObject, QRect
from PyQt5.QtGui import (QIcon, QFont, QPalette, QColor, QPainter, QLinearGradient, 
                        QFontDatabase, QPixmap, QPen, QWheelEvent, QBrush, QRadialGradient, QKeySequence, QCursor)
# Try to import QX11Info from the correct module
try:
    from PyQt5.QtX11Extras import QX11Info
    HAS_X11 = True
except ImportError:
    try:
        from PyQt5.QtGui import QX11Info
        HAS_X11 = True
    except ImportError:
        HAS_X11 = False
        print("Warning: QX11Info not available. Some X11-specific features may be disabled.")

# Enhanced Dark Night Color Palette
class TokyoNight:
    # Base colors - deeper, more night-like
    BACKGROUND = "#0d0f1a"  # Deeper dark blue-black
    FOREGROUND = "#c0caf5"
    # Content colors
    COMMENT = "#3a415e"  # Slightly lighter comment color
    SELECTION = "#1a2332"  # Darker selection
    # Ansi colors - adjusted for night theme
    BLACK = "#0a0b14"  # Almost pure black
    RED = "#f7768e"
    GREEN = "#9ece6a"
    YELLOW = "#e0af68"
    BLUE = "#5a7fc7"  # Slightly muted blue
    PURPLE = "#9b7fc7"  # Muted purple
    CYAN = "#5abfcf"  # Muted cyan
    WHITE = "#a9b1d6"
    # Bright colors - adjusted for night theme
    BRIGHT_BLACK = "#2a3146"  # Darker bright black
    BRIGHT_RED = "#f7768e"
    BRIGHT_GREEN = "#9ece6a"
    BRIGHT_YELLOW = "#e0af68"
    BRIGHT_BLUE = "#5a7fc7"  # Muted bright blue
    BRIGHT_PURPLE = "#9b7fc7"  # Muted bright purple
    BRIGHT_CYAN = "#5abfcf"  # Muted bright cyan
    BRIGHT_WHITE = "#c0caf5"
    # Additional accents - night-themed
    ORANGE = "#ff9e64"
    PINK = "#ff007c"
    TEAL = "#2ac3de"
    # Night sky gradient colors
    NIGHT_TOP = "#0a0b14"  # Deep space black
    NIGHT_BOTTOM = "#1a1b26"  # Tokyo night background
    NIGHT_HIGHLIGHT = "#1f2335"  # Subtle highlight
    # Moon and stars colors
    MOON_GLOW = "#e0e6ff"  # Soft moon glow
    STAR_COLOR = "#ffffff"  # White stars
    NEBULA = "#3a415e"  # Nebula clouds

@dataclass
class Application:
    name: str
    command: str
    icon: str = "üöÄ"
    args: str = ""  # Additional arguments for the command
    workspace: int = -1  # -1 means current workspace, 0+ means specific workspace

@dataclass
class Window:
    id: str
    desktop: int
    pid: int
    x: int
    y: int
    width: int
    height: int
    title: str
    class_name: str

class IntegratedTiler(QObject):
    """Integrated window tiler - no external dependency"""
    def __init__(self):
        super().__init__()
        self.current_layout = 0
        self.layouts = ["tall", "wide", "grid", "monocle", "floating"]
        self.master_window = None
        self.gap = 15
        self.inner_gap = 8
        self.is_active = False
        self.auto_tile = True
        self.window_history = []
        self.managed_windows = set()
        self.ignore_classes = ["dock", "panel", "desktop", "notification", "toolbar", "xfce4-panel"]



    def setup_window_hooks(self):
        """Setup window event monitoring for automatic tiling"""
        try:
            # Use wmctrl to monitor window events
            subprocess.Popen([
                "bash", "-c", 
                "while true; do wmctrl -l; sleep 1; done"
            ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"Window hook setup failed: {e}")


        
    def run_cmd(self, cmd: List[str]) -> str:
        """Run shell command and return output"""
        try:
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            return result.stdout.strip()
        except:
            return ""


    def get_windows(self) -> List[Window]:
        """Alternative method using xprop to get windows."""
        windows = []
        try:
            # Get current desktop
            current_desktop_result = subprocess.run(
                ["xdotool", "get_desktop"], 
                capture_output=True, text=True, timeout=2
            )
            current_desktop = current_desktop_result.stdout.strip() if current_desktop_result.returncode == 0 else "0"
            print(f"DEBUG: Current desktop: {current_desktop}")

            # Get window IDs using xdotool - search for all visible windows on current desktop
            window_ids_result = subprocess.run(
                ["xdotool", "search", "--onlyvisible", "--desktop", current_desktop, "."],
                capture_output=True, text=True, timeout=5
            )
            
            if window_ids_result.returncode != 0:
                print("DEBUG: xdotool search failed")
                return windows

            window_ids = window_ids_result.stdout.strip().split()
            print(f"DEBUG: Found {len(window_ids)} window IDs: {window_ids}")
            
            if not window_ids:
                print("DEBUG: No window IDs found")
                return windows

            for win_id in window_ids:
                if not win_id:
                    continue
                    
                try:
                    print(f"DEBUG: Processing window ID: {win_id}")
                    
                    # Get window geometry using xwininfo
                    geometry_result = subprocess.run(
                        ["xwininfo", "-id", win_id],
                        capture_output=True, text=True, timeout=2
                    )
                    
                    if geometry_result.returncode != 0:
                        print(f"DEBUG: xwininfo failed for window {win_id}")
                        continue
                    
                    # Parse geometry from xwininfo output
                    geometry_output = geometry_result.stdout
                    width = 0
                    height = 0
                    x = 0
                    y = 0
                    
                    for line in geometry_output.splitlines():
                        if "Width:" in line:
                            width = int(line.split(":")[1].strip())
                        elif "Height:" in line:
                            height = int(line.split(":")[1].strip())
                        elif "Absolute upper-left X:" in line:
                            x = int(line.split(":")[1].strip())
                        elif "Absolute upper-left Y:" in line:
                            y = int(line.split(":")[1].strip())
                    
                    print(f"DEBUG: Window {win_id} geometry: {x},{y} {width}x{height}")
                    
                    # Skip if geometry is invalid
                    if width <= 0 or height <= 0:
                        print(f"DEBUG: Skipping window {win_id} - invalid geometry")
                        continue
                    
                    # Get window title
                    title_result = subprocess.run(
                        ["xdotool", "getwindowname", win_id],
                        capture_output=True, text=True, timeout=2
                    )
                    title = title_result.stdout.strip() if title_result.returncode == 0 else ""
                    print(f"DEBUG: Window {win_id} title: '{title}'")
                    
                    # Skip if no title
                    if not title.strip():
                        print(f"DEBUG: Skipping window {win_id} - no title")
                        continue
                    
                    # Get window class using xprop
                    class_result = subprocess.run(
                        ["xprop", "-id", win_id, "WM_CLASS"],
                        capture_output=True, text=True, timeout=2
                    )
                    class_name = ""
                    if class_result.returncode == 0:
                        # WM_CLASS can return multiple values, we take the first one
                        class_match = re.search(r'WM_CLASS\(\w+\) = "([^"]*)"', class_result.stdout)
                        if class_match:
                            class_name = class_match.group(1)
                        else:
                            # Alternative pattern matching
                            class_match = re.search(r'= "([^"]*)"', class_result.stdout)
                            if class_match:
                                class_name = class_match.group(1)
                    
                    print(f"DEBUG: Window {win_id} class: '{class_name}'")
                    
                    # Skip system windows
                    if any(ignore in class_name.lower() for ignore in self.ignore_classes):
                        print(f"DEBUG: Skipping window {win_id} - system window class '{class_name}'")
                        continue
                    
                    # Skip windows that are too small (like tray icons)
                    if width < 50 or height < 50:
                        print(f"DEBUG: Skipping window {win_id} - too small ({width}x{height})")
                        continue
                    
                    # Skip windows with obviously system-like titles
                    skip_titles = ["desktop", "panel", "dock", "tray"]
                    if any(skip in title.lower() for skip in skip_titles):
                        print(f"DEBUG: Skipping window {win_id} - system title")
                        continue
                    
                    # Get PID if possible
                    pid_result = subprocess.run(
                        ["xdotool", "getwindowpid", win_id],
                        capture_output=True, text=True, timeout=2
                    )
                    pid = int(pid_result.stdout.strip()) if pid_result.returncode == 0 else 0
                    
                    # All checks passed - add window
                    window = Window(win_id, int(current_desktop), pid, x, y, width, height, title, class_name)
                    windows.append(window)
                    print(f"‚úÖ ADDED WINDOW: '{title}' ({class_name}) {width}x{height}")
                    
                except Exception as e:
                    print(f"DEBUG: Error processing window {win_id}: {e}")
                    continue
                    
        except Exception as e:
            print(f"ERROR in get_windows: {e}")
        
        print(f"DEBUG: get_windows returning {len(windows)} windows")
        return windows

    def force_apply_current_layout(self) -> bool:
        """
        Apply the current layout without checking if tiling is active or auto-tile is enabled.
        This method is intended to be called externally to force a layout application.
        
        Returns:
            bool: True if layout was applied successfully, False otherwise.
        """
        print("ü™ü Force applying layout regardless of active/auto-tile status")
        windows = self.get_windows()
        
        try:
            screen = self.get_screen_geometry()
        except Exception as e:
            print(f"ERROR: Failed to get screen geometry: {e}")
            return False
            
        if not windows:
            print("No windows found to tile.")
            return True  # Consider this a success since there's nothing to tile

        layout_name = self.layouts[self.current_layout]
        print(f"Applying {layout_name.upper()} layout to {len(windows)} windows.")

        # Unmaximize all windows first
        for window in windows:
            try:
                self.unmaximize_window(window.id)
            except Exception as e:
                print(f"ERROR: Failed to unmaximize window {window.id}: {e}")

        # Apply the specific layout logic
        try:
            if layout_name == "tall":
                self.tile_tall(windows, screen)
            elif layout_name == "wide":
                self.tile_wide(windows, screen)
            elif layout_name == "grid":
                self.tile_grid(windows, screen)
            elif layout_name == "monocle":
                self.tile_monocle(windows, screen)
            elif layout_name == "floating":
                self.tile_floating(windows, screen)
        except Exception as e:
            print(f"ERROR: Failed to apply {layout_name} layout: {e}")
            return False

        # Focus the master window if one is set
        if self.master_window:
            try:
                self.focus_window(self.master_window)
            except Exception as e:
                print(f"ERROR: Failed to focus master window {self.master_window}: {e}")
        
        return True

    def get_active_window(self) -> Optional[str]:
        """Get currently focused window"""
        return self.run_cmd(["xdotool", "getactivewindow"])

    def get_screen_geometry(self) -> Tuple[int, int, int, int]:
        """Get accurate screen geometry with multiple fallback methods"""
        try:
            # Method 1: Use xrandr for accurate screen info
            result = subprocess.run(
                ["xrandr", "--query"],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    if " connected " in line and "primary" in line:
                        # Example: "eDP-1 connected primary 1920x1080+0+0"
                        import re
                        match = re.search(r'(\d+)x(\d+)\+(\d+)\+(\d+)', line)
                        if match:
                            w, h, x, y = map(int, match.groups())
                            return (x, y, w, h)
            
            # Method 2: Use xdotool with current screen
            result = subprocess.run(
                ["xdotool", "getdisplaygeometry"],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                w, h = map(int, result.stdout.split())
                return (0, 0, w, h)
                
            # Method 3: Use root window properties
            result = subprocess.run(
                ["xwininfo", "-root"],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                width, height = 0, 0
                for line in result.stdout.splitlines():
                    if "Width:" in line:
                        width = int(line.split(":")[1].strip())
                    elif "Height:" in line:
                        height = int(line.split(":")[1].strip())
                if width > 0 and height > 0:
                    return (0, 0, width, height)
                    
        except Exception as e:
            print(f"Screen geometry error: {e}")
        
        # Final fallback
        return (0, 0, 1920, 1080)

    def unmaximize_window(self, win_id: str):
        """Properly unmaximize a window"""
        self.run_cmd(["wmctrl", "-ir", win_id, "-b", "remove,maximized_vert,maximized_horz"])
        time.sleep(0.01)

    def focus_window(self, win_id: str):
        """Focus a window"""
        self.run_cmd(["wmctrl", "-ia", win_id])

    def set_window_geometry(self, win_id: str, x: int, y: int, w: int, h: int):
        """Set window geometry with proper gap handling and validation"""
        try:
            # Ensure minimum size
            w = max(100, w)
            h = max(100, h)
            
            # Get screen geometry to validate bounds
            screen_x, screen_y, screen_w, screen_h = self.get_screen_geometry()
            
            # Ensure window stays within screen bounds
            x = max(screen_x, x)
            y = max(screen_y, y)
            w = min(w, screen_w - x)
            h = min(h, screen_h - y)
            
            # First unmaximize
            self.unmaximize_window(win_id)
            
            # Use multiple methods to set geometry for better compatibility
            methods = [
                # Method 1: wmctrl (primary)
                ["wmctrl", "-ir", win_id, "-e", f"0,{x},{y},{w},{h}"],
                # Method 2: xdotool (fallback)
                ["xdotool", "windowmove", win_id, str(x), str(y)],
                ["xdotool", "windowsize", win_id, str(w), str(h)]
            ]
            
            for method in methods:
                try:
                    result = subprocess.run(method, capture_output=True, text=True, timeout=1)
                    if result.returncode == 0:
                        break
                except:
                    continue
                    
            # Small delay to let window manager process the change
            time.sleep(0.05)
            
        except Exception as e:
            print(f"Error setting geometry for {win_id}: {e}")

    def tile_tall(self, windows: List[Window], screen: Tuple[int, int, int, int]):
        """Improved tall layout with better gap handling"""
        if not windows:
            return
            
        screen_x, screen_y, screen_w, screen_h = screen
        gap = self.gap
        inner_gap = self.inner_gap
        
        print(f"üìê Tiling {len(windows)} windows in tall layout")
        print(f"üìè Screen: {screen_w}x{screen_h}, Gaps: {gap}/{inner_gap}")
        
        # Convert to IDs for master tracking
        win_ids = [w.id for w in windows]
        
        # Set master if needed
        if not self.master_window or self.master_window not in win_ids:
            self.master_window = win_ids[0]
        
        # Calculate usable area (subtract outer gaps from all sides)
        usable_width = screen_w - (gap * 2)
        usable_height = screen_h - (gap * 2)
        
        # Master gets 60% width, stack gets the rest minus inner gap
        master_width = int(usable_width * 0.6)
        stack_width = usable_width - master_width - inner_gap
        
        print(f"üìê Master: {master_width}px, Stack: {stack_width}px")
        
        # Position master window
        if self.master_window in win_ids:
            master_x = screen_x + gap
            master_y = screen_y + gap
            master_height = usable_height
            
            print(f"üéØ Positioning master: {master_x},{master_y} {master_width}x{master_height}")
            self.set_window_geometry(self.master_window, master_x, master_y, master_width, master_height)
        
        # Position stack windows
        stack_windows = [w for w in windows if w.id != self.master_window]
        if stack_windows:
            stack_count = len(stack_windows)
            total_inner_gaps = inner_gap * (stack_count - 1)
            available_stack_height = usable_height - total_inner_gaps
            base_stack_height = available_stack_height // stack_count
            
            for i, window in enumerate(stack_windows):
                stack_x = screen_x + gap + master_width + inner_gap
                stack_y = screen_y + gap + (i * (base_stack_height + inner_gap))
                
                # Calculate height for this stack window
                if i == stack_count - 1:
                    # Last window gets remaining height
                    used_height = i * (base_stack_height + inner_gap)
                    stack_height = usable_height - used_height
                else:
                    stack_height = base_stack_height
                
                print(f"üìê Positioning stack {i+1}: {stack_x},{stack_y} {stack_width}x{stack_height}")
                self.set_window_geometry(window.id, stack_x, stack_y, stack_width, stack_height)

    def tile_wide(self, windows: List[Window], screen: Tuple[int, int, int, int]):
        """Wide layout - master on top, stack on bottom"""
        if not windows:
            return
            
        screen_x, screen_y, screen_w, screen_h = screen
        gap = self.gap
        inner_gap = self.inner_gap
        
        win_ids = [w.id for w in windows]
        
        if not self.master_window or self.master_window not in win_ids:
            self.master_window = win_ids[0]
        
        # Calculate areas with gaps
        usable_width = screen_w - (gap * 2)
        usable_height = screen_h - (gap * 2)
        
        master_height = int(usable_height * 0.6)
        stack_height = usable_height - master_height - inner_gap
        
        # Position master window
        if self.master_window in win_ids:
            master_x = screen_x + gap
            master_y = screen_y + gap
            self.set_window_geometry(self.master_window, master_x, master_y, usable_width, master_height)
        
        # Position stack windows
        stack_windows = [w for w in windows if w.id != self.master_window]
        if stack_windows:
            stack_width = (usable_width - (inner_gap * (len(stack_windows) - 1))) // len(stack_windows)
            
            for i, window in enumerate(stack_windows):
                stack_x = screen_x + gap + (i * (stack_width + inner_gap))
                stack_y = screen_y + gap + master_height + inner_gap
                
                # Last window gets remaining width
                if i == len(stack_windows) - 1:
                    remaining_width = usable_width - (stack_x - (screen_x + gap))
                    self.set_window_geometry(window.id, stack_x, stack_y, remaining_width, stack_height)
                else:
                    self.set_window_geometry(window.id, stack_x, stack_y, stack_width, stack_height)




    def refresh_window_positions(self):
        """Force refresh all window positions to correct any misalignment"""
        windows = self.get_windows()
        screen = self.get_screen_geometry()
        
        if not windows:
            return
            
        layout_name = self.layouts[self.current_layout]
        print(f"üîÑ Refreshing {len(windows)} windows in {layout_name} layout")
        
        # Re-apply the current layout
        if layout_name == "tall":
            self.tile_tall(windows, screen)
        elif layout_name == "wide":
            self.tile_wide(windows, screen)
        elif layout_name == "grid":
            self.tile_grid(windows, screen)
        elif layout_name == "monocle":
            self.tile_monocle(windows, screen)

    def correct_window_alignment(self, win_id: str):
        """Correct alignment for a specific window"""
        try:
            # Get current window geometry
            result = subprocess.run(
                ["xwininfo", "-id", win_id],
                capture_output=True, text=True, timeout=2
            )
            
            if result.returncode == 0:
                current_x, current_y, current_w, current_h = 0, 0, 0, 0
                for line in result.stdout.splitlines():
                    if "Absolute upper-left X:" in line:
                        current_x = int(line.split(":")[1].strip())
                    elif "Absolute upper-left Y:" in line:
                        current_y = int(line.split(":")[1].strip())
                    elif "Width:" in line:
                        current_w = int(line.split(":")[1].strip())
                    elif "Height:" in line:
                        current_h = int(line.split(":")[1].strip())
                
                print(f"üîß Correcting alignment for window {win_id}")
                print(f"üìê Current: {current_x},{current_y} {current_w}x{current_h}")
                
                # Re-apply the same geometry to force correction
                self.set_window_geometry(win_id, current_x, current_y, current_w, current_h)
                
        except Exception as e:
            print(f"Alignment correction failed: {e}")











    def tile_grid(self, windows: List[Window], screen: Tuple[int, int, int, int]):
        """Improved grid layout with better spacing"""
        if not windows:
            return
            
        screen_x, screen_y, screen_w, screen_h = screen
        gap = self.gap
        inner_gap = self.inner_gap
        
        n = len(windows)
        print(f"üìê Tiling {n} windows in grid layout")
        
        # Calculate optimal grid dimensions
        if n <= 1:
            cols = 1
            rows = 1
        elif n <= 2:
            cols = 2
            rows = 1
        elif n <= 4:
            cols = 2
            rows = 2
        elif n <= 6:
            cols = 3
            rows = 2
        elif n <= 9:
            cols = 3
            rows = 3
        else:
            cols = int(n ** 0.5)
            rows = (n + cols - 1) // cols
        
        print(f"üìê Grid: {cols}x{rows}")
        
        # Calculate usable area
        usable_width = screen_w - (gap * 2)
        usable_height = screen_h - (gap * 2)
        
        # Calculate cell size with gaps
        total_horizontal_gaps = inner_gap * (cols - 1)
        total_vertical_gaps = inner_gap * (rows - 1)
        
        cell_width = (usable_width - total_horizontal_gaps) // cols
        cell_height = (usable_height - total_vertical_gaps) // rows
        
        print(f"üìê Cell size: {cell_width}x{cell_height}")
        
        for i, window in enumerate(windows):
            row = i // cols
            col = i % cols
            
            x = screen_x + gap + (col * (cell_width + inner_gap))
            y = screen_y + gap + (row * (cell_height + inner_gap))
            
            # Handle last column/row to use remaining space
            actual_width = cell_width
            actual_height = cell_height
            
            if col == cols - 1:
                remaining_width = usable_width - (x - (screen_x + gap))
                actual_width = max(100, remaining_width)
            if row == rows - 1:
                remaining_height = usable_height - (y - (screen_y + gap))
                actual_height = max(100, remaining_height)
            
            print(f"üìê Grid cell {i+1} ({row},{col}): {x},{y} {actual_width}x{actual_height}")
            self.set_window_geometry(window.id, x, y, actual_width, actual_height)

    def tile_monocle(self, windows: List[Window], screen: Tuple[int, int, int, int]):
        """Monocle layout - only master visible, others minimized"""
        if not windows:
            return
            
        screen_x, screen_y, screen_w, screen_h = screen
        gap = self.gap
        win_ids = [w.id for w in windows]
        
        if not self.master_window or self.master_window not in win_ids:
            self.master_window = win_ids[0]
        
        # Show and position master window
        if self.master_window in win_ids:
            self.run_cmd(["wmctrl", "-ir", self.master_window, "-b", "remove,hidden"])
            self.set_window_geometry(
                self.master_window,
                screen_x + gap,
                screen_y + gap,
                screen_w - (gap * 2),
                screen_h - (gap * 2)
            )
        
        # Hide other windows
        for window in windows:
            if window.id != self.master_window:
                self.run_cmd(["wmctrl", "-ir", window.id, "-b", "add,hidden"])

    def tile_floating(self, windows: List[Window], screen: Tuple[int, int, int, int]):
        """Floating layout - restore windows to their previous positions"""
        # For floating layout, we don't tile - windows stay where they are
        # Just ensure they're not maximized
        for window in windows:
            self.unmaximize_window(window.id)

    def apply_layout(self):
        """Apply current layout to all windows"""
        if not self.is_active:
            return
            
        windows = self.get_windows()
        screen = self.get_screen_geometry()
        
        if not windows:
            return
            
        layout_name = self.layouts[self.current_layout]
        print(f"ü™ü Auto-tiling {len(windows)} windows | üìê {layout_name.upper()} layout")
        
        # Unmaximize all windows first
        for window in windows:
            self.unmaximize_window(window.id)
        
        if layout_name == "tall":
            self.tile_tall(windows, screen)
        elif layout_name == "wide":
            self.tile_wide(windows, screen)
        elif layout_name == "grid":
            self.tile_grid(windows, screen)
        elif layout_name == "monocle":
            self.tile_monocle(windows, screen)
        elif layout_name == "floating":
            self.tile_floating(windows, screen)
        
        # Focus master
        if self.master_window:
            self.focus_window(self.master_window)

    def cycle_layout(self):
        """Cycle to next layout"""
        self.current_layout = (self.current_layout + 1) % len(self.layouts)
        layout_name = self.layouts[self.current_layout]
        print(f"üîÑ Switching to {layout_name.upper()} layout")
        self.apply_layout()

    def set_master(self):
        """Set currently focused window as master"""
        active_win = self.get_active_window()
        windows = self.get_windows()
        win_ids = [w.id for w in windows]
        
        if active_win and active_win in win_ids:
            self.master_window = active_win
            print(f"üéØ Master set: {active_win}")
            self.apply_layout()

    def toggle_auto_tile(self):
        """Toggle auto-tiling on/off"""
        self.auto_tile = not self.auto_tile
        status = "ON" if self.auto_tile else "OFF"
        print(f"ü§ñ Auto-tiling {status}")
        if self.auto_tile:
            self.apply_layout()

    def set_layout(self, layout_name):
        """Set specific layout"""
        if layout_name in self.layouts:
            self.current_layout = self.layouts.index(layout_name)
            print(f"üìê Setting layout to {layout_name.upper()}")
            self.apply_layout()

class TilingControlWidget(QWidget):
    """Widget for integrated STILE window tiling control"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.tiler = IntegratedTiler()
        self.setup_ui()
        # Update display immediately
        self.update_display()

    def setup_ui(self):
        """Setup the tiling control UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        
        # Tiling button (clickable to toggle tiling)
        self.tiling_button = QPushButton("‚äû")  # Tiling icon
        self.tiling_button.setFixedSize(32, 32)
        self.tiling_button.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        self.tiling_button.setCursor(Qt.PointingHandCursor)
        self.tiling_button.clicked.connect(self.toggle_tiling)
        self.tiling_button.setContextMenuPolicy(Qt.CustomContextMenu)
        self.tiling_button.customContextMenuRequested.connect(self.show_tiling_menu)
        layout.addWidget(self.tiling_button)
        
        # Layout indicator
        self.layout_label = QLabel("TALL")
        self.layout_label.setStyleSheet(f"""
            padding: 4px 8px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 9pt;
            color: {TokyoNight.FOREGROUND};
        """)
        layout.addWidget(self.layout_label)
        
        # Start monitoring timer
        self.monitor_timer = QTimer()
        self.monitor_timer.timeout.connect(self.monitor_windows)
        self.monitor_timer.start(1000)  # Check every second





    def refresh_layout(self):
        """Refresh the current layout to fix alignment issues"""
        print("üîÑ Refreshing layout to fix alignment")
        self.tiler.refresh_window_positions()
        self.update_display()

    def correct_alignment(self):
        """Correct alignment for all windows"""
        print("üîß Correcting window alignment")
        windows = self.tiler.get_windows()
        for window in windows:
            self.tiler.correct_window_alignment(window.id)
        self.update_display()











    def force_apply_layout(self):
        """Force apply the current layout regardless of tiler's active/auto-tile status."""
        print("üîÑ Force applying tiling layout (from TilingControlWidget)")
        # Call the tiler's specific force method
        self.tiler.force_apply_current_layout()
        # Update the display in the control widget
        self.update_display()


    def monitor_windows(self):
        """Monitor windows and apply tiling if needed"""
        if self.tiler.is_active and self.tiler.auto_tile:
            # Get current windows
            current_windows = self.tiler.get_windows()
            current_ids = {w.id for w in current_windows}
            
            # Check if window state changed
            if (not hasattr(self, 'last_window_ids') or 
                self.last_window_ids != current_ids):
                
                # Apply layout if windows changed
                if current_windows:
                    self.tiler.apply_layout()
                
                # Update tracking
                self.last_window_ids = current_ids
        
        self.update_display()

    def update_display(self):
        """Update the display based on tiler status"""
        if self.tiler.is_active:
            if self.tiler.auto_tile:
                color = TokyoNight.GREEN
                status_text = "ON"
            else:
                color = TokyoNight.YELLOW
                status_text = "PAUSED"
            self.tiling_button.setText(f"<font color='{color}'>‚äû</font>")
            layout_name = self.tiler.layouts[self.tiler.current_layout].upper()
            self.layout_label.setText(f"<font color='{color}'>{layout_name}</font>")
            self.layout_label.setVisible(True)
            self.tiling_button.setToolTip(f"‚äû Tiling {status_text}\nLayout: {layout_name}\nLeft click: Toggle\nRight click: Options")
        else:
            self.tiling_button.setText(f"<font color='{TokyoNight.RED}'>‚äû</font>")
            self.layout_label.setVisible(False)
            self.tiling_button.setToolTip("‚äû Tiling OFF\nLeft click: Enable tiling\nRight click: Options")

    def toggle_tiling(self):
        """Toggle tiling on/off"""
        if self.tiler.is_active:
            self.tiler.is_active = False
            print("üõë Tiling disabled")
        else:
            self.tiler.is_active = True
            self.tiler.auto_tile = True
            print("üöÄ Tiling enabled")
            self.tiler.apply_layout()
        self.update_display()

    def cycle_layout(self):
        """Cycle to next layout"""
        self.tiler.cycle_layout()
        self.update_display()

    def set_layout(self, layout_name):
        """Set specific layout"""
        self.tiler.set_layout(layout_name)
        self.update_display()

    def set_master(self):
        """Set currently focused window as master"""
        self.tiler.set_master()
        self.update_display()

    def apply_layout(self):
        """Apply the current tiling layout"""
        self.tiler.apply_layout()
        self.update_display()

    def show_tiling_menu(self, position):
        """Show context menu for tiling options"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        
        # Status info
        status_text = "ON" if self.tiler.is_active else "OFF"
        status_color = TokyoNight.GREEN if self.tiler.is_active else TokyoNight.RED
        status_action = QAction(f"Status: {status_text}", self)
        status_action.setEnabled(False)  # Make it non-clickable
        menu.addAction(status_action)
        menu.addSeparator()
        
        # Toggle tiling
        toggle_action = QAction("‚äû Toggle Tiling", self)
        toggle_action.triggered.connect(self.toggle_tiling)
        menu.addAction(toggle_action)
        
        if self.tiler.is_active:
            # Auto-tile toggle
            auto_action = QAction("ü§ñ Auto-tile", self)
            auto_action.setCheckable(True)
            auto_action.setChecked(self.tiler.auto_tile)
            auto_action.triggered.connect(self.toggle_auto_tile)
            menu.addAction(auto_action)
            
            # Layout options
            menu.addSeparator()
            layout_menu = QMenu("üìê Layout", self)
            layout_menu.setStyleSheet(menu.styleSheet())
            
            layouts = ["tall", "wide", "grid", "monocle", "floating"]
            for layout in layouts:
                action = QAction(layout.capitalize(), self)
                action.setCheckable(True)
                action.setChecked(self.tiler.layouts[self.tiler.current_layout] == layout)
                action.triggered.connect(lambda checked, l=layout: self.set_layout(l))
                layout_menu.addAction(action)
            
            menu.addMenu(layout_menu)
            
            # Cycle layout
            cycle_action = QAction("üîÑ Cycle Layout", self)
            cycle_action.triggered.connect(self.cycle_layout)
            menu.addAction(cycle_action)
            
            # Set master
            master_action = QAction("üéØ Set Master", self)
            master_action.triggered.connect(self.set_master)
            menu.addAction(master_action)
        
        menu.exec_(self.tiling_button.mapToGlobal(position))

    def toggle_auto_tile(self):
        """Toggle auto-tiling"""
        self.tiler.toggle_auto_tile()
        self.update_display()

class GlobalKeyHandler(QObject):
    """Global key handler for volume keys"""
    def __init__(self, volume_widget):
        super().__init__()
        self.volume_widget = volume_widget
        print("Global key handler installed - volume keys may not work in all environments")

    def handle_volume_up(self):
        """Handle volume up"""
        print("Volume up key pressed")
        new_volume = min(100, self.volume_widget.current_volume + 5)
        self.volume_widget.set_volume(new_volume)

    def handle_volume_down(self):
        """Handle volume down"""
        print("Volume down key pressed")
        new_volume = max(0, self.volume_widget.current_volume - 5)
        self.volume_widget.set_volume(new_volume)

    def handle_volume_mute(self):
        """Handle volume mute"""
        print("Volume mute key pressed")
        self.volume_widget.toggle_mute()

class NightSkyWidget(QWidget):
    """Widget with animated night sky background"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.stars = []
        self.animation_timer = QTimer()
        self.animation_timer.timeout.connect(self.update_stars)
        self.animation_timer.start(100)  # Update every 100ms
        self.generate_stars()

    def generate_stars(self):
        """Generate random stars for the night sky"""
        import random
        width = self.width() if self.width() > 0 else 1920
        height = self.height() if self.height() > 0 else 40
        # Create stars with varying sizes and brightness
        for _ in range(50):  # Create 50 stars
            x = random.randint(0, width)
            y = random.randint(0, height)
            size = random.uniform(0.5, 2.0)
            brightness = random.uniform(0.3, 1.0)
            twinkle_speed = random.uniform(0.01, 0.05)
            self.stars.append({
                'x': x, 'y': y, 'size': size, 
                'brightness': brightness, 
                'twinkle_speed': twinkle_speed,
                'phase': random.uniform(0, 2 * 3.14159)  # Random phase
            })

    def update_stars(self):
        """Update star brightness for twinkling effect"""
        import math
        for star in self.stars:
            star['phase'] += star['twinkle_speed']
            star['current_brightness'] = star['brightness'] * (0.5 + 0.5 * math.sin(star['phase']))
        self.update()

    def paintEvent(self, event):
        """Paint the night sky with stars"""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        # Create night sky gradient
        gradient = QLinearGradient(0, 0, 0, self.height())
        gradient.setColorAt(0, QColor(TokyoNight.NIGHT_TOP))
        gradient.setColorAt(0.7, QColor(TokyoNight.NIGHT_BOTTOM))
        gradient.setColorAt(1, QColor(TokyoNight.NIGHT_HIGHLIGHT))
        painter.fillRect(self.rect(), gradient)
        # Draw stars
        for star in self.stars:
            color = QColor(TokyoNight.STAR_COLOR)
            color.setAlphaF(star.get('current_brightness', star['brightness']))
            painter.setPen(QPen(color, star['size']))
            painter.drawPoint(star['x'], star['y'])
        # Draw nebula clouds
        nebula_brush = QBrush(QColor(TokyoNight.NEBULA))
        nebula_brush.setStyle(Qt.Dense6Pattern)
        painter.setBrush(nebula_brush)
        painter.setPen(Qt.NoPen)
        painter.setOpacity(0.1)
        painter.drawEllipse(100, 10, 200, 30)
        painter.drawEllipse(500, 5, 150, 20)
        painter.drawEllipse(900, 15, 180, 25)

class WirelessNetworkDialog(QDialog):
    """Dialog for managing wireless network connections"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()
        self.scan_networks()

    def setup_ui(self):
        self.setWindowTitle("Wireless Networks")
        self.setFixedSize(500, 600)
        self.setStyleSheet(f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QListWidget {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 4px;
                padding: 5px;
            }}
            QListWidget::item {{
                padding: 8px;
                border-radius: 3px;
            }}
            QListWidget::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
            QLabel {{
                color: {TokyoNight.FOREGROUND};
            }}
            QLineEdit {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                padding: 5px;
                border-radius: 3px;
            }}
            QCheckBox {{
                color: {TokyoNight.FOREGROUND};
            }}
            QGroupBox {{
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                background: {TokyoNight.NIGHT_BOTTOM}80;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }}
        """)
        layout = QVBoxLayout()
        # Title
        title = QLabel("Wireless Networks")
        title.setStyleSheet(f"font-size: 14pt; font-weight: bold; color: {TokyoNight.CYAN};")
        layout.addWidget(title)
        # Network list
        self.network_list = QListWidget()
        self.network_list.itemDoubleClicked.connect(self.connect_to_network)
        layout.addWidget(self.network_list)
        # Buttons
        button_layout = QHBoxLayout()
        self.refresh_btn = QPushButton("Û∞ëê Refresh")
        self.refresh_btn.clicked.connect(self.scan_networks)
        button_layout.addWidget(self.refresh_btn)
        self.connect_btn = QPushButton("Û∞ñ© Connect")
        self.connect_btn.clicked.connect(self.connect_to_selected)
        button_layout.addWidget(self.connect_btn)
        self.disconnect_btn = QPushButton("Û∞ñ™ Disconnect")
        self.disconnect_btn.clicked.connect(self.disconnect_current)
        button_layout.addWidget(self.disconnect_btn)
        button_layout.addStretch()
        self.close_btn = QPushButton("Close")
        self.close_btn.clicked.connect(self.close)
        button_layout.addWidget(self.close_btn)
        layout.addLayout(button_layout)
        # Connection details section
        self.details_group = QGroupBox("Connection Details")
        details_layout = QFormLayout()
        self.ssid_label = QLabel("--")
        self.signal_label = QLabel("--")
        self.security_label = QLabel("--")
        self.status_label = QLabel("--")
        details_layout.addRow("SSID:", self.ssid_label)
        details_layout.addRow("Signal:", self.signal_label)
        details_layout.addRow("Security:", self.security_label)
        details_layout.addRow("Status:", self.status_label)
        self.details_group.setLayout(details_layout)
        layout.addWidget(self.details_group)
        # Password input for secured networks
        self.password_group = QGroupBox("Network Password")
        password_layout = QVBoxLayout()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.password_input.setPlaceholderText("Enter network password")
        password_layout.addWidget(self.password_input)
        self.show_password_check = QCheckBox("Show password")
        self.show_password_check.stateChanged.connect(self.toggle_password_visibility)
        password_layout.addWidget(self.show_password_check)
        self.password_group.setLayout(password_layout)
        self.password_group.setVisible(False)
        layout.addWidget(self.password_group)

        self.setLayout(layout)
        # Update connection details when selection changes
        self.network_list.itemSelectionChanged.connect(self.update_connection_details)

    def toggle_password_visibility(self, state):
        """Toggle password visibility"""
        if state == Qt.Checked:
            self.password_input.setEchoMode(QLineEdit.Normal)
        else:
            self.password_input.setEchoMode(QLineEdit.Password)

    def scan_networks(self):
        """Scan for available wireless networks"""
        self.network_list.clear()
        try:
            # Try to get wireless networks using nmcli
            result = subprocess.run(
                "nmcli -t -f SSID,SIGNAL,SECURITY dev wifi list",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                networks = []
                for line in result.stdout.splitlines():
                    parts = line.split(':')
                    if len(parts) >= 3:
                        ssid = parts[0]
                        signal = parts[1]
                        security = parts[2]
                        # Skip empty SSIDs
                        if not ssid:
                            continue
                        networks.append({
                            'ssid': ssid,
                            'signal': signal,
                            'security': security,
                            'connected': False
                        })
                # Check which network is currently connected
                try:
                    current_result = subprocess.run(
                        "nmcli -t -f NAME,TYPE connection show --active | grep wifi",
                        shell=True, capture_output=True, text=True
                    )
                    if current_result.returncode == 0:
                        current_ssid = current_result.stdout.split(':')[0]
                        for network in networks:
                            if network['ssid'] == current_ssid:
                                network['connected'] = True
                except:
                    pass
                # Sort networks by signal strength (descending) and connection status
                networks.sort(key=lambda x: (not x['connected'], -int(x['signal'])))
                # Add networks to the list
                for network in networks:
                    icon = "Û∞ñ©" if network['connected'] else "Û∞ñ™"
                    security_icon = "üîí" if network['security'] else "üîì"
                    item_text = f"{icon} {network['ssid']} {security_icon} ({network['signal']}%)"
                    item = QListWidgetItem(item_text)
                    item.setData(Qt.UserRole, network)
                    if network['connected']:
                        item.setForeground(QColor(TokyoNight.GREEN))
                    self.network_list.addItem(item)
            else:
                # Fallback to iwlist if nmcli fails
                self.scan_with_iwlist()
        except Exception as e:
            print(f"Error scanning networks: {e}")
            # Try fallback method
            self.scan_with_iwlist()

    def scan_with_iwlist(self):
        """Fallback method using iwlist to scan networks"""
        try:
            result = subprocess.run(
                "iwlist scan 2>/dev/null | grep -E 'ESSID|Quality|Encryption key'",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                networks = []
                current_network = {}
                for line in result.stdout.splitlines():
                    if "ESSID" in line:
                        if current_network:
                            networks.append(current_network)
                        ssid = line.split('"')[1] if '"' in line else "Hidden Network"
                        current_network = {'ssid': ssid}
                    elif "Quality" in line:
                        quality = line.split('=')[1].split('/')[0]
                        current_network['signal'] = int(quality)
                    elif "Encryption key" in line:
                        encrypted = "on" in line.split(':')[1]
                        current_network['security'] = "WPA/WPA2" if encrypted else "Open"
                if current_network:
                    networks.append(current_network)
                # Add networks to the list
                for network in networks:
                    security_icon = "üîí" if network.get('security') != "Open" else "üîì"
                    signal = network.get('signal', 0)
                    item_text = f"Û∞ñ™ {network['ssid']} {security_icon} ({signal}%)"
                    item = QListWidgetItem(item_text)
                    item.setData(Qt.UserRole, network)
                    self.network_list.addItem(item)
        except Exception as e:
            print(f"Error with iwlist scan: {e}")
            self.network_list.addItem(QListWidgetItem("Error scanning networks"))

    def update_connection_details(self):
        """Update connection details when selection changes"""
        current_item = self.network_list.currentItem()
        if not current_item:
            return
        network = current_item.data(Qt.UserRole)
        if not network:
            return

        self.ssid_label.setText(network.get('ssid', '--'))
        self.signal_label.setText(f"{network.get('signal', '--')}%")
        self.security_label.setText(network.get('security', '--'))
        status = "Connected" if network.get('connected', False) else "Available"
        self.status_label.setText(status)
        # Show password input for secured networks
        is_secured = network.get('security') and network.get('security') != "Open"
        self.password_group.setVisible(is_secured and not network.get('connected', False))

    def connect_to_selected(self):
        """Connect to the selected network"""
        current_item = self.network_list.currentItem()
        if not current_item:
            return
        self.connect_to_network(current_item)

    def connect_to_network(self, item):
        """Connect to a wireless network"""
        network = item.data(Qt.UserRole)
        if not network:
            return
        ssid = network.get('ssid')
        if not ssid:
            return

        try:
            # Check if already connected
            if network.get('connected', False):
                return
            # Check if network requires password
            is_secured = network.get('security') and network.get('security') != "Open"
            if is_secured:
                password = self.password_input.text()
                if not password:
                    self.password_group.setVisible(True)
                    self.password_input.setFocus()
                    return
                # Try to connect with password using nmcli
                # Method 1: Direct connection
                result = subprocess.run(
                    f"nmcli dev wifi connect '{ssid}' password '{password}'",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode != 0:
                    # Method 2: Create connection first, then connect
                    connection_name = ssid.replace(' ', '_')
                    create_result = subprocess.run(
                        f"nmcli connection add type wifi con-name '{connection_name}' ifname wlan0 ssid '{ssid}' wifi-sec.key-mgmt wpa-psk wifi-sec.psk '{password}'",
                        shell=True, capture_output=True, text=True
                    )
                    if create_result.returncode == 0:
                        # Now connect to the created connection
                        result = subprocess.run(
                            f"nmcli connection up '{connection_name}'",
                            shell=True, capture_output=True, text=True
                        )
                    else:
                        # Method 3: Try with different interface
                        create_result = subprocess.run(
                            f"nmcli connection add type wifi con-name '{connection_name}' ssid '{ssid}' wifi-sec.key-mgmt wpa-psk wifi-sec.psk '{password}'",
                            shell=True, capture_output=True, text=True
                        )
                        if create_result.returncode == 0:
                            result = subprocess.run(
                                f"nmcli connection up '{connection_name}'",
                                shell=True, capture_output=True, text=True
                            )
                if result.returncode != 0:
                    print(f"Failed to connect: {result.stderr}")
                    # Show error message
                    error_msg = result.stderr.strip() if result.stderr else "Connection failed"
                    self.status_label.setText(f"Error: {error_msg}")
                    # Show a more user-friendly error dialog
                    QMessageBox.warning(
                        self, "Connection Failed",
                        f"Failed to connect to {ssid}.\nError: {error_msg}\nPlease check your password and try again."
                    )
                    return
            else:
                # Connect to open network
                result = subprocess.run(
                    f"nmcli dev wifi connect '{ssid}'",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode != 0:
                    print(f"Failed to connect: {result.stderr}")
                    self.status_label.setText(f"Error: {result.stderr.strip()}")
                    # Show a more user-friendly error dialog
                    QMessageBox.warning(
                        self, "Connection Failed",
                        f"Failed to connect to {ssid}.\nError: {result.stderr.strip()}"
                    )
                    return
            # Update status
            self.status_label.setText("Connecting...")
            # Refresh network list after a short delay
            QTimer.singleShot(3000, self.scan_networks)
        except Exception as e:
            print(f"Error connecting to network: {e}")
            self.status_label.setText(f"Error: {str(e)}")
            # Show a more user-friendly error dialog
            QMessageBox.warning(
                self, "Connection Error",
                f"An error occurred while connecting to {ssid}.\nError: {str(e)}"
            )

    def disconnect_current(self):
        """Disconnect from current network"""
        try:
            # Get active WiFi connection
            result = subprocess.run(
                "nmcli -t -f NAME,TYPE connection show --active | grep wifi",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                connection_name = result.stdout.split(':')[0]
                # Disconnect the specific connection
                result = subprocess.run(
                    f"nmcli connection down '{connection_name}'",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    self.status_label.setText("Disconnected")
                    # Refresh network list after a short delay
                    QTimer.singleShot(2000, self.scan_networks)
                else:
                    print(f"Failed to disconnect: {result.stderr}")
                    self.status_label.setText(f"Error: {result.stderr.strip()}")
                    # Show a more user-friendly error dialog
                    QMessageBox.warning(
                        self, "Disconnection Failed",
                        f"Failed to disconnect from {connection_name}.\nError: {result.stderr.strip()}"
                    )
            else:
                # Try alternative method if no active WiFi connection found
                result = subprocess.run(
                    "nmcli dev disconnect $(nmcli dev status | grep wifi | head -1 | awk '{print $1}')",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    self.status_label.setText("Disconnected")
                    # Refresh network list after a short delay
                    QTimer.singleShot(2000, self.scan_networks)
                else:
                    print(f"Failed to disconnect: {result.stderr}")
                    self.status_label.setText(f"Error: {result.stderr.strip()}")
                    # Show a more user-friendly error dialog
                    QMessageBox.warning(
                        self, "Disconnection Failed",
                        f"Failed to disconnect from WiFi.\nError: {result.stderr.strip()}"
                    )
        except Exception as e:
            print(f"Error disconnecting: {e}")
            self.status_label.setText(f"Error: {str(e)}")
            # Show a more user-friendly error dialog
            QMessageBox.warning(
                self, "Disconnection Error",
                f"An error occurred while disconnecting from WiFi.\nError: {str(e)}"
            )

class NetworkManagerWidget(QWidget):
    """Widget for Network Manager control with wireless network dialog"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()

    def setup_ui(self):
        """Setup the network manager control UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        # Network manager button (clickable to launch network manager)
        self.network_button = QPushButton("Û∞§®")  # Network icon
        self.network_button.setFixedSize(32, 32)
        self.network_button.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        self.network_button.setCursor(Qt.PointingHandCursor)
        self.network_button.setToolTip("Left click: Wireless Networks\nRight click: Network Manager")
        self.network_button.clicked.connect(self.launch_wireless_dialog)
        self.network_button.setContextMenuPolicy(Qt.CustomContextMenu)
        self.network_button.customContextMenuRequested.connect(self.show_network_menu)
        layout.addWidget(self.network_button)

    def launch_wireless_dialog(self):
        """Launch wireless network dialog"""
        try:
            dialog = WirelessNetworkDialog(self)
            dialog.exec_()
        except Exception as e:
            print(f"Failed to launch wireless dialog: {e}")
            # Fallback to network manager
            self.launch_network_manager()

    def show_network_menu(self, position):
        """Show context menu for network options"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        wireless_action = QAction("Û∞ñ© Wireless Networks", self)
        wireless_action.triggered.connect(self.launch_wireless_dialog)
        menu.addAction(wireless_action)
        menu.addSeparator()
        manager_action = QAction("Û∞íì Network Manager", self)
        manager_action.triggered.connect(self.launch_network_manager)
        menu.addAction(manager_action)
        menu.exec_(self.network_button.mapToGlobal(position))

    def launch_network_manager(self):
        """Launch network manager when button is clicked"""
        try:
            # Try nm-connection-editor first (GUI version)
            result = subprocess.run(
                "which nm-connection-editor",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # Check if nm-connection-editor is already running
                result = subprocess.run(
                    "pgrep -f nm-connection-editor",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    # If running, focus it
                    subprocess.run(
                        "wmctrl -a 'Network Connections'",
                        shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                    )
                else:
                    # Launch nm-connection-editor
                    subprocess.Popen(
                        ["nm-connection-editor"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
            else:
                # Fallback to nm-applet
                subprocess.Popen(
                    ["nm-applet"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
        except Exception as e:
            print(f"Failed to launch network manager: {e}")
            # Try alternative command
            try:
                subprocess.Popen(
                    ["nm-applet"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except Exception as e2:
                print(f"Failed to launch nm-applet: {e2}")

class BluetoothManagerWidget(QWidget):
    """Widget for Bluetooth Manager control that launches blueman-manager"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_ui()

    def setup_ui(self):
        """Setup the bluetooth manager control UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)
        # Bluetooth manager button (clickable to launch bluetooth manager)
        self.bluetooth_button = QPushButton("Û∞ÇØ")  # Bluetooth icon
        self.bluetooth_button.setFixedSize(32, 32)
        self.bluetooth_button.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        self.bluetooth_button.setCursor(Qt.PointingHandCursor)
        self.bluetooth_button.setToolTip("Click to open Bluetooth Manager")
        self.bluetooth_button.clicked.connect(self.launch_bluetooth_manager)
        layout.addWidget(self.bluetooth_button)

    def launch_bluetooth_manager(self):
        """Launch bluetooth manager when button is clicked"""
        try:
            # Check if blueman-manager is available
            result = subprocess.run(
                "which blueman-manager",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # Check if blueman-manager is already running
                result = subprocess.run(
                    "pgrep -f blueman-manager",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    # If running, focus it
                    subprocess.run(
                        "wmctrl -a 'Bluetooth Manager'",
                        shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                    )
                else:
                    # Launch blueman-manager
                    subprocess.Popen(
                        ["blueman-manager"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
            else:
                print("Blueman-manager not found. Please install it with: sudo apt install blueman")
                # Try alternative bluetooth managers
                try:
                    # Try blueberry (alternative)
                    subprocess.Popen(
                        ["blueberry"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
                except:
                    # Try gnome-bluetooth
                    subprocess.Popen(
                        ["gnome-bluetooth"],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.DEVNULL
                    )
        except Exception as e:
            print(f"Failed to launch bluetooth manager: {e}")

class VolumeControlWidget(QWidget):
    """Widget for volume control with interactive slider, scroll wheel support, and global key bindings"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_volume = 50
        self.is_muted = False
        self.audio_backend = None
        self.default_sink = None
        self.global_key_handler = None
        self.setup_ui()
        self.detect_audio_backend()
        self.start_volume_monitor()
        # Add global key handler
        self.setup_global_key_handler()

    def setup_global_key_handler(self):
        """Setup global key handler for volume keys"""
        try:
            # Create global key handler
            self.global_key_handler = GlobalKeyHandler(self)
            print("Global volume key handler installed successfully")
        except Exception as e:
            print(f"Failed to setup global key handler: {e}")

    def start_volume_monitor(self):
        """Monitor for volume changes"""
        self.volume_timer = QTimer()
        self.volume_timer.timeout.connect(self.check_system_volume)
        self.volume_timer.start(500)  # Check every 500ms

    def check_system_volume(self):
        """Check current system volume and update display"""
        try:
            volume, muted = self.get_current_volume()
            if volume is not None and (volume != self.current_volume or muted != self.is_muted):
                self.current_volume = volume
                self.is_muted = muted
                self.update_volume_display(volume, muted)
                # Update slider
                self.volume_slider.blockSignals(True)
                self.volume_slider.setValue(volume)
                self.volume_slider.blockSignals(False)
        except Exception as e:
            print(f"Error checking system volume: {e}")

    def get_current_volume(self):
        """Get current volume using pactl"""
        try:
            # Get volume from default sink
            result = subprocess.run(
                ["pactl", "get-sink-volume", "@DEFAULT_SINK@"],
                capture_output=True, text=True, timeout=2
            )
            if result.returncode == 0:
                # Parse volume from output
                import re
                volume_matches = re.findall(r'(\d+)%', result.stdout)
                if volume_matches:
                    volume = int(volume_matches[0])
                    # Check if muted
                    mute_result = subprocess.run(
                        ["pactl", "get-sink-mute", "@DEFAULT_SINK@"],
                        capture_output=True, text=True, timeout=2
                    )
                    muted = (mute_result.returncode == 0 and 
                           "yes" in mute_result.stdout.lower())
                    return volume, muted
        except Exception as e:
            print(f"Volume check error: {e}")
        return None, None

    def setup_ui(self):
        """Setup the volume control UI"""
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(5)

        # Volume icon (clickable to toggle mute)
        self.volume_icon = QLabel("Û∞ïæ")
        self.volume_icon.setStyleSheet(f"""
            padding: 4px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 12pt;
            color: {TokyoNight.FOREGROUND};
        """)
        self.volume_icon.setCursor(Qt.PointingHandCursor)
        self.volume_icon.mousePressEvent = self.volume_icon_mouse_press
        self.volume_icon.setToolTip("Click to toggle mute\nScroll to adjust volume\nVolume keys work globally")
        layout.addWidget(self.volume_icon)

        # Volume slider
        self.volume_slider = QSlider(Qt.Horizontal)
        self.volume_slider.setRange(0, 100)
        self.volume_slider.setValue(self.current_volume)
        self.volume_slider.setFixedWidth(80)
        self.volume_slider.valueChanged.connect(self.set_volume)
        self.volume_slider.setStyleSheet(f"""
            QSlider::groove:horizontal {{
                border: none;
                height: 4px;
                background: {TokyoNight.NEBULA};
                border-radius: 2px;
            }}
            QSlider::handle:horizontal {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                border: none;
                width: 12px;
                margin: -4px 0;
                border-radius: 6px;
            }}
            QSlider::handle:horizontal:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """)
        layout.addWidget(self.volume_slider)

        # Volume label (clickable to launch pavucontrol)
        self.volume_label = QLabel("50%")
        self.volume_label.setStyleSheet(f"""
            padding: 4px 8px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 9pt;
            color: {TokyoNight.FOREGROUND};
        """)
        self.volume_label.setCursor(Qt.PointingHandCursor)
        self.volume_label.mousePressEvent = self.volume_label_mouse_press
        self.volume_label.setToolTip("Click to open Volume Control")
        layout.addWidget(self.volume_label)

        # Enable mouse tracking for the whole widget
        self.setMouseTracking(True)

    def volume_icon_mouse_press(self, event):
        """Handle mouse press on volume icon"""
        if event.button() == Qt.LeftButton:
            self.toggle_mute()

    def volume_label_mouse_press(self, event):
        """Handle mouse press on volume label"""
        if event.button() == Qt.LeftButton:
            self.launch_pavucontrol()

    def mousePressEvent(self, event):
        """Handle mouse press events for the entire widget."""
        if event.button() == Qt.LeftButton:
            # Don't handle clicks on child widgets - let their handlers deal with it
            child_widget = self.childAt(event.pos())
            if child_widget in [self.volume_icon, self.volume_label, self.volume_slider]:
                # Let the child widget handle the click
                super().mousePressEvent(event)
                return
                
            # Handle click on empty space in the widget
            # Calculate the volume based on the click position relative to the widget
            widget_rect = self.rect()
            click_x = event.pos().x()
            
            # Calculate volume based on click position
            if widget_rect.width() > 0:
                volume = int((click_x / widget_rect.width()) * 100)
                volume = max(0, min(100, volume))
                self.set_volume(volume)
                
        super().mousePressEvent(event)

    def wheelEvent(self, event):
        """Handle mouse wheel events for the entire widget to change volume."""
        # Calculate volume change
        delta = event.angleDelta().y()
        if delta > 0:
            # Scroll up - increase volume
            new_volume = min(100, self.current_volume + 5)
        else:
            # Scroll down - decrease volume
            new_volume = max(0, self.current_volume - 5)
        # Set the new volume
        self.set_volume(new_volume)
        event.accept()

    def set_volume(self, volume):
        """Set system volume and update display"""
        # Update current volume
        self.current_volume = volume
        # Update slider position (block signals to avoid recursion)
        self.volume_slider.blockSignals(True)
        self.volume_slider.setValue(volume)
        self.volume_slider.blockSignals(False)
        # Set system volume using pactl
        success = self.set_volume_pactl(volume)
        if not success:
            print(f"Failed to set volume to {volume}%")
        # Update display
        self.update_volume_display(volume, self.is_muted)

    def set_volume_pactl(self, volume):
        """Set volume using pactl command"""
        try:
            result = subprocess.run(
                ["pactl", "set-sink-volume", "@DEFAULT_SINK@", f"{volume}%"],
                capture_output=True, text=True, timeout=2
            )
            return result.returncode == 0
        except Exception as e:
            print(f"Volume set error: {e}")
            return False

    def toggle_mute(self):
        """Toggle mute state"""
        success = self.toggle_mute_pactl()
        if not success:
            print("Failed to toggle mute")
        else:
            # Toggle mute state locally
            self.is_muted = not self.is_muted
            self.update_volume_display(self.current_volume, self.is_muted)

    def toggle_mute_event(self, event):
        """Toggle mute state (for key binding)"""
        success = self.toggle_mute_pactl()
        if not success:
            print("Failed to toggle mute")
        else:
            # Toggle mute state locally
            self.is_muted = not self.is_muted
            self.update_volume_display(self.current_volume, self.is_muted)

    def toggle_mute_pactl(self):
        """Toggle mute using pactl"""
        try:
            result = subprocess.run(
                ["pactl", "set-sink-mute", "@DEFAULT_SINK@", "toggle"],
                capture_output=True, text=True, timeout=2
            )
            return result.returncode == 0
        except Exception as e:
            print(f"Mute toggle error: {e}")
            return False

    def launch_pavucontrol(self):
        """Launch volume control when label is clicked"""
        try:
            # Try pavucontrol first (works with PipeWire)
            # Check if pavucontrol is already running
            result = subprocess.run(
                ["pgrep", "-f", "pavucontrol"],
                capture_output=True, text=True
            )
            if result.returncode == 0:
                # If running, focus it
                subprocess.run(
                    ["wmctrl", "-a", "pavucontrol"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            else:
                # Launch pavucontrol
                subprocess.Popen(
                    ["pavucontrol"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
        except Exception as e:
            print(f"Failed to launch pavucontrol: {e}")

    def update_volume_display(self, volume, muted):
        """Update the volume label display"""
        self.current_volume = volume
        self.is_muted = muted
        icon = "Û∞ñÅ" if muted else "Û∞ïæ"  # Muted vs volume icon
        color = TokyoNight.RED if muted else TokyoNight.CYAN
        # Update icon
        self.volume_icon.setText(f"<font color='{color}'>{icon}</font>")
        # Update label
        self.volume_label.setText(f"<font color='{color}'>{volume}%</font>")

    def detect_audio_backend(self):
        """Detect which audio backend is available"""
        try:
            # Check if pactl works
            result = subprocess.run(
                ["pactl", "info"],
                capture_output=True, text=True, timeout=3
            )
            if result.returncode == 0:
                if "PipeWire" in result.stdout or "pipewire" in result.stdout.lower():
                    self.audio_backend = 'pipewire'
                    print("Using PipeWire backend")
                else:
                    self.audio_backend = 'pulse'
                    print("Using PulseAudio backend")
                return
        except Exception as e:
            print(f"PulseAudio/PipeWire check failed: {e}")

        # Fallback to ALSA
        try:
            result = subprocess.run(
                ["amixer", "scontrols"],
                capture_output=True, text=True, timeout=3
            )
            if result.returncode == 0 and "Master" in result.stdout:
                self.audio_backend = 'alsa'
                print("Using ALSA backend")
                return
        except:
            pass
        print("Warning: No supported audio backend found")
        self.audio_backend = None

class SystemMonitorThread(QThread):
    cpu_updated = pyqtSignal(float)
    memory_updated = pyqtSignal(float)
    battery_updated = pyqtSignal(int, str, str)  # capacity, status, time
    volume_updated = pyqtSignal(int, bool)
    network_updated = pyqtSignal(str, str)  # ssid, status
    brightness_updated = pyqtSignal(int)
    workspace_updated = pyqtSignal(int)  # Current workspace index
    active_window_updated = pyqtSignal(str)  # Active window ID

    def __init__(self):
        super().__init__()
        self.battery_path = self.find_battery_path()

    def find_battery_path(self):
        """Find the correct battery path"""
        battery_base = "/sys/class/power_supply"
        try:
            # List all power supply devices
            devices = os.listdir(battery_base)
            for device in devices:
                if device.startswith(('BAT', 'bat')):
                    # Check if capacity file exists
                    capacity_file = os.path.join(battery_base, device, 'capacity')
                    if os.path.exists(capacity_file):
                        return os.path.join(battery_base, device)
        except:
            pass
        return os.path.join(battery_base, 'BAT0')  # Default fallback

    def format_time(self, seconds):
        """Format seconds into hours and minutes"""
        if seconds <= 0:
            return ""
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        if hours > 0:
            return f"{hours}h{minutes:02d}m"
        else:
            return f"{minutes}m"

    def get_battery_time_upower(self, status):
        """Get battery time using upower command"""
        try:
            if status.lower() == "discharging":
                result = subprocess.run(
                    "upower -i $(upower -e | grep battery) 2>/dev/null | grep 'time to empty' | cut -d':' -f2 | tr -d ' ' | head -1",
                    shell=True, capture_output=True, text=True
                )
            elif status.lower() == "charging":
                result = subprocess.run(
                    "upower -i $(upower -e | grep battery) 2>/dev/null | grep 'time to full' | cut -d':' -f2 | tr -d ' ' | head -1",
                    shell=True, capture_output=True, text=True
                )
            else:
                return ""
            if result.returncode == 0 and result.stdout.strip():
                time_str = result.stdout.strip()
                # Parse time format like "1.5h" or "45min"
                if 'h' in time_str and 'min' in time_str:
                    # Format: "1.5h 30min"
                    hours_part = time_str.split('h')[0]
                    minutes_part = time_str.split('min')[0].split()[-1]
                    try:
                        hours = int(float(hours_part))
                        minutes = int(minutes_part)
                        return f"{hours}h{minutes:02d}m"
                    except:
                        return time_str
                elif 'h' in time_str:
                    return time_str.replace('h', 'h')
                elif 'min' in time_str:
                    return time_str.replace('min', 'm')
        except:
            pass
        return ""

    def get_battery_info(self):
        """Get comprehensive battery information"""
        capacity = 0
        status = "Unknown"
        time_str = ""
        try:
            # Get capacity
            capacity_file = os.path.join(self.battery_path, 'capacity')
            if os.path.exists(capacity_file):
                with open(capacity_file, 'r') as f:
                    capacity = int(f.read().strip())
            else:
                # Try alternative location
                capacity_result = subprocess.run(
                    "cat /sys/class/power_supply/BAT*/capacity 2>/dev/null | head -1 || echo 0",
                    shell=True, capture_output=True, text=True
                )
                capacity = int(capacity_result.stdout.strip()) if capacity_result.stdout.strip().isdigit() else 0

            # Get status
            status_file = os.path.join(self.battery_path, 'status')
            if os.path.exists(status_file):
                with open(status_file, 'r') as f:
                    status = f.read().strip()
            else:
                status_result = subprocess.run(
                    "cat /sys/class/power_supply/BAT*/status 2>/dev/null | head -1 || echo Unknown",
                    shell=True, capture_output=True, text=True
                )
                status = status_result.stdout.strip()

            # Get time information with multiple fallback methods
            time_str = self.get_battery_time(status, capacity)
        except Exception as e:
            print(f"Battery info error: {e}")
        return capacity, status, time_str

    def get_battery_time(self, status, capacity):
        """Get battery time with multiple fallback methods"""
        time_str = ""
        try:
            # Method 1: Direct kernel files (most accurate)
            if status.lower() == "discharging":
                time_file = os.path.join(self.battery_path, 'time_to_empty')
                if os.path.exists(time_file):
                    with open(time_file, 'r') as f:
                        time_value = f.read().strip()
                    if time_value and time_value.isdigit() and int(time_value) > 0:
                        seconds = int(time_value) * 60  # Convert minutes to seconds
                        time_str = self.format_time(seconds)
                else:
                    # Try alternative naming
                    time_file = os.path.join(self.battery_path, 'time_to_empty_now')
                    if os.path.exists(time_file):
                        with open(time_file, 'r') as f:
                            time_value = f.read().strip()
                        if time_value and time_value.isdigit() and int(time_value) > 0:
                            seconds = int(time_value)
                            time_str = self.format_time(seconds)

            elif status.lower() == "charging":
                time_file = os.path.join(self.battery_path, 'time_to_full')
                if os.path.exists(time_file):
                    with open(time_file, 'r') as f:
                        time_value = f.read().strip()
                    if time_value and time_value.isdigit() and int(time_value) > 0:
                        seconds = int(time_value) * 60  # Convert minutes to seconds
                        time_str = self.format_time(seconds)
                else:
                    # Try alternative naming
                    time_file = os.path.join(self.battery_path, 'time_to_full_now')
                    if os.path.exists(time_file):
                        with open(time_file, 'r') as f:
                            time_value = f.read().strip()
                        if time_value and time_value.isdigit() and int(time_value) > 0:
                            seconds = int(time_value)
                            time_str = self.format_time(seconds)

            # Method 2: Use upower if available (good fallback)
            if not time_str:
                time_str = self.get_battery_time_upower(status)

            # Method 3: Estimate based on capacity and average consumption
            if not time_str and status.lower() == "discharging":
                # Very rough estimate: assume 5 hours total battery life
                estimated_minutes = int((capacity / 100.0) * 300)  # 5 hours = 300 minutes
                if estimated_minutes > 60:
                    time_str = f"{estimated_minutes // 60}h{estimated_minutes % 60:02d}m"
                else:
                    time_str = f"{estimated_minutes}m"
            elif not time_str and status.lower() == "charging":
                # Rough estimate for charging
                remaining_percent = 100 - capacity
                estimated_minutes = int(remaining_percent * 1.5)  # ~1.5 minutes per percent
                if estimated_minutes > 60:
                    time_str = f"{estimated_minutes // 60}h{estimated_minutes % 60:02d}m"
                else:
                    time_str = f"{estimated_minutes}m"
            elif status.lower() == "full":
                time_str = "Full"
        except Exception as e:
            print(f"Battery time error: {e}")
        return time_str

    def get_volume_pulse(self):
        """Get volume using PipeWire/PulseAudio pactl commands"""
        try:
            # Get default sink
            sink_result = subprocess.run(
                ["pactl", "get-default-sink"],
                capture_output=True, text=True, timeout=2
            )
            default_sink = None
            if sink_result.returncode == 0:
                default_sink = sink_result.stdout.strip()
            # If no default sink, try to find one
            if not default_sink:
                list_result = subprocess.run(
                    ["pactl", "list", "sinks", "short"],
                    capture_output=True, text=True, timeout=2
                )
                if list_result.returncode == 0:
                    lines = list_result.stdout.splitlines()
                    if lines:
                        default_sink = lines[0].split()[1]

            if default_sink:
                # Get volume
                result = subprocess.run(
                    ["pactl", "get-sink-volume", default_sink],
                    capture_output=True, text=True, timeout=2
                )
                if result.returncode == 0:
                    # Parse volume from output (PipeWire/PulseAudio format)
                    import re
                    # Look for volume percentage in the output
                    volume_matches = re.findall(r'(\d+)%', result.stdout)
                    if volume_matches:
                        # Take the left channel volume (usually first match)
                        volume = int(volume_matches[0])
                        # Check if muted
                        mute_result = subprocess.run(
                            ["pactl", "get-sink-mute", default_sink],
                            capture_output=True, text=True, timeout=2
                        )
                        muted = (mute_result.returncode == 0 and 
                               "yes" in mute_result.stdout.lower())
                        return volume, muted
        except Exception as e:
            print(f"PipeWire/PulseAudio volume error: {e}")
        return None, None

    def get_volume_amixer(self):
        """Get volume using amixer"""
        try:
            result = subprocess.run(
                "amixer sget Master 2>/dev/null | grep -o '[0-9]*%' | head -1",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                volume_str = result.stdout.strip().rstrip('%')
                if volume_str.isdigit():
                    # Check if muted
                    muted_result = subprocess.run(
                        "amixer sget Master 2>/dev/null | grep -q '\\[off\\]'",
                        shell=True
                    )
                    muted = muted_result.returncode == 0
                    return int(volume_str), muted
        except:
            pass
        return None, None

    def get_current_workspace(self):
        """Get the current workspace index more reliably"""
        try:
            # Method 1: wmctrl
            result = subprocess.run(
                "wmctrl -d | grep '*' | awk '{print $1}'",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip().isdigit():
                return int(result.stdout.strip())
            
            # Method 2: xdotool
            result = subprocess.run(
                "xdotool get_desktop",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip().isdigit():
                return int(result.stdout.strip())
                
        except Exception as e:
            print(f"Error getting current workspace: {e}")
        
        return 0  # Fallback

    def get_active_window(self):
        """Get the ID of the currently active window"""
        try:
            result = subprocess.run(
                "xdotool getwindowfocus",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
        except:
            pass
        # Fallback to wmctrl
        try:
            result = subprocess.run(
                "wmctrl -l | grep ' *' | cut -d' ' -f1",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
        except:
            pass
        return ""

    def run(self):
        self.prev_cpu_total = 0
        self.prev_cpu_idle = 0
        while True:
            # CPU usage
            try:
                with open('/proc/stat', 'r') as f:
                    for line in f:
                        if line.startswith('cpu '):
                            parts = line.split()
                            user = int(parts[1])
                            nice = int(parts[2])
                            system = int(parts[3])
                            idle = int(parts[4])
                            total = user + nice + system + idle
                            if self.prev_cpu_total > 0:
                                usage = ((total - self.prev_cpu_total) - (idle - self.prev_cpu_idle)) / (total - self.prev_cpu_total) * 100
                                self.cpu_updated.emit(usage)
                            self.prev_cpu_total = total
                            self.prev_cpu_idle = idle
                            break
            except:
                self.cpu_updated.emit(0)

            # Memory usage
            try:
                with open('/proc/meminfo', 'r') as f:
                    meminfo = {}
                    for line in f:
                        key, value = line.split(':', 1)
                        meminfo[key] = value.strip().split(' ')[0]
                total = int(meminfo['MemTotal'])
                available = int(meminfo['MemAvailable'])
                used = total - available
                percent = (used / total) * 100
                self.memory_updated.emit(percent)
            except:
                self.memory_updated.emit(0)

            # Battery - Enhanced with time information
            try:
                capacity, status, time_str = self.get_battery_info()
                self.battery_updated.emit(capacity, status, time_str)
            except:
                self.battery_updated.emit(0, "Unknown", "")

            # Volume - try multiple methods with proper backend detection
            volume, muted = None, None
            # Try PipeWire/PulseAudio first
            volume, muted = self.get_volume_pulse()
            # If PipeWire/PulseAudio failed, try ALSA
            if volume is None:
                volume, muted = self.get_volume_amixer()
            # If all failed, emit default values
            if volume is None:
                volume, muted = 0, False
                print("Warning: Could not get volume - no audio tool found")
            self.volume_updated.emit(volume, muted)

            # Network
            try:
                ssid = subprocess.run(
                    "iwgetid -r 2>/dev/null || echo ''",
                    shell=True, capture_output=True, text=True
                ).stdout.strip()
                if ssid:
                    self.network_updated.emit(ssid, "connected")
                else:
                    # Check ethernet
                    ethernet = subprocess.run(
                        "ip route | grep default | head -1 | awk '{print $5}' 2>/dev/null || echo ''",
                        shell=True, capture_output=True, text=True
                    ).stdout.strip()
                    if ethernet:
                        self.network_updated.emit(ethernet, "connected")
                    else:
                        self.network_updated.emit("", "disconnected")
            except:
                self.network_updated.emit("", "disconnected")

            # Brightness
            try:
                result = subprocess.run(
                    "brightnessctl get && brightnessctl max",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    current, max_val = map(int, result.stdout.splitlines())
                    brightness = int((current / max_val) * 100)
                    self.brightness_updated.emit(brightness)
            except:
                pass

            # Current workspace
            current_workspace = self.get_current_workspace()
            self.workspace_updated.emit(current_workspace)

            # Active window
            active_window = self.get_active_window()
            self.active_window_updated.emit(active_window)

            time.sleep(2)

class SystemTrayWidget(QWidget):
    """Widget to host system tray icons"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(2)
        self.layout.setAlignment(Qt.AlignRight)
        # Set up system tray integration
        self.tray_icons = []
        self.setup_system_tray()

    def setup_system_tray(self):
        """Setup system tray integration using XEmbed"""
        try:
            # Try to find existing system tray
            if HAS_X11 and QX11Info.isPlatformX11():
                # Get the system tray selection atom
                import os
                os.environ['XDG_CURRENT_DESKTOP'] = 'XFCE'
                # Start sni-qt or similar if available
                subprocess.Popen(["which", "snid"], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"System tray setup error: {e}")

    def add_tray_icon(self, icon_widget):
        """Add a tray icon widget to the tray area"""
        self.layout.addWidget(icon_widget)
        self.tray_icons.append(icon_widget)

    def clear_tray_icons(self):
        """Clear all tray icons"""
        for icon in self.tray_icons:
            icon.deleteLater()
        self.tray_icons.clear()

@dataclass
class PanelConfig:
    position: str = "top"
    height: int = 40
    opacity: float = 0.95
    blur_effect: bool = True
    show_date: bool = True
    show_battery: bool = True
    show_volume: bool = True
    show_network: bool = True
    show_tray: bool = True
    theme_variant: str = "tokyo_night"
    rounded_corners: bool = True
    corner_radius: int = 10
    show_xfce_launchers: bool = True
    
    # New features
    show_workspace_switcher: bool = True
    show_brightness_control: bool = True
    show_weather: bool = True
    show_notifications: bool = True
    
    # NEW: Network and Bluetooth controls
    show_network_control: bool = True
    show_bluetooth_control: bool = True
    weather_location: str = ""
    
    # NEW: Tiling control
    show_tiling_control: bool = True
    
    # Custom launchers
    launcher_customizations: List[Application] = None
    custom_launchers: list = None  # Add this line for panel context menu launchers
    
    # Built-in launcher configurations
    terminal_command: str = "xfce4-terminal"
    file_manager_command: str = "thunar"
    browser_command: str = "firefox"
    text_editor_command: str = "mousepad"
    settings_command: str = "xfce4-settings-manager"
    calculator_command: str = "gnome-calculator"
    screenshot_command: str = "xfce4-screenshooter"
    image_viewer_command: str = "ristretto"
    music_player_command: str = "vlc"
    music_player_args: str = ""
    
    # Auto-hide settings
    auto_hide: bool = False
    auto_hide_delay: int = 2000
    show_on_edge: bool = True
    edge_size: int = 5

    # NEW: Clock and date customization
    clock_font_size: int = 11
    date_font_size: int = 8
    clock_color: str = TokyoNight.MOON_GLOW
    date_color: str = TokyoNight.FOREGROUND
    clock_font_weight: str = "bold"
    date_font_weight: str = "normal"
    show_seconds: bool = False
    date_format: str = "ddd MMM d"  # Mon Jan 1
    time_format: str = "hh:mm AP"   # 12:00 PM

    def __post_init__(self):
        """Initialize lists after creation"""
        if self.launcher_customizations is None:
            self.launcher_customizations = []
        if self.custom_launchers is None:
            self.custom_launchers = []

class LauncherDialog(QDialog):
    """Dialog for adding/editing a launcher with system icon support and workspace targeting"""
    def __init__(self, parent=None, launcher=None):
        super().__init__(parent)
        self.launcher = launcher
        self.setup_ui()
        if self.launcher:
            # If editing, set the initial values
            self.name_edit.setText(self.launcher.name)
            self.command_edit.setText(self.launcher.command)
            self.args_edit.setText(self.launcher.args)
            self.icon_edit.setText(self.launcher.icon)
            self.workspace_combo.setCurrentIndex(self.launcher.workspace + 1)  # +1 because index 0 is "Current"

    def setup_ui(self):
        self.setWindowTitle("Add Launcher" if not self.launcher else "Edit Launcher")
        self.setFixedSize(450, 350)  # Increased height for workspace option
        self.setStyleSheet(f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QLabel {{
                color: {TokyoNight.FOREGROUND};
            }}
            QLineEdit, QComboBox {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                padding: 5px;
                border-radius: 3px;
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """)
        layout = QFormLayout()
        
        self.name_edit = QLineEdit()
        if self.launcher:
            self.name_edit.setText(self.launcher.name)
        layout.addRow("Name:", self.name_edit)
        
        self.command_edit = QLineEdit()
        if self.launcher:
            self.command_edit.setText(self.launcher.command)
        layout.addRow("Command:", self.command_edit)
        
        self.args_edit = QLineEdit()
        if self.launcher:
            self.args_edit.setText(self.launcher.args)
        self.args_edit.setPlaceholderText("Optional arguments")
        layout.addRow("Arguments:", self.args_edit)
        
        # Icon selection
        icon_selection_layout = QHBoxLayout()
        self.icon_edit = QLineEdit()
        self.icon_edit.setPlaceholderText("Enter system icon name (e.g., 'firefox', 'thunar') or path")
        if self.launcher:
            self.icon_edit.setText(self.launcher.icon)
        browse_icon_btn = QPushButton("Browse System Icon")
        browse_icon_btn.clicked.connect(self.browse_system_icon)
        icon_selection_layout.addWidget(self.icon_edit)
        icon_selection_layout.addWidget(browse_icon_btn)
        layout.addRow("Icon (name or path):", icon_selection_layout)
        
        # NEW: Workspace selection
        self.workspace_combo = QComboBox()
        # Get available workspaces
        workspaces = self.get_available_workspaces()
        self.workspace_combo.addItem("Current Workspace", -1)  # -1 means current
        for i, workspace_name in enumerate(workspaces):
            self.workspace_combo.addItem(f"Workspace {i+1}: {workspace_name}", i)
        layout.addRow("Open in Workspace:", self.workspace_combo)
        
        buttons_layout = QHBoxLayout()
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        buttons_layout.addWidget(save_btn)
        buttons_layout.addWidget(cancel_btn)
        layout.addRow(buttons_layout)
        
        self.setLayout(layout)

    def get_available_workspaces(self):
        """Get list of available workspace names"""
        workspaces = []
        try:
            result = subprocess.run("wmctrl -d", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    # Extract workspace name (the part after the resolution)
                    parts = line.split()
                    if len(parts) >= 9:
                        # Join the parts that form the workspace name
                        name_parts = parts[8:]
                        workspace_name = ' '.join(name_parts)
                        workspaces.append(workspace_name)
                    else:
                        workspaces.append(f"Workspace {len(workspaces)}")
        except Exception as e:
            print(f"Error getting workspaces: {e}")
            # Fallback: create generic workspace names
            workspaces = [f"Workspace {i+1}" for i in range(4)]
        return workspaces

    def browse_system_icon(self):
        """Open a simple dialog to enter a system icon name."""
        icon_name, ok = QInputDialog.getText(
            self, "System Icon Name", "Enter system icon name (e.g., 'firefox', 'thunar', 'terminal'):", 
            QLineEdit.Normal, self.icon_edit.text()
        )
        if ok:
            self.icon_edit.setText(icon_name)

    def get_launcher(self):
        """Get the launcher from the dialog."""
        workspace_index = self.workspace_combo.currentData()
        return Application(
            name=self.name_edit.text(),
            command=self.command_edit.text(),
            args=self.args_edit.text(),
            icon=self.icon_edit.text() or "üöÄ",
            workspace=workspace_index
        )
        
class SettingsDialog(QDialog):
    def __init__(self, config: PanelConfig, parent=None):
        super().__init__(parent)
        self.config = config
        self.setup_ui()

    def setup_ui(self):
        self.setWindowTitle("Panel Settings")
        self.setFixedSize(600, 700)
        self.setStyleSheet(self.get_stylesheet())

        layout = QVBoxLayout()
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(8)
        
        # Create tabs
        tabs = QTabWidget()
        tabs.setStyleSheet(f"""
            QTabWidget::pane {{
                border: 1px solid {TokyoNight.SELECTION};
                border-radius: 6px;
                background: {TokyoNight.NIGHT_BOTTOM};
            }}
            QTabBar::tab {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                padding: 8px 12px;
                margin-right: 2px;
                border-top-left-radius: 6px;
                border-top-right-radius: 6px;
                font-size: 9pt;
            }}
            QTabBar::tab:selected {{
                background: {TokyoNight.BLUE};
            }}
            QTabBar::tab:hover {{
                background: {TokyoNight.BLUE}40;
            }}
        """)

        # Appearance tab
        appearance_tab = QWidget()
        appearance_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        appearance_layout = QFormLayout(appearance_tab)
        appearance_layout.setContentsMargins(8, 8, 8, 8)
        appearance_layout.setSpacing(6)
        
        self.position_combo = QComboBox()
        self.position_combo.addItems(["top", "bottom"])
        self.position_combo.setCurrentText(self.config.position)
        appearance_layout.addRow("Position:", self.position_combo)
        
        self.height_spin = QSpinBox()
        self.height_spin.setRange(30, 100)
        self.height_spin.setValue(self.config.height)
        appearance_layout.addRow("Height:", self.height_spin)
        
        opacity_layout = QHBoxLayout()
        self.opacity_slider = QSlider(Qt.Horizontal)
        self.opacity_slider.setRange(50, 100)
        self.opacity_slider.setValue(int(self.config.opacity * 100))
        self.opacity_label = QLabel(f"{self.opacity_slider.value()}%")
        self.opacity_slider.valueChanged.connect(lambda v: self.opacity_label.setText(f"{v}%"))
        opacity_layout.addWidget(self.opacity_slider)
        opacity_layout.addWidget(self.opacity_label)
        opacity_layout.setStretch(0, 3)
        opacity_layout.setStretch(1, 1)
        appearance_layout.addRow("Opacity:", opacity_layout)
        
        self.theme_combo = QComboBox()
        self.theme_combo.addItems(["tokyo_night", "tokyo_storm", "tokyo_day"])
        self.theme_combo.setCurrentText(self.config.theme_variant)
        appearance_layout.addRow("Theme:", self.theme_combo)
        
        # Rounded corners
        corners_layout = QHBoxLayout()
        self.rounded_corners_check = QCheckBox("Rounded Corners")
        self.rounded_corners_check.setChecked(self.config.rounded_corners)
        self.corner_radius_spin = QSpinBox()
        self.corner_radius_spin.setRange(0, 30)
        self.corner_radius_spin.setValue(self.config.corner_radius)
        self.corner_radius_spin.setEnabled(self.config.rounded_corners)
        self.rounded_corners_check.toggled.connect(self.corner_radius_spin.setEnabled)
        corners_layout.addWidget(self.rounded_corners_check)
        corners_layout.addWidget(QLabel("Radius:"))
        corners_layout.addWidget(self.corner_radius_spin)
        corners_layout.addStretch()
        appearance_layout.addRow("Corners:", corners_layout)

        # Auto-hide settings
        auto_hide_group = QGroupBox("Auto-Hide")
        auto_hide_group.setStyleSheet(f"""
            QGroupBox {{
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
                background: {TokyoNight.NIGHT_BOTTOM}80;
            }}
            QGroupBox::title {{
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
            }}
        """)
        auto_hide_layout = QFormLayout(auto_hide_group)
        auto_hide_layout.setContentsMargins(8, 15, 8, 8)
        auto_hide_layout.setSpacing(6)
        
        self.auto_hide_check = QCheckBox("Enable Auto-Hide")
        self.auto_hide_check.setChecked(self.config.auto_hide)
        auto_hide_layout.addRow(self.auto_hide_check)
        
        self.auto_hide_delay_spin = QSpinBox()
        self.auto_hide_delay_spin.setRange(500, 5000)
        self.auto_hide_delay_spin.setValue(self.config.auto_hide_delay)
        self.auto_hide_delay_spin.setSuffix(" ms")
        auto_hide_layout.addRow("Hide Delay:", self.auto_hide_delay_spin)
        
        self.show_on_edge_check = QCheckBox("Show on Edge Hover")
        self.show_on_edge_check.setChecked(self.config.show_on_edge)
        auto_hide_layout.addRow(self.show_on_edge_check)
        
        self.edge_size_spin = QSpinBox()
        self.edge_size_spin.setRange(1, 20)
        self.edge_size_spin.setValue(self.config.edge_size)
        self.edge_size_spin.setSuffix(" px")
        auto_hide_layout.addRow("Edge Size:", self.edge_size_spin)
        
        appearance_layout.addRow(auto_hide_group)

        # Modules tab
        modules_tab = QWidget()
        modules_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        modules_layout = QVBoxLayout(modules_tab)
        modules_layout.setContentsMargins(8, 8, 8, 8)
        
        # Create scroll area for modules
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        scroll.setStyleSheet(f"""
            QScrollArea {{
                border: none;
                background: {TokyoNight.NIGHT_BOTTOM};
            }}
            QScrollBar:vertical {{
                background: {TokyoNight.SELECTION};
                width: 8px;
                border-radius: 4px;
            }}
            QScrollBar::handle:vertical {{
                background: {TokyoNight.BLUE};
                border-radius: 4px;
                min-height: 20px;
            }}
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {{
                border: none;
                background: none;
            }}
        """)
        
        modules_widget = QWidget()
        modules_widget.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        modules_scroll_layout = QVBoxLayout(modules_widget)
        modules_scroll_layout.setSpacing(8)
        modules_scroll_layout.setContentsMargins(5, 5, 5, 5)
        
        modules = [
            ("Show Date", "show_date_check", self.config.show_date),
            ("Show Battery", "show_battery_check", self.config.show_battery),
            ("Show Volume", "show_volume_check", self.config.show_volume),
            ("Show Network Status", "show_network_check", self.config.show_network),
            ("Show System Tray", "show_tray_check", self.config.show_tray),
            ("Show XFCE Launchers", "show_xfce_launchers_check", self.config.show_xfce_launchers),
            ("Show Workspace Switcher", "show_workspace_switcher_check", self.config.show_workspace_switcher),
            ("Show Brightness Control", "show_brightness_control_check", self.config.show_brightness_control),
            ("Show Weather Widget", "show_weather_check", self.config.show_weather),
            ("Show Notification Center", "show_notifications_check", self.config.show_notifications),
            ("Show Network Manager Control", "show_network_control_check", self.config.show_network_control),
            ("Show Bluetooth Manager Control", "show_bluetooth_control_check", self.config.show_bluetooth_control),
            ("Show Tiling Control", "show_tiling_control_check", self.config.show_tiling_control),
        ]
        
        for name, attr, value in modules:
            checkbox = QCheckBox(name)
            checkbox.setChecked(value)
            checkbox.setStyleSheet(f"""
                QCheckBox {{
                    color: {TokyoNight.FOREGROUND};
                    background: transparent;
                    spacing: 8px;
                }}
                QCheckBox::indicator {{
                    width: 16px;
                    height: 16px;
                    border-radius: 3px;
                }}
                QCheckBox::indicator:unchecked {{
                    background: {TokyoNight.SELECTION};
                    border: 1px solid {TokyoNight.NEBULA};
                }}
                QCheckBox::indicator:checked {{
                    background: {TokyoNight.BLUE};
                    border: 1px solid {TokyoNight.BLUE};
                }}
                QCheckBox:hover {{
                    color: {TokyoNight.BRIGHT_WHITE};
                }}
            """)
            setattr(self, attr, checkbox)
            modules_scroll_layout.addWidget(checkbox)
        
        modules_scroll_layout.addStretch()
        scroll.setWidget(modules_widget)
        modules_layout.addWidget(scroll)

        # Weather settings tab
        weather_tab = QWidget()
        weather_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        weather_layout = QFormLayout(weather_tab)
        weather_layout.setContentsMargins(8, 8, 8, 8)
        weather_layout.setSpacing(6)
        
        self.weather_location_edit = QLineEdit()
        self.weather_location_edit.setPlaceholderText("Leave empty for auto-detection")
        self.weather_location_edit.setText(self.config.weather_location)
        weather_layout.addRow("Location:", self.weather_location_edit)
        
        weather_info = QLabel("Weather data from wttr.in")
        weather_info.setStyleSheet(f"color: {TokyoNight.COMMENT}; font-size: 8pt;")
        weather_layout.addRow(weather_info)

        # Launchers tab - FIXED VERSION
        launchers_tab = QWidget()
        launchers_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        launchers_layout = QVBoxLayout(launchers_tab)
        launchers_layout.setContentsMargins(8, 8, 8, 8)
        launchers_layout.setSpacing(6)
        
        instructions = QLabel("Manage your custom application launchers:")
        instructions.setStyleSheet(f"color: {TokyoNight.FOREGROUND}; margin-bottom: 5px; font-size: 9pt;")
        launchers_layout.addWidget(instructions)
        
        # List of launchers
        self.launchers_list = QListWidget()
        self.launchers_list.setMaximumHeight(150)
        self.launchers_list.setStyleSheet(f"""
            QListWidget {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 4px;
                padding: 3px;
            }}
            QListWidget::item {{
                padding: 8px;
                border-radius: 3px;
                font-size: 9pt;
                border-bottom: 1px solid {TokyoNight.NEBULA}40;
            }}
            QListWidget::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
            QListWidget::item:hover {{
                background: {TokyoNight.BLUE}20;
            }}
        """)
        launchers_layout.addWidget(self.launchers_list)
        
        # Buttons for launcher management
        buttons_layout = QHBoxLayout()
        
        add_btn = QPushButton("Û∞êï Add")
        add_btn.setFixedHeight(32)
        add_btn.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.GREEN}, 
                    stop:1 {TokyoNight.BRIGHT_GREEN});
                color: {TokyoNight.BACKGROUND};
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BRIGHT_GREEN}, 
                    stop:1 {TokyoNight.GREEN});
            }}
        """)
        add_btn.clicked.connect(self.add_launcher)
        buttons_layout.addWidget(add_btn)
        
        edit_btn = QPushButton("Û∞è´ Edit")
        edit_btn.setFixedHeight(32)
        edit_btn.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.PURPLE}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """)
        edit_btn.clicked.connect(self.edit_launcher)
        buttons_layout.addWidget(edit_btn)
        
        remove_btn = QPushButton("Û∞Ü¥ Remove")
        remove_btn.setFixedHeight(32)
        remove_btn.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.RED}, 
                    stop:1 {TokyoNight.BRIGHT_RED});
                color: {TokyoNight.BACKGROUND};
                border: none;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BRIGHT_RED}, 
                    stop:1 {TokyoNight.RED});
            }}
        """)
        remove_btn.clicked.connect(self.remove_launcher)
        buttons_layout.addWidget(remove_btn)
        
        buttons_layout.addStretch()
        launchers_layout.addLayout(buttons_layout)
        
        # Info label
        info_label = QLabel("Launchers will appear in the applications menu and panel context menu")
        info_label.setStyleSheet(f"color: {TokyoNight.COMMENT}; font-size: 8pt; margin-top: 8px;")
        launchers_layout.addWidget(info_label)
        
        # Load existing launchers
        self.load_launchers()
        
        # Connect double-click to edit
        self.launchers_list.itemDoubleClicked.connect(self.edit_launcher)

        # Built-in launchers tab
        builtin_tab = QWidget()
        builtin_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        builtin_layout = QFormLayout(builtin_tab)
        builtin_layout.setContentsMargins(8, 8, 8, 8)
        builtin_layout.setSpacing(6)
        
        builtin_title = QLabel("Configure built-in application launchers:")
        builtin_title.setStyleSheet(f"color: {TokyoNight.FOREGROUND}; font-weight: bold; margin-bottom: 8px; font-size: 9pt;")
        builtin_layout.addRow(builtin_title)
        
        # Group common applications
        apps = [
            ("Terminal:", "terminal_edit", self.config.terminal_command, "xfce4-terminal, gnome-terminal, konsole"),
            ("File Manager:", "file_manager_edit", self.config.file_manager_command, "thunar, nautilus, dolphin"),
            ("Web Browser:", "browser_edit", self.config.browser_command, "firefox, chromium, google-chrome"),
            ("Text Editor:", "text_editor_edit", self.config.text_editor_command, "mousepad, gedit, kate"),
            ("Settings:", "settings_edit", self.config.settings_command, "xfce4-settings-manager, gnome-control-center"),
            ("Calculator:", "calculator_edit", self.config.calculator_command, "gnome-calculator, kcalc"),
            ("Screenshot:", "screenshot_edit", self.config.screenshot_command, "xfce4-screenshooter, gnome-screenshot"),
            ("Image Viewer:", "image_viewer_edit", self.config.image_viewer_command, "ristretto, eog, gwenview"),
            ("Music Player:", "music_player_edit", self.config.music_player_command, "vlc, mpv, audacious"),
        ]
        
        for label, attr, value, placeholder in apps:
            edit = QLineEdit(value)
            edit.setPlaceholderText(placeholder)
            edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
            setattr(self, attr, edit)
            builtin_layout.addRow(label, edit)
        
        # Music Player Arguments
        self.music_player_args_edit = QLineEdit()
        self.music_player_args_edit.setText(self.config.music_player_args)
        self.music_player_args_edit.setPlaceholderText("Optional arguments for music player")
        self.music_player_args_edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
        builtin_layout.addRow("Music Player Args:", self.music_player_args_edit)

        # Clock & Date tab
        clock_tab = QWidget()
        clock_tab.setStyleSheet(f"background: {TokyoNight.NIGHT_BOTTOM};")
        clock_layout = QFormLayout(clock_tab)
        clock_layout.setContentsMargins(8, 8, 8, 8)
        clock_layout.setSpacing(6)
        
        # Font sizes in a compact row
        font_sizes_layout = QHBoxLayout()
        self.clock_font_size_spin = QSpinBox()
        self.clock_font_size_spin.setRange(8, 20)
        self.clock_font_size_spin.setValue(self.config.clock_font_size)
        self.clock_font_size_spin.setPrefix("Clock: ")
        self.clock_font_size_spin.setSuffix("pt")
        font_sizes_layout.addWidget(self.clock_font_size_spin)
        
        self.date_font_size_spin = QSpinBox()
        self.date_font_size_spin.setRange(6, 16)
        self.date_font_size_spin.setValue(self.config.date_font_size)
        self.date_font_size_spin.setPrefix("Date: ")
        self.date_font_size_spin.setSuffix("pt")
        font_sizes_layout.addWidget(self.date_font_size_spin)
        
        font_sizes_layout.addStretch()
        clock_layout.addRow("Font Sizes:", font_sizes_layout)
        
        # Colors in a compact row
        colors_layout = QHBoxLayout()
        self.clock_color_edit = QLineEdit(self.config.clock_color)
        self.clock_color_edit.setPlaceholderText("Clock color")
        self.clock_color_edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
        clock_color_btn = QPushButton("...")
        clock_color_btn.setFixedSize(30, 25)
        clock_color_btn.clicked.connect(lambda: self.pick_color(self.clock_color_edit))
        colors_layout.addWidget(QLabel("Clock:"))
        colors_layout.addWidget(self.clock_color_edit)
        colors_layout.addWidget(clock_color_btn)
        
        self.date_color_edit = QLineEdit(self.config.date_color)
        self.date_color_edit.setPlaceholderText("Date color")
        self.date_color_edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
        date_color_btn = QPushButton("...")
        date_color_btn.setFixedSize(30, 25)
        date_color_btn.clicked.connect(lambda: self.pick_color(self.date_color_edit))
        colors_layout.addWidget(QLabel("Date:"))
        colors_layout.addWidget(self.date_color_edit)
        colors_layout.addWidget(date_color_btn)
        
        clock_layout.addRow("Colors:", colors_layout)
        
        # Font weights in a compact row
        weights_layout = QHBoxLayout()
        self.clock_font_weight_combo = QComboBox()
        self.clock_font_weight_combo.addItems(["normal", "bold", "light"])
        self.clock_font_weight_combo.setCurrentText(self.config.clock_font_weight)
        weights_layout.addWidget(QLabel("Clock:"))
        weights_layout.addWidget(self.clock_font_weight_combo)
        
        self.date_font_weight_combo = QComboBox()
        self.date_font_weight_combo.addItems(["normal", "bold", "light"])
        self.date_font_weight_combo.setCurrentText(self.config.date_font_weight)
        weights_layout.addWidget(QLabel("Date:"))
        weights_layout.addWidget(self.date_font_weight_combo)
        
        weights_layout.addStretch()
        clock_layout.addRow("Font Weight:", weights_layout)
        
        # Show seconds
        self.show_seconds_check = QCheckBox("Show Seconds in Clock")
        self.show_seconds_check.setChecked(self.config.show_seconds)
        clock_layout.addRow(self.show_seconds_check)
        
        # Date format
        self.date_format_combo = QComboBox()
        self.date_format_combo.addItems([
            "Mon Jan 1",
            "Monday, January 1", 
            "01/01/2024",
            "01-01-2024",
            "2024-01-01",
            "Custom..."
        ])
        if self.config.date_format in ["ddd MMM d", "dddd, MMMM d", "MM/dd/yyyy", "dd-MM-yyyy", "yyyy-MM-dd"]:
            format_map = {
                "ddd MMM d": "Mon Jan 1",
                "dddd, MMMM d": "Monday, January 1",
                "MM/dd/yyyy": "01/01/2024", 
                "dd-MM-yyyy": "01-01-2024",
                "yyyy-MM-dd": "2024-01-01"
            }
            self.date_format_combo.setCurrentText(format_map.get(self.config.date_format, "Mon Jan 1"))
        else:
            self.date_format_combo.setCurrentText("Custom...")
        self.custom_date_edit = QLineEdit(self.config.date_format)
        self.custom_date_edit.setPlaceholderText("Custom date format")
        self.custom_date_edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
        clock_layout.addRow("Date Format:", self.date_format_combo)
        clock_layout.addRow("Custom Format:", self.custom_date_edit)
        
        # Time format  
        self.time_format_combo = QComboBox()
        self.time_format_combo.addItems([
            "12:00 PM",
            "24:00",
            "12:00:00 PM",
            "24:00:00",
            "Custom..."
        ])
        format_map = {
            "hh:mm AP": "12:00 PM",
            "HH:mm": "24:00",
            "hh:mm:ss AP": "12:00:00 PM",
            "HH:mm:ss": "24:00:00"
        }
        if self.config.time_format in format_map:
            self.time_format_combo.setCurrentText(format_map[self.config.time_format])
        else:
            self.time_format_combo.setCurrentText("Custom...")
        self.custom_time_edit = QLineEdit(self.config.time_format)
        self.custom_time_edit.setPlaceholderText("Custom time format")
        self.custom_time_edit.setStyleSheet(f"font-size: 9pt; background: {TokyoNight.SELECTION}; color: {TokyoNight.FOREGROUND}; border: 1px solid {TokyoNight.NEBULA}; border-radius: 3px; padding: 4px;")
        clock_layout.addRow("Time Format:", self.time_format_combo)
        clock_layout.addRow("Custom Format:", self.custom_time_edit)
        
        # Format help
        help_label = QLabel("Format codes: d=day, M=month, y=year, h=hour, m=minute, s=second, AP=AM/PM")
        help_label.setStyleSheet(f"color: {TokyoNight.COMMENT}; font-size: 7pt; margin-top: 8px;")
        clock_layout.addRow(help_label)

        # Add tabs
        tabs.addTab(appearance_tab, "Appearance")
        tabs.addTab(modules_tab, "Modules") 
        tabs.addTab(weather_tab, "Weather")
        tabs.addTab(launchers_tab, "Custom Launchers")
        tabs.addTab(builtin_tab, "Built-in")
        tabs.addTab(clock_tab, "Clock")

        layout.addWidget(tabs)

        # Buttons
        button_layout = QHBoxLayout()
        save_btn = QPushButton("Save Settings")
        save_btn.setFixedHeight(32)
        save_btn.clicked.connect(self.save_settings)
        cancel_btn = QPushButton("Cancel")  
        cancel_btn.setFixedHeight(32)
        cancel_btn.clicked.connect(self.reject)
        button_layout.addWidget(save_btn)
        button_layout.addWidget(cancel_btn)
        layout.addLayout(button_layout)

        self.setLayout(layout)

    def load_launchers(self):
        """Load existing launchers into the list"""
        self.launchers_list.clear()
        if self.config.launcher_customizations:
            for launcher in self.config.launcher_customizations:
                # Create a descriptive item text
                workspace_info = "Current" if launcher.workspace == -1 else f"WS{launcher.workspace + 1}"
                item_text = f"{launcher.icon} {launcher.name} ‚Üí {launcher.command}"
                if launcher.args:
                    item_text += f" {launcher.args}"
                item_text += f" [{workspace_info}]"
                
                item = QListWidgetItem(item_text)
                item.setData(Qt.UserRole, launcher)
                self.launchers_list.addItem(item)
        print(f"DEBUG: Loaded {self.launchers_list.count()} launchers")

    def add_launcher(self):
        """Add a new launcher"""
        print("DEBUG: Add launcher clicked")
        dialog = LauncherDialog(self)
        if dialog.exec_() == QDialog.Accepted:
            launcher = dialog.get_launcher()
            if launcher and launcher.name and launcher.command:
                # Add to list
                workspace_info = "Current" if launcher.workspace == -1 else f"WS{launcher.workspace + 1}"
                item_text = f"{launcher.icon} {launcher.name} ‚Üí {launcher.command}"
                if launcher.args:
                    item_text += f" {launcher.args}"
                item_text += f" [{workspace_info}]"
                
                item = QListWidgetItem(item_text)
                item.setData(Qt.UserRole, launcher)
                self.launchers_list.addItem(item)
                print(f"DEBUG: Added launcher: {launcher.name}")
            else:
                QMessageBox.warning(self, "Invalid Launcher", "Please provide both name and command for the launcher.")

    def edit_launcher(self):
        """Edit selected launcher"""
        current_item = self.launchers_list.currentItem()
        if not current_item:
            QMessageBox.information(self, "No Selection", "Please select a launcher to edit.")
            return
        
        launcher = current_item.data(Qt.UserRole)
        if not launcher:
            return
            
        print(f"DEBUG: Editing launcher: {launcher.name}")
        dialog = LauncherDialog(self, launcher)
        if dialog.exec_() == QDialog.Accepted:
            updated_launcher = dialog.get_launcher()
            if updated_launcher and updated_launcher.name and updated_launcher.command:
                # Update the list item
                workspace_info = "Current" if updated_launcher.workspace == -1 else f"WS{updated_launcher.workspace + 1}"
                item_text = f"{updated_launcher.icon} {updated_launcher.name} ‚Üí {updated_launcher.command}"
                if updated_launcher.args:
                    item_text += f" {updated_launcher.args}"
                item_text += f" [{workspace_info}]"
                
                current_item.setText(item_text)
                current_item.setData(Qt.UserRole, updated_launcher)
                print(f"DEBUG: Updated launcher: {updated_launcher.name}")
            else:
                QMessageBox.warning(self, "Invalid Launcher", "Please provide both name and command for the launcher.")

    def remove_launcher(self):
        """Remove selected launcher"""
        current_item = self.launchers_list.currentItem()
        if not current_item:
            QMessageBox.information(self, "No Selection", "Please select a launcher to remove.")
            return
            
        launcher = current_item.data(Qt.UserRole)
        if launcher:
            reply = QMessageBox.question(
                self, "Confirm Removal", 
                f"Are you sure you want to remove '{launcher.name}'?",
                QMessageBox.Yes | QMessageBox.No,
                QMessageBox.No
            )
            if reply == QMessageBox.Yes:
                row = self.launchers_list.row(current_item)
                self.launchers_list.takeItem(row)
                print(f"DEBUG: Removed launcher: {launcher.name}")

    def pick_color(self, line_edit):
        """Open color picker dialog"""
        current_color = QColor(line_edit.text())
        color = QColorDialog.getColor(current_color, self, "Choose Color")
        if color.isValid():
            line_edit.setText(color.name())

    def save_settings(self):
        """Save all settings including clock customization"""
        # Save appearance settings
        self.config.position = self.position_combo.currentText()
        self.config.height = self.height_spin.value()
        self.config.opacity = self.opacity_slider.value() / 100.0
        self.config.theme_variant = self.theme_combo.currentText()
        self.config.rounded_corners = self.rounded_corners_check.isChecked()
        self.config.corner_radius = self.corner_radius_spin.value()
        
        # Save module visibility settings
        self.config.show_date = self.show_date_check.isChecked()
        self.config.show_battery = self.show_battery_check.isChecked()
        self.config.show_volume = self.show_volume_check.isChecked()
        self.config.show_network = self.show_network_check.isChecked()
        self.config.show_tray = self.show_tray_check.isChecked()
        self.config.show_xfce_launchers = self.show_xfce_launchers_check.isChecked()
        self.config.show_workspace_switcher = self.show_workspace_switcher_check.isChecked()
        self.config.show_brightness_control = self.show_brightness_control_check.isChecked()
        self.config.show_weather = self.show_weather_check.isChecked()
        self.config.show_notifications = self.show_notifications_check.isChecked()
        self.config.show_network_control = self.show_network_control_check.isChecked()
        self.config.show_bluetooth_control = self.show_bluetooth_control_check.isChecked()
        # NEW: Tiling control
        self.config.show_tiling_control = self.show_tiling_control_check.isChecked()
        
        # Save weather settings
        self.config.weather_location = self.weather_location_edit.text()
        
        # Save auto-hide settings
        self.config.auto_hide = self.auto_hide_check.isChecked()
        self.config.auto_hide_delay = self.auto_hide_delay_spin.value()
        self.config.show_on_edge = self.show_on_edge_check.isChecked()
        self.config.edge_size = self.edge_size_spin.value()
        
        # Save built-in launcher commands
        self.config.terminal_command = self.terminal_edit.text()
        self.config.file_manager_command = self.file_manager_edit.text()
        self.config.browser_command = self.browser_edit.text()
        self.config.text_editor_command = self.text_editor_edit.text()
        self.config.settings_command = self.settings_edit.text()
        self.config.calculator_command = self.calculator_edit.text()
        self.config.screenshot_command = self.screenshot_edit.text()
        self.config.image_viewer_command = self.image_viewer_edit.text()
        self.config.music_player_command = self.music_player_edit.text()
        self.config.music_player_args = self.music_player_args_edit.text()
        
        # Save clock settings
        self.config.clock_font_size = self.clock_font_size_spin.value()
        self.config.date_font_size = self.date_font_size_spin.value()
        self.config.clock_color = self.clock_color_edit.text()
        self.config.date_color = self.date_color_edit.text()
        self.config.clock_font_weight = self.clock_font_weight_combo.currentText()
        self.config.date_font_weight = self.date_font_weight_combo.currentText()
        self.config.show_seconds = self.show_seconds_check.isChecked()
        
        # Handle date/time formats
        if self.date_format_combo.currentText() == "Custom...":
            self.config.date_format = self.custom_date_edit.text()
        else:
            self.config.date_format = self.date_format_combo.currentText()
            
        if self.time_format_combo.currentText() == "Custom...":
            self.config.time_format = self.custom_time_edit.text()
        else:
            self.config.time_format = self.time_format_combo.currentText()
        
        # CRITICAL FIX: Save custom launchers properly
        custom_launchers = []
        for i in range(self.launchers_list.count()):
            item = self.launchers_list.item(i)
            if item:
                launcher = item.data(Qt.UserRole)
                if launcher:
                    custom_launchers.append(launcher)
        
        self.config.launcher_customizations = custom_launchers
        print(f"DEBUG: Saved {len(custom_launchers)} custom launchers to config")
        
        self.accept()

    def get_stylesheet(self):
        return f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QTabWidget::pane {{
                border: 1px solid {TokyoNight.SELECTION};
                background: {TokyoNight.NIGHT_BOTTOM};
                border-radius: 6px;
            }}
            QTabBar::tab {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                padding: 8px 16px;
                margin-right: 2px;
                border-top-left-radius: 6px;
                border-top-right-radius: 6px;
            }}
            QTabBar::tab:selected {{
                background: {TokyoNight.BLUE};
            }}
            QCheckBox {{
                color: {TokyoNight.FOREGROUND};
                spacing: 8px;
            }}
            QCheckBox::indicator {{
                width: 16px;
                height: 16px;
                border-radius: 3px;
            }}
            QCheckBox::indicator:unchecked {{
                background: {TokyoNight.SELECTION};
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QCheckBox::indicator:checked {{
                background: {TokyoNight.BLUE};
                border: 1px solid {TokyoNight.BLUE};
            }}
            QComboBox, QSpinBox, QSlider, QLineEdit {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                padding: 5px;
                border-radius: 3px;
            }}
            QLineEdit {{
                padding: 6px;
            }}
            QComboBox::drop-down {{
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 15px;
                border-left-width: 1px;
                border-left-color: {TokyoNight.NEBULA};
                border-left-style: solid;
                border-top-right-radius: 3px;
                border-bottom-right-radius: 3px;
                background-color: {TokyoNight.SELECTION};
            }}
            QComboBox::down-arrow {{
                image: none;
                border-left: 5px solid transparent;
                border-right: 5px solid transparent;
                border-top: 5px solid {TokyoNight.FOREGROUND};
                margin-right: 5px;
            }}
            QComboBox QAbstractItemView {{
                background: {TokyoNight.NIGHT_BOTTOM};
                color: {TokyoNight.FOREGROUND};
                selection-background-color: {TokyoNight.BLUE};
                selection-color: {TokyoNight.BACKGROUND};
                border: 1px solid {TokyoNight.SELECTION};
                border-radius: 4px;
            }}
            QSpinBox::up-button, QSpinBox::down-button {{
                subcontrol-origin: border;
                width: 16px;
                border-radius: 2px;
            }}
            QSpinBox::up-button {{
                subcontrol-position: top right;
            }}
            QSpinBox::down-button {{
                subcontrol-position: bottom right;
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
            QFormLayout {{
                color: {TokyoNight.FOREGROUND};
            }}
            QLabel {{
                color: {TokyoNight.FOREGROUND};
            }}
        """

    def save_settings(self):
        """Save all settings including built-in launcher commands and custom launchers"""
        # Save appearance settings
        self.config.position = self.position_combo.currentText()
        self.config.height = self.height_spin.value()
        self.config.opacity = self.opacity_slider.value() / 100.0
        self.config.theme_variant = self.theme_combo.currentText()
        self.config.rounded_corners = self.rounded_corners_check.isChecked()
        self.config.corner_radius = self.corner_radius_spin.value()
        
        # Save module visibility settings
        self.config.show_date = self.show_date_check.isChecked()
        self.config.show_battery = self.show_battery_check.isChecked()
        self.config.show_volume = self.show_volume_check.isChecked()
        self.config.show_network = self.show_network_check.isChecked()
        self.config.show_tray = self.show_tray_check.isChecked()
        self.config.show_xfce_launchers = self.show_xfce_launchers_check.isChecked()
        self.config.show_workspace_switcher = self.show_workspace_switcher_check.isChecked()
        self.config.show_brightness_control = self.show_brightness_control_check.isChecked()
        self.config.show_weather = self.show_weather_check.isChecked()
        self.config.show_notifications = self.show_notifications_check.isChecked()
        self.config.show_network_control = self.show_network_control_check.isChecked()
        self.config.show_bluetooth_control = self.show_bluetooth_control_check.isChecked()
        # NEW: Tiling control
        self.config.show_tiling_control = self.show_tiling_control_check.isChecked()
        
        # Save weather settings
        self.config.weather_location = self.weather_location_edit.text()
        
        # Save auto-hide settings
        self.config.auto_hide = self.auto_hide_check.isChecked()
        self.config.auto_hide_delay = self.auto_hide_delay_spin.value()
        self.config.show_on_edge = self.show_on_edge_check.isChecked()
        self.config.edge_size = self.edge_size_spin.value()
        
        # Save built-in launcher commands
        self.config.terminal_command = self.terminal_edit.text()
        self.config.file_manager_command = self.file_manager_edit.text()
        self.config.browser_command = self.browser_edit.text()
        self.config.text_editor_command = self.text_editor_edit.text()
        self.config.settings_command = self.settings_edit.text()
        self.config.calculator_command = self.calculator_edit.text()
        self.config.screenshot_command = self.screenshot_edit.text()
        self.config.image_viewer_command = self.image_viewer_edit.text()
        self.config.music_player_command = self.music_player_edit.text()
        self.config.music_player_args = self.music_player_args_edit.text()
        
        # CRITICAL FIX: Save custom launchers properly
        custom_launchers = []
        for i in range(self.launchers_list.count()):
            item = self.launchers_list.item(i)
            if item:
                launcher = item.data(Qt.UserRole)
                if launcher:
                    custom_launchers.append(launcher)
        
        self.config.launcher_customizations = custom_launchers
        print(f"DEBUG: Saved {len(custom_launchers)} custom launchers")  # Debug line
        
        self.accept()

class TokyoNightPanelBar(QMainWindow):
    def __init__(self, config: PanelConfig):
        super().__init__()
        self.config = config
        self.applications = []
        self.window_buttons = {}
        self.xfce_launchers = []
        self.workspace_buttons = []
        self.notification_count = 0
        self.current_workspace = 0
        self.active_window_id = ""
        
        # Auto-hide properties
        self.auto_hide_timer = QTimer()
        self.auto_hide_timer.setSingleShot(True)
        self.auto_hide_timer.timeout.connect(self.hide_panel)
        self.is_hidden = False
        self.edge_detection_timer = QTimer()
        self.edge_detection_timer.timeout.connect(self.check_mouse_position)
        self.edge_detection_timer.start(100)  # Check every 100ms
        
        self.setup_ui()
        self.load_applications()
        self.load_xfce_launchers()
        self.setup_system_monitor()
        self.start_timers()
        self.setup_strut()
        # Enable context menu for the entire panel
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.show_panel_context_menu)
        
        # Set up mouse tracking for auto-hide
        self.setMouseTracking(True)
        QApplication.instance().installEventFilter(self)
        
        # Start auto-hide if enabled
        if self.config.auto_hide:
            self.auto_hide_timer.start(self.config.auto_hide_delay)

    def setup_ui(self):
        """Setup the main panel UI with enhanced dark night theme"""
        # Window configuration
        self.setWindowTitle("Tokyo Night Panel")
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Tool)
        # Set opacity
        self.setWindowOpacity(self.config.opacity)
        # Apply stylesheet
        self.setStyleSheet(self.get_stylesheet())
        # Central widget with night sky background
        central_widget = NightSkyWidget()
        central_widget.setObjectName("centralwidget")
        self.setCentralWidget(central_widget)
        # === NEW LAYOUT STRUCTURE FOR FULL WIDTH ===
        # Main layout - ensure it expands fully
        layout = QHBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)  # Remove margins for full width
        layout.setSpacing(0)  # Remove spacing
        # Left section - allow it to expand
        self.left_widget = QWidget()
        left_layout = QHBoxLayout(self.left_widget)
        left_layout.setContentsMargins(10, 5, 10, 5)  # Keep some internal padding
        left_layout.setSpacing(6)
        # Applications menu button
        self.apps_button = QToolButton()
        self.apps_button.setText("Û∞Äª")  # nf-linux-arch icon
        self.apps_button.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.apps_button.setPopupMode(QToolButton.InstantPopup)
        self.apps_button.setMenu(self.create_applications_menu())
        self.apps_button.setFixedSize(32, 32)
        left_layout.addWidget(self.apps_button)
        # Separator
        sep1 = QFrame()
        sep1.setFrameShape(QFrame.VLine)
        sep1.setFrameShadow(QFrame.Sunken)
        left_layout.addWidget(sep1)
        # Workspace switcher
        if self.config.show_workspace_switcher:
            self.setup_workspace_switcher(left_layout)
            sep_ws = QFrame()
            sep_ws.setFrameShape(QFrame.VLine)
            sep_ws.setFrameShadow(QFrame.Sunken)
            left_layout.addWidget(sep_ws)
        # XFCE Launchers area
        self.xfce_launchers_widget = QWidget()
        self.xfce_launchers_layout = QHBoxLayout(self.xfce_launchers_widget)
        self.xfce_launchers_layout.setContentsMargins(0, 0, 0, 0)
        self.xfce_launchers_layout.setSpacing(4)
        self.xfce_launchers_widget.setVisible(self.config.show_xfce_launchers)
        left_layout.addWidget(self.xfce_launchers_widget)
        # Separator
        sep2 = QFrame()
        sep2.setFrameShape(QFrame.VLine)
        sep2.setFrameShadow(QFrame.Sunken)
        sep2.setVisible(self.config.show_xfce_launchers)
        left_layout.addWidget(sep2)
        # === FIXED TASKBAR SECTION - NOW EXPANDS PROPERLY ===
        # Taskbar area with scroll support - NOW EXPANDS TO FILL AVAILABLE SPACE
        self.taskbar_container = QWidget()
        self.taskbar_container.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Changed to Expanding
        taskbar_container_layout = QHBoxLayout(self.taskbar_container)
        taskbar_container_layout.setContentsMargins(0, 0, 0, 0)
        taskbar_container_layout.setSpacing(0)
        # Create scroll area for taskbar
        self.taskbar_scroll = QScrollArea()
        self.taskbar_scroll.setWidgetResizable(True)
        self.taskbar_scroll.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.taskbar_scroll.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.taskbar_scroll.setFrameShape(QFrame.NoFrame)
        self.taskbar_scroll.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Added expanding policy
        self.taskbar_scroll.setStyleSheet(f"""
            QScrollArea {{
                background: transparent;
                border: none;
            }}
            QScrollBar:horizontal {{
                background: {TokyoNight.SELECTION};
                height: 6px;
                border-radius: 3px;
            }}
            QScrollBar::handle:horizontal {{
                background: {TokyoNight.BLUE};
                border-radius: 3px;
                min-width: 20px;
            }}
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {{
                border: none;
                background: none;
            }}
        """)
        # Create taskbar widget
        self.taskbar_widget = QWidget()
        self.taskbar_widget.setStyleSheet(f"background: transparent;")
        self.taskbar_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)  # Added expanding policy
        self.taskbar_layout = QHBoxLayout(self.taskbar_widget)
        self.taskbar_layout.setContentsMargins(0, 0, 0, 0)
        self.taskbar_layout.setSpacing(4)
        self.taskbar_layout.setAlignment(Qt.AlignLeft)
        # Set the taskbar widget as the scroll area's widget
        self.taskbar_scroll.setWidget(self.taskbar_widget)
        taskbar_container_layout.addWidget(self.taskbar_scroll)
        # Add taskbar container to left layout WITH STRETCH FACTOR
        left_layout.addWidget(self.taskbar_container, 1)  # This makes it expand

        # Center section - fixed width
        self.center_widget = QWidget()
        center_layout = QVBoxLayout(self.center_widget)
        center_layout.setContentsMargins(15, 0, 15, 0)
        center_layout.setSpacing(0)
        self.clock_label = QLabel("00:00")
        self.clock_label.setAlignment(Qt.AlignCenter)
        
        self.date_label = QLabel("Mon Jan 1")
        self.date_label.setAlignment(Qt.AlignCenter)
        self.date_label.setVisible(self.config.show_date)
        
        # Apply initial styles
        self.update_clock_styles()
        
        center_layout.addWidget(self.clock_label)
        center_layout.addWidget(self.date_label)

        # Right section - fixed width
        self.right_widget = QWidget()
        right_layout = QHBoxLayout(self.right_widget)
        right_layout.setContentsMargins(0, 0, 10, 0)  # Right margin only
        right_layout.setSpacing(8)
        # Notification center
        if self.config.show_notifications:
            self.setup_notification_center(right_layout)
        # Weather widget
        if self.config.show_weather:
            self.setup_weather_widget(right_layout)
        # System monitors
        self.cpu_label = QLabel("Û∞çõ 0%")
        self.mem_label = QLabel("Û∞òö 0%")
        # Apply styling to labels
        for label in [self.cpu_label, self.mem_label]:
            label.setStyleSheet(f"""
                padding: 4px 8px;
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                border-radius: 6px;
                font-size: 9pt;
                color: {TokyoNight.FOREGROUND};
            """)
        right_layout.addWidget(self.cpu_label)
        right_layout.addWidget(self.mem_label)
        # Brightness control
        if self.config.show_brightness_control:
            self.setup_brightness_control(right_layout)
        # Volume control widget
        if self.config.show_volume:
            self.volume_control = VolumeControlWidget(self)
            right_layout.addWidget(self.volume_control)
        # Network Manager control
        if self.config.show_network_control:
            self.network_control = NetworkManagerWidget(self)
            right_layout.addWidget(self.network_control)
        # Bluetooth Manager control  
        if self.config.show_bluetooth_control:
            self.bluetooth_control = BluetoothManagerWidget(self)
            right_layout.addWidget(self.bluetooth_control)
        # NEW: Tiling control
        if self.config.show_tiling_control:
            self.tiling_control = TilingControlWidget(self)
            right_layout.addWidget(self.tiling_control)
        if self.config.show_battery:
            self.battery_label = QLabel("Û∞Åπ 0%")
            self.battery_label.setStyleSheet(f"""
                padding: 4px 8px;
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                border-radius: 6px;
                font-size: 9pt;
                color: {TokyoNight.FOREGROUND};
            """)
            right_layout.addWidget(self.battery_label)
        if self.config.show_network:
            self.network_label = QLabel("Û∞ñ© --")
            self.network_label.setStyleSheet(f"""
                padding: 4px 8px;
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                border-radius: 6px;
                font-size: 9pt;
                color: {TokyoNight.FOREGROUND};
            """)
            right_layout.addWidget(self.network_label)
        # System tray area
        if self.config.show_tray:
            self.tray_widget = SystemTrayWidget(self)
            self.tray_widget.setMaximumWidth(200)
            right_layout.addWidget(self.tray_widget)
            # Separator before system menu
            sep3 = QFrame()
            sep3.setFrameShape(QFrame.VLine)
            sep3.setFrameShadow(QFrame.Sunken)
            right_layout.addWidget(sep3)
        
        # System menu button
        self.system_button = QToolButton()
        self.system_button.setText("Û∞ÄΩ")
        self.system_button.setToolButtonStyle(Qt.ToolButtonIconOnly)
        self.system_button.setPopupMode(QToolButton.InstantPopup)
        self.system_button.setMenu(self.create_system_menu())
        self.system_button.setFixedSize(32, 32)
        right_layout.addWidget(self.system_button)
        
        # Add all sections to main layout WITH PROPER STRETCH FACTORS
        layout.addWidget(self.left_widget, 1)  # Left section expands
        layout.addWidget(self.center_widget, 0)  # Center section fixed width
        layout.addWidget(self.right_widget, 0)  # Right section fixed width
        
        # Set initial geometry
        self.update_panel_geometry()





    def toggle_tiling(self):
        """Toggle window tiling"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.toggle_tiling()

    def set_tiling_layout(self, layout_name):
        """Set specific tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.set_layout(layout_name)

    def cycle_tiling_layout(self):
        """Cycle to next tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.cycle_layout()

    def set_tiling_master(self):
        """Set currently focused window as master"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.set_master()

    def force_apply_tiling(self):
        """Force apply tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.force_apply_layout()

    def toggle_auto_tile(self):
        """Toggle auto-tiling"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.tiler.toggle_auto_tile()
            self.tiling_control.update_display()

    def refresh_layout(self):
        """Refresh the current layout to fix alignment issues"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.refresh_layout()

    def correct_alignment(self):
        """Correct alignment for all windows"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.correct_alignment()

    def restart_tiler(self):
        """Restart the tiler"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.restart_tiler()













    def edit_custom_launchers(self):
        """Edit custom launchers in a dialog"""
        if not hasattr(self, 'custom_apps') or not self.custom_apps:
            QMessageBox.information(self, "No Launchers", "No custom launchers to edit.")
            return
        
        dialog = QDialog(self)
        dialog.setWindowTitle("Edit Custom Launchers")
        dialog.setFixedSize(500, 400)
        dialog.setStyleSheet(f"""
            QDialog {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border-radius: 8px;
                border: 1px solid {TokyoNight.NEBULA};
            }}
            QListWidget {{
                background: {TokyoNight.SELECTION};
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 4px;
                padding: 5px;
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 8px 16px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
        """)
        
        layout = QVBoxLayout(dialog)
        
        # List widget to display current launchers
        list_widget = QListWidget()
        for name, command, icon in self.custom_apps:
            item = QListWidgetItem(f"{name} ‚Üí {command}")
            list_widget.addItem(item)
        
        layout.addWidget(QLabel("Current Custom Launchers:"))
        layout.addWidget(list_widget)
        
        # Buttons layout
        buttons_layout = QHBoxLayout()
        
        add_btn = QPushButton("Û∞êï Add")
        add_btn.clicked.connect(lambda: self.add_from_edit_dialog(dialog))
        buttons_layout.addWidget(add_btn)
        
        remove_btn = QPushButton("Û∞Ü¥ Remove")
        remove_btn.clicked.connect(lambda: self.remove_launcher_from_list(list_widget))
        buttons_layout.addWidget(remove_btn)
        
        edit_btn = QPushButton("Û∞è´ Edit")
        edit_btn.clicked.connect(lambda: self.edit_launcher_in_list(list_widget))
        buttons_layout.addWidget(edit_btn)
        
        buttons_layout.addStretch()
        
        close_btn = QPushButton("Close")
        close_btn.clicked.connect(dialog.accept)
        buttons_layout.addWidget(close_btn)
        
        layout.addLayout(buttons_layout)
        dialog.exec_()




    def force_apply_tiling(self):
        """Force apply tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.force_apply_layout()

    def toggle_auto_tile(self):
        """Toggle auto-tiling"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.tiler.toggle_auto_tile()
            self.tiling_control.update_display()




    def update_clock_styles(self):
        """Update clock and date styles based on configuration"""
        # Clock style
        clock_style = f"""
            font-size: {self.config.clock_font_size}pt;
            color: {self.config.clock_color};
            background: transparent;
        """
        if self.config.clock_font_weight == "bold":
            clock_style += "font-weight: bold;"
        elif self.config.clock_font_weight == "light":
            clock_style += "font-weight: 300;"
        
        # Add text shadow for better visibility
        clock_style += f"text-shadow: 0px 0px 5px {self.config.clock_color}40;"
        
        self.clock_label.setStyleSheet(clock_style)
        
        # Date style
        date_style = f"""
            font-size: {self.config.date_font_size}pt;
            color: {self.config.date_color};
            background: transparent;
            opacity: 0.9;
        """
        if self.config.date_font_weight == "bold":
            date_style += "font-weight: bold;"
        elif self.config.date_font_weight == "light":
            date_style += "font-weight: 300;"
        
        self.date_label.setStyleSheet(date_style)

    def update_clock(self):
        """Update clock display with customizable formatting"""
        now = datetime.now()
        
        try:
            # Format time
            if self.config.show_seconds:
                # If show_seconds is enabled, use format that includes seconds
                if "ss" not in self.config.time_format:
                    # Auto-add seconds to format if not present
                    time_format = self.config.time_format.replace("mm", "mm:ss")
                else:
                    time_format = self.config.time_format
            else:
                # Remove seconds from format if present
                time_format = self.config.time_format.replace(":ss", "").replace("ss", "")
            
            time_str = now.strftime(time_format)
            
            # Format date
            date_str = now.strftime(self.config.date_format)
            
            self.clock_label.setText(time_str)
            self.date_label.setText(date_str)
            
        except Exception as e:
            # Fallback to default formatting if custom format fails
            print(f"Clock format error: {e}, using defaults")
            time_str = now.strftime("%I:%M %p")
            date_str = now.strftime("%a %b %d")
            self.clock_label.setText(time_str)
            self.date_label.setText(date_str)

    # Add these quick setting methods to TokyoNightPanelBar class
    def set_clock_font_size(self, size):
        """Quick set clock font size"""
        self.config.clock_font_size = size
        self.update_clock_styles()
        self.save_config()

    def set_date_font_size(self, size):
        """Quick set date font size"""
        self.config.date_font_size = size
        self.update_clock_styles()
        self.save_config()

    def set_clock_color(self, color):
        """Quick set clock color"""
        self.config.clock_color = color
        self.update_clock_styles()
        self.save_config()

    def toggle_seconds(self):
        """Toggle seconds display"""
        self.config.show_seconds = not self.config.show_seconds
        self.update_clock_styles()
        self.save_config()

    def save_config(self):
        """Save configuration"""
        config_manager = ConfigManager()
        config_manager.save_config(self.config)





    def add_from_edit_dialog(self, parent_dialog):
        """Add launcher from edit dialog"""
        self.add_custom_launcher()
        parent_dialog.accept()
        self.edit_custom_launchers()  # Reopen to refresh list

    def remove_launcher_from_list(self, list_widget):
        """Remove selected launcher from list"""
        current_row = list_widget.currentRow()
        if current_row >= 0:
            self.custom_apps.pop(current_row)
            list_widget.takeItem(current_row)
            self.save_custom_launchers_to_config()
            self.update_applications_menu()

    def edit_launcher_in_list(self, list_widget):
        """Edit selected launcher"""
        current_row = list_widget.currentRow()
        if current_row >= 0:
            old_name, old_command, old_icon = self.custom_apps[current_row]
            
            new_name, ok = QInputDialog.getText(
                self, "Edit Launcher", 
                "Enter new name:",
                text=old_name
            )
            if ok and new_name:
                new_command, ok = QInputDialog.getText(
                    self, "Edit Launcher",
                    "Enter new command:",
                    text=old_command
                )
                if ok and new_command:
                    self.custom_apps[current_row] = (new_name, new_command, old_icon)
                    list_widget.currentItem().setText(f"{new_name} ‚Üí {new_command}")
                    self.save_custom_launchers_to_config()
                    self.update_applications_menu()

    def save_custom_launchers_to_config(self):
        """Save custom launchers to configuration"""
        if hasattr(self, 'custom_apps'):
            # Convert to the format expected by create_applications_menu
            self.config.custom_launchers = self.custom_apps
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def update_applications_menu(self):
        """Update the applications menu with current custom launchers"""
        self.apps_button.setMenu(self.create_applications_menu())

    def add_custom_launcher(self):
        """Add a new custom launcher via dialog"""
        name, ok = QInputDialog.getText(
            self, "Add Custom Launcher", 
            "Enter launcher name:"
        )
        if ok and name:
            command, ok = QInputDialog.getText(
                self, "Add Custom Launcher",
                "Enter command to execute:"
            )
            if ok and command:
                # Initialize custom_apps if it doesn't exist
                if not hasattr(self, 'custom_apps'):
                    self.custom_apps = []
                
                # Add the new launcher
                self.custom_apps.append((name, command, ""))
                
                # Save to config and reload menu
                self.save_custom_launchers_to_config()
                self.update_applications_menu()
                
                QMessageBox.information(self, "Success", "Custom launcher added!")

    def eventFilter(self, obj, event):
        """Filter events to detect mouse movement for auto-hide"""
        if event.type() == QEvent.MouseMove and self.config.auto_hide:
            # Get the current mouse position
            mouse_pos = QCursor.pos()
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()
            
            # Check if mouse is at the edge where panel is located
            at_edge = False
            
            if self.config.position == "top":
                if mouse_pos.y() <= self.config.edge_size:
                    at_edge = True
            else:  # bottom
                if mouse_pos.y() >= screen_rect.height() - self.config.edge_size:
                    at_edge = True
            
            # Show panel if mouse is at edge and show_on_edge is enabled
            if at_edge and self.config.show_on_edge and self.is_hidden:
                self.show_panel()
            
            # Reset auto-hide timer if mouse is over the panel
            if self.geometry().contains(mouse_pos) and not self.is_hidden:
                self.auto_hide_timer.stop()
                self.auto_hide_timer.start(self.config.auto_hide_delay)
        
        return super().eventFilter(obj, event)

    def check_mouse_position(self):
        """Check mouse position for edge detection"""
        if not self.config.auto_hide or not self.config.show_on_edge:
            return
            
        mouse_pos = QCursor.pos()
        screen = QApplication.primaryScreen()
        screen_rect = screen.geometry()
        
        # Check if mouse is at the edge where panel is located
        at_edge = False
        
        if self.config.position == "top":
            if mouse_pos.y() <= self.config.edge_size:
                at_edge = True
        else:  # bottom
            if mouse_pos.y() >= screen_rect.height() - self.config.edge_size:
                at_edge = True
        
        # Show panel if mouse is at edge and panel is hidden
        if at_edge and self.is_hidden:
            self.show_panel()

    def show_panel(self):
        """Show the panel with animation"""
        if self.is_hidden:
            self.is_hidden = False
            
            # Get the screen geometry
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()
            
            # Create animation
            self.animation = QPropertyAnimation(self, b"geometry")
            self.animation.setDuration(200)
            self.animation.setEasingCurve(QEasingCurve.OutCubic)
            
            # Set start and end positions based on panel position
            if self.config.position == "top":
                start_pos = QRect(0, -self.config.height, screen_rect.width(), self.config.height)
                end_pos = QRect(0, 0, screen_rect.width(), self.config.height)
            else:  # bottom
                start_pos = QRect(0, screen_rect.height(), screen_rect.width(), self.config.height)
                end_pos = QRect(0, screen_rect.height() - self.config.height, screen_rect.width(), self.config.height)
            
            self.animation.setStartValue(start_pos)
            self.animation.setEndValue(end_pos)
            self.animation.start()
            
            # Show the panel
            self.show()
            
            # Reset auto-hide timer
            self.auto_hide_timer.stop()
            self.auto_hide_timer.start(self.config.auto_hide_delay)

    def hide_panel(self):
        """Hide the panel with animation"""
        if not self.is_hidden and self.config.auto_hide:
            self.is_hidden = True
            
            # Get the screen geometry
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()
            
            # Create animation
            self.animation = QPropertyAnimation(self, b"geometry")
            self.animation.setDuration(200)
            self.animation.setEasingCurve(QEasingCurve.InCubic)
            
            # Set start and end positions based on panel position
            if self.config.position == "top":
                start_pos = QRect(0, 0, screen_rect.width(), self.config.height)
                end_pos = QRect(0, -self.config.height, screen_rect.width(), self.config.height)
            else:  # bottom
                start_pos = QRect(0, screen_rect.height() - self.config.height, screen_rect.width(), self.config.height)
                end_pos = QRect(0, screen_rect.height(), screen_rect.width(), self.config.height)
            
            self.animation.setStartValue(start_pos)
            self.animation.setEndValue(end_pos)
            self.animation.start()
            
            # Hide the panel after animation completes
            QTimer.singleShot(250, self.hide)

    def enterEvent(self, event):
        """Handle mouse enter event"""
        if self.config.auto_hide and self.is_hidden:
            self.show_panel()
        super().enterEvent(event)

    def leaveEvent(self, event):
        """Handle mouse leave event"""
        if self.config.auto_hide and not self.is_hidden:
            self.auto_hide_timer.stop()
            self.auto_hide_timer.start(self.config.auto_hide_delay)
        super().leaveEvent(event)

    def create_applications_menu(self):
        """Create applications menu with Nerd Font icons and workspace options"""
        menu = QMenu(self)
        menu.setStyleSheet(self.get_stylesheet())
        
        # === CUSTOM LAUNCHERS AT THE TOP ===
        # Load custom launchers from config or initialize
        if hasattr(self.config, 'custom_launchers') and self.config.custom_launchers:
            self.custom_apps = self.config.custom_launchers
        elif not hasattr(self, 'custom_apps'):
            # Initialize with default launchers if none exist
            self.custom_apps = [
                ("StormOS Launcher", "launch4", "StormOS Launcher"),
                # Add more default launchers here if desired
            ]
        
        # Add custom launchers to menu
        if hasattr(self, 'custom_apps') and self.custom_apps:
            for name, command, icon in self.custom_apps:
                action = QAction(name, self)
                action.triggered.connect(lambda checked, cmd=command: self.launch_application(cmd))
                menu.addAction(action)
            
            menu.addSeparator()
        # === END CUSTOM LAUNCHERS ===
        
        # Rest of the method remains the same...
        # Common applications with Nerd Font icons (original apps below custom ones)
        apps = [
            ("Û∞Üç Terminal", self.config.terminal_command, "terminal"),
            ("Û∞âã File Manager", self.config.file_manager_command, "folder"),
            ("Û∞àπ Web Browser", self.config.browser_command, "browser"),
            ("Û∞à¨ Text Editor", self.config.text_editor_command, "text"),
            ("Û∞É§ Settings", self.config.settings_command, "settings"),
            ("Û∞éÅ Calculator", self.config.calculator_command, "calculator"),
            ("Û∞äì Screenshot", self.config.screenshot_command, "camera"),
            ("Û∞ª≠ Image Viewer", self.config.image_viewer_command, "image"),
            ("Û∞éÑ Music Player", self.config.music_player_command, "music", self.config.music_player_args),
        ]

        # Add workspace submenus for each app
        for name, command, icon, *args in apps:
            app_menu = QMenu(name, self)
            app_menu.setStyleSheet(menu.styleSheet())
            
            # Get workspace options
            workspaces = self.get_workspace_options()
            
            for ws_name, ws_id in workspaces:
                ws_action = QAction(ws_name, self)
                extra_args = args[0] if args else ""
                ws_action.triggered.connect(lambda checked, cmd=command, extra=extra_args, wid=ws_id: 
                                          self.launch_application(cmd, extra, wid))
                app_menu.addAction(ws_action)
            
            menu.addMenu(app_menu)

        menu.addSeparator()
        
        # Power menu (unchanged)
        power_menu = QMenu("Û∞ê• Power", self)
        power_menu.setStyleSheet(self.get_stylesheet())
        power_actions = [
            ("Û∞óΩ Log Out", "xfce4-session-logout"),
            ("Û∞úâ Reboot", "systemctl reboot"),
            ("Û∞ê• Shutdown", "systemctl poweroff"),
            ("Û∞í≤ Suspend", "systemctl suspend"),
        ]
        for name, command in power_actions:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, cmd=command: self.execute_command(cmd))
            power_menu.addAction(action)
        menu.addMenu(power_menu)
        
        return menu
    
    def get_workspace_options(self):
        """Get workspace options for menu"""
        options = [("Current Workspace", -1)]
        try:
            result = subprocess.run("wmctrl -d", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                for i, line in enumerate(result.stdout.splitlines()):
                    parts = line.split()
                    if len(parts) >= 9:
                        name_parts = parts[8:]
                        ws_name = ' '.join(name_parts)
                        options.append((f"Workspace {i+1}: {ws_name}", i))
                    else:
                        options.append((f"Workspace {i+1}", i))
        except:
            # Fallback options
            for i in range(4):
                options.append((f"Workspace {i+1}", i))
        return options

    def create_system_menu(self):
        """Create system menu"""
        menu = QMenu(self)
        menu.setStyleSheet(self.get_stylesheet())
        # Volume control - now launches pavucontrol
        vol_action = QAction("Û∞ïæ Volume Control", self)
        vol_action.triggered.connect(self.launch_pavucontrol)
        menu.addAction(vol_action)
        # Network Manager action
        net_action = QAction("Û∞§® Network Manager", self)
        net_action.triggered.connect(self.launch_network_manager)
        menu.addAction(net_action)
        # Bluetooth Manager action
        bt_action = QAction("Û∞ÇØ Bluetooth Manager", self)
        bt_action.triggered.connect(self.launch_bluetooth_manager)
        menu.addAction(bt_action)
        menu.addSeparator()
        # System tools
        tools_actions = [
            ("Û∞çõ System Monitor", "gnome-system-monitor"),
            ("Û∞íì Settings", "xfce4-settings-manager"),
        ]
        for name, command in tools_actions:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, cmd=command: self.launch_application(cmd))
            menu.addAction(action)
        menu.addSeparator()
        # Panel settings
        settings_action = QAction("Û∞íì Panel Settings", self)
        settings_action.triggered.connect(self.show_settings)
        menu.addAction(settings_action)
        return menu

    def show_settings(self):
        """Show settings dialog"""
        dialog = SettingsDialog(self.config, self)
        if dialog.exec_() == QDialog.Accepted:
            # Update panel configuration
            old_config = self.config
            self.config = dialog.config
            
            # Save configuration immediately
            config_manager = ConfigManager()
            config_manager.save_config(self.config)
            print("DEBUG: Settings saved immediately after dialog close")  # Debug line
            
            # Reload the panel with new settings
            self.setup_ui()
            self.load_xfce_launchers()  # This will reload both XFCE and custom launchers
            self.setup_strut()
            
            # Update applications menu with new commands
            self.apps_button.setMenu(self.create_applications_menu())
            
            # Update auto-hide settings
            if self.config.auto_hide:
                self.auto_hide_timer.start(self.config.auto_hide_delay)
            else:
                self.auto_hide_timer.stop()
                if self.is_hidden:
                    self.show_panel()

    def launch_pavucontrol(self):
        """Launch pavucontrol"""
        try:
            # Check if pavucontrol is already running
            result = subprocess.run(
                ["pgrep", "-f", "pavucontrol"],
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # If running, focus it
                subprocess.run(
                    ["wmctrl", "-a", "pavucontrol"],
                    shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                )
            else:
                # Launch pavucontrol
                subprocess.Popen(
                    ["pavucontrol"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
        except Exception as e:
            print(f"Failed to launch pavucontrol: {e}")

    def launch_network_manager(self):
        """Launch network manager"""
        if hasattr(self, 'network_control'):
            self.network_control.launch_network_manager()
        else:
            # Fallback if widget not available
            try:
                subprocess.Popen(
                    ["nm-connection-editor"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except:
                subprocess.Popen(
                    ["nm-applet"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )

    def launch_bluetooth_manager(self):
        """Launch bluetooth manager"""
        if hasattr(self, 'bluetooth_control'):
            self.bluetooth_control.launch_bluetooth_manager()
        else:
            # Fallback if widget not available
            try:
                subprocess.Popen(
                    ["blueman-manager"],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
            except:
                print("Bluetooth manager not available")

    def load_applications(self):
        """Load common applications"""
        self.applications = [
            Application("Web Browser", "firefox", "üåê"),
            Application("Text Editor", "mousepad", "üìù"),
            Application("Calculator", "gnome-calculator", "üßÆ"),
        ]

    def load_xfce_launchers(self):
        """Load XFCE panel launchers and custom launchers"""
        # Always load custom launchers first
        combined_launchers = []
        if self.config.launcher_customizations:
            combined_launchers.extend(self.config.launcher_customizations)
            print(f"DEBUG: Loaded {len(self.config.launcher_customizations)} custom launchers from config")  # Debug line

        # Then load XFCE launchers if the setting is enabled
        if self.config.show_xfce_launchers:
            try:
                reader = XfceLauncherReader()
                xfce_launchers = reader.get_xfce_launchers()
                combined_launchers.extend(xfce_launchers)
                print(f"DEBUG: Loaded {len(xfce_launchers)} XFCE launchers")  # Debug line
            except Exception as e:
                print(f"Error loading XFCE launchers: {e}")

        # Update the internal list
        self.xfce_launchers = combined_launchers
        # Update the display - always show if there are custom launchers
        should_show = self.config.show_xfce_launchers or bool(self.config.launcher_customizations)
        self.xfce_launchers_widget.setVisible(should_show)
        # Update the actual buttons displayed in the widget
        self.update_xfce_launchers_display()

    def update_xfce_launchers_display(self):
        """Update the XFCE launchers display - now handles system icons and workspace targeting."""
        # Clear existing launcher buttons
        for i in reversed(range(self.xfce_launchers_layout.count())):
            widget = self.xfce_launchers_layout.itemAt(i).widget()
            if widget:
                widget.deleteLater()
        
        # Add launcher buttons for the combined list
        for launcher in self.xfce_launchers: # Uses the combined list from load_xfce_launchers
            btn = QToolButton()
            
            # Set tooltip with workspace info
            workspace_info = "Current workspace" if launcher.workspace == -1 else f"Workspace {launcher.workspace + 1}"
            btn.setToolTip(f"{launcher.name}\nOpen in: {workspace_info}")
            
            btn.setFixedSize(32, 32)
            
            # Icon loading logic (existing code)
            icon_input = launcher.icon
            icon_set = False
            
            if icon_input and icon_input.startswith('/'):
                if os.path.isfile(icon_input):
                    try:
                        icon_from_file = QIcon(icon_input)
                        if not icon_from_file.isNull():
                            btn.setIcon(icon_from_file)
                            btn.setIconSize(QSize(24, 24))
                            icon_set = True
                    except:
                        pass

            if not icon_set and icon_input:
                system_icon = QIcon.fromTheme(icon_input)
                if not system_icon.isNull():
                    btn.setIcon(system_icon)
                    btn.setIconSize(QSize(24, 24))
                    icon_set = True

            if not icon_set:
                btn.setText(icon_input or "üöÄ")
            else:
                btn.setText("")
            
            # FIX: Connect with workspace parameter - THIS WAS MISSING
            btn.clicked.connect(lambda checked, cmd=launcher.command, args=launcher.args, ws=launcher.workspace: 
                               self.launch_application(cmd, args, ws))
            self.xfce_launchers_layout.addWidget(btn)
        
        print(f"Updated launcher display with {len(self.xfce_launchers)} buttons (XFCE + Custom)")

    def launch_application(self, command, args="", workspace=-1):
        """Launch an application with optional arguments and workspace targeting"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            
            print(f"Launching: {command} with workspace target: {workspace} (current: {current_workspace})")
            
            # Build the command list properly
            cmd_list = command.split() if ' ' in command else [command]
            if args:
                cmd_list.extend(args.split())
            
            # Launch the application
            process = subprocess.Popen(cmd_list, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # If workspace is specified and different from current, move the window
            if workspace >= 0 and workspace != current_workspace:
                print(f"Will move application to workspace {workspace}")
                
                # Use multiple methods to ensure window gets moved
                # Method 1: Try to move by PID after a delay
                QTimer.singleShot(1000, lambda: self.move_window_to_workspace(process.pid, workspace))
                
                # Method 2: Try to move by window title/class as backup
                app_name = os.path.basename(command.split()[0])  # Get app name from command
                QTimer.singleShot(2000, lambda: self.ensure_window_in_workspace(app_name, workspace))
                
            elif workspace >= 0:
                print(f"Application already on target workspace {workspace}")
                
        except Exception as e:
            print(f"Failed to launch {command}: {e}")

    def move_window_to_workspace(self, pid, workspace_id):
        """Move a window to a specific workspace by PID"""
        try:
            print(f"Attempting to move window with PID {pid} to workspace {workspace_id}")
            
            # Wait a bit more for the window to fully appear
            time.sleep(0.5)
            
            # Find window by PID and move it to target workspace
            result = subprocess.run(
                f"wmctrl -l -p | grep ' {pid} ' | head -1 | cut -d' ' -f1",
                shell=True, capture_output=True, text=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Found window {window_id} for PID {pid}, moving to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
                print(f"Window {window_id} moved to workspace {workspace_id}")
            else:
                print(f"No window found for PID {pid}, trying alternative methods")
                # Try alternative method
                self.move_recent_window_to_workspace(workspace_id)
                
        except Exception as e:
            print(f"Error moving window to workspace: {e}")

    def move_recent_window_to_workspace(self, workspace_id):
        """Move the most recent window to target workspace"""
        try:
            print(f"Moving most recent window to workspace {workspace_id}")
            
            # Get list of windows and move the most recent one
            result = subprocess.run("wmctrl -l | tail -1 | cut -d' ' -f1", 
                                  shell=True, capture_output=True, text=True)
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Moving recent window {window_id} to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
                print(f"Recent window moved to workspace {workspace_id}")
        except Exception as e:
            print(f"Error moving recent window: {e}")

    def ensure_window_in_workspace(self, app_name, workspace_id):
        """Ensure the application window ends up in the target workspace"""
        try:
            print(f"Ensuring {app_name} window is in workspace {workspace_id}")
            
            # Try to find window by application name
            result = subprocess.run(
                f"wmctrl -l | grep -i '{app_name}' | tail -1 | cut -d' ' -f1",
                shell=True, capture_output=True, text=True
            )
            
            if result.returncode == 0 and result.stdout.strip():
                window_id = result.stdout.strip()
                print(f"Found {app_name} window {window_id}, moving to workspace {workspace_id}")
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
                print(f"{app_name} window moved to workspace {workspace_id}")
            else:
                print(f"No {app_name} window found, trying to move most recent window")
                # Move the most recent window as fallback
                self.move_recent_window_to_workspace(workspace_id)
                
        except Exception as e:
            print(f"Error ensuring window in workspace: {e}")

    def execute_command(self, command):
        """Execute a system command"""
        try:
            subprocess.Popen(command.split(), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"Failed to execute {command}: {e}")

    def setup_system_monitor(self):
        """Setup system monitoring thread"""
        self.monitor_thread = SystemMonitorThread()
        self.monitor_thread.cpu_updated.connect(self.update_cpu_display)
        self.monitor_thread.memory_updated.connect(self.update_memory_display)
        self.monitor_thread.battery_updated.connect(self.update_battery_display)
        self.monitor_thread.volume_updated.connect(self.update_volume_display)
        self.monitor_thread.network_updated.connect(self.update_network_display)
        self.monitor_thread.brightness_updated.connect(self.update_brightness_display)
        self.monitor_thread.workspace_updated.connect(self.update_workspace_display)
        self.monitor_thread.active_window_updated.connect(self.update_active_window)
        self.monitor_thread.start()

    def update_cpu_display(self, usage):
        """Update CPU display with color coding"""
        color = TokyoNight.GREEN if usage < 50 else TokyoNight.YELLOW if usage < 80 else TokyoNight.RED
        self.cpu_label.setText(f"Û∞çõ <font color='{color}'>{usage:.0f}%</font>")

    def update_memory_display(self, usage):
        """Update memory display with color coding"""
        color = TokyoNight.GREEN if usage < 60 else TokyoNight.YELLOW if usage < 85 else TokyoNight.RED
        self.mem_label.setText(f"Û∞òö <font color='{color}'>{usage:.0f}%</font>")

    def update_battery_display(self, capacity, status, time_str):
        """Update battery display with dynamic icons and time information"""
        # Check if battery_label exists
        if not hasattr(self, 'battery_label'):
            return
        # Battery icons based on level
        battery_icons = ["Û∞Çé", "Û∞Å∫", "Û∞Åª", "Û∞Åº", "Û∞ÅΩ", "Û∞Åæ", "Û∞ÇÄ", "Û∞ÇÅ", "Û∞ÇÇ", "Û∞Åπ"]
        icon_index = min(len(battery_icons) - 1, capacity // 10)
        icon = battery_icons[icon_index]
        if status == "Charging":
            icon = "Û∞ÇÑ"  # Charging icon
        
        # Battery capacity color
        capacity_color = (TokyoNight.GREEN if capacity > 50
                         else TokyoNight.YELLOW if capacity > 20
                         else TokyoNight.RED)
        
        # Build display text with time information
        display_text = f"{icon} <font color='{capacity_color}'>{capacity}%</font>"
        
        # Add time information if available - CHANGED COLORS HERE
        if time_str:
            if status.lower() == "discharging":
                # Use yellow for discharging time to make it more visible
                display_text += f" <font color='{TokyoNight.YELLOW}'>({time_str})</font>"
            elif status.lower() == "charging":
                display_text += f" <font color='{TokyoNight.GREEN}'>({time_str})</font>"
            elif status.lower() == "full":
                display_text += f" <font color='{TokyoNight.GREEN}'>(Full)</font>"
        
        self.battery_label.setText(display_text)

    def update_volume_display(self, volume, muted):
        """Update volume display"""
        if hasattr(self, 'volume_control'):
            self.volume_control.update_volume_display(volume, muted)

    def update_network_display(self, ssid, status):
        """Update network display"""
        # Check if network_label exists
        if not hasattr(self, 'network_label'):
            return
        if status == "connected":
            icon = "Û∞ñ©" if ssid else "Û∞àÄ"  # WiFi vs Ethernet
            color = TokyoNight.GREEN
            text = ssid[:12] if ssid else "Ethernet"
        else:
            icon = "Û∞ñ™"
            color = TokyoNight.RED
            text = "Offline"
        self.network_label.setText(f"{icon} <font color='{color}'>{text}</font>")

    def update_brightness_display(self, brightness):
        """Update brightness slider position"""
        if hasattr(self, 'brightness_slider'):
            self.brightness_slider.blockSignals(True)
            self.brightness_slider.setValue(brightness)
            self.brightness_slider.blockSignals(False)

    def update_clock(self):
        """Update clock display"""
        now = datetime.now()
        time_str = now.strftime("%I:%M %p")
        date_str = now.strftime("%a %b %d")
        self.clock_label.setText(time_str)
        self.date_label.setText(date_str)

    def update_windows(self):
        """Update window list"""
        try:
            result = subprocess.run("wmctrl -l", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                self.update_taskbar(result.stdout)
        except Exception as e:
            print(f"Window update error: {e}")

    def update_taskbar(self, wmctrl_output):
        """Update taskbar with current windows"""
        # Clear existing window buttons
        for i in reversed(range(self.taskbar_layout.count())):
            widget = self.taskbar_layout.itemAt(i).widget()
            if widget and hasattr(widget, 'is_window_button'):
                widget.deleteLater()
        # Add new window buttons
        windows = []
        for line in wmctrl_output.splitlines():
            parts = line.split(None, 3)
            if len(parts) >= 4:
                window_id, desktop, host, title = parts
                if desktop != '-1':  # Skip sticky windows
                    windows.append({'id': window_id, 'title': title})

        # Add buttons for windows (limit to 6)
        for window in windows[:6]:
            btn = QPushButton(window['title'][:18])  # Truncate long titles
            btn.setFixedHeight(28)
            btn.is_window_button = True
            btn.setProperty("window_id", window['id'])
            btn.clicked.connect(lambda checked, wid=window['id']: self.focus_window(wid))
            # Check if this is the active window
            if window['id'] == self.active_window_id:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}, 
                            stop:1 {TokyoNight.PURPLE});
                        color: {TokyoNight.BACKGROUND};
                        border: none;
                        border-radius: 6px;
                        font-weight: bold;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.CYAN}, 
                            stop:1 {TokyoNight.BLUE});
                    }}
                """)
            else:
                btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.SELECTION}, 
                            stop:1 {TokyoNight.NIGHT_BOTTOM});
                        color: {TokyoNight.FOREGROUND};
                        border: none;
                        border-radius: 6px;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}40, 
                            stop:1 {TokyoNight.PURPLE}40);
                    }}
                """)
            # Add context menu support
            btn.setContextMenuPolicy(Qt.CustomContextMenu)
            btn.customContextMenuRequested.connect(self.show_window_menu)
            self.taskbar_layout.addWidget(btn)

        # Update the taskbar widget size to ensure proper scrolling
        self.taskbar_widget.adjustSize()

    def show_window_menu(self, position):
        """Show context menu for window button"""
        btn = self.sender()
        window_id = btn.property('window_id')
        if window_id:
            self.show_window_menu_at_position(btn.mapToGlobal(position), window_id)

    def show_window_menu_at_position(self, position, window_id):
        """Show window context menu at specified position"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        # Window actions
        actions = [
            ("Û∞ñ© Focus", self.focus_window),
            ("Û∞ñ∞ Maximize", self.maximize_window),
            ("Û∞ñØ Minimize", self.minimize_window),
            ("Û∞ñ™ Close", self.close_window),
            ("Û∞íì Move", self.move_window),
            ("Û∞íç Always on Top", self.set_always_on_top),
            ("Û∞Ç∏ Unstick", self.unstick_window),
            ("Û∞òö Always Below", self.set_always_below),
            ("Û∞Ç∏ Pin to Workspace", self.pin_to_workspace),
            ("Û∞Çä Move to Workspace", self.move_to_workspace),
            ("Û∞îÅ Send to Workspace", self.send_to_workspace)
        ]
        for name, callback in actions:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, func=callback: func(window_id))
            menu.addAction(action)
        menu.exec_(position)

    def focus_window(self, window_id):
        """Focus a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -a {window_id}", shell=True)
        except Exception as e:
            print(f"Focus error: {e}")

    def minimize_window(self, window_id):
        """Minimize a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,hidden", shell=True)
        except Exception as e:
            print(f"Minimize error: {e}")

    def maximize_window(self, window_id):
        """Maximize a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,maximized_vert,maximized_horz", shell=True)
        except Exception as e:
            print(f"Maximize error: {e}")

    def close_window(self, window_id):
        """Close a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -c {window_id}", shell=True)
        except Exception as e:
            print(f"Close error: {e}")

    def move_window(self, window_id):
        """Move a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,move", shell=True)
        except Exception as e:
            print(f"Move error: {e}")

    def set_always_on_top(self, window_id):
        """Set window to always on top"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,above", shell=True)
        except Exception as e:
            print(f"Always on top error: {e}")

    def unstick_window(self, window_id):
        """Unstick a window by ID"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b remove,sticky", shell=True)
        except Exception as e:
            print(f"Unstick error: {e}")

    def set_always_below(self, window_id):
        """Set window to always below"""
        try:
            subprocess.run(f"wmctrl -i -r {window_id} -b add,below", shell=True)
        except Exception as e:
            print(f"Always below error: {e}")

    def pin_to_workspace(self, window_id):
        """Pin window to current workspace"""
        try:
            current_workspace = self.current_workspace
            subprocess.run(f"wmctrl -i -r {window_id} -b add,sticky", shell=True)
        except Exception as e:
            print(f"Pin to workspace error: {e}")

    def move_to_workspace(self, window_id):
        """Move window to a specific workspace"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            # Show dialog to select workspace
            workspace_id, ok = QInputDialog.getInt(
                self, "Move to Workspace",
                f"Enter workspace number (0-{current_workspace + 10}):",
                current_workspace,
                0, current_workspace + 10
            )
            if ok:
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
        except Exception as e:
            print(f"Move to workspace error: {e}")

    def send_to_workspace(self, window_id):
        """Send window to a specific workspace"""
        try:
            # Get current workspace
            current_workspace = self.current_workspace
            # Show dialog to select workspace
            workspace_id, ok = QInputDialog.getInt(
                self, "Send to Workspace",
                f"Enter workspace number (0-{current_workspace + 10}):",
                current_workspace,
                0, current_workspace + 10
            )
            if ok:
                subprocess.run(f"wmctrl -i -r {window_id} -t {workspace_id}", shell=True)
        except Exception as e:
            print(f"Send to workspace error: {e}")

    def update_active_window(self, window_id):
        """Update the active window indicator"""
        self.active_window_id = window_id
        # Update taskbar to highlight active window
        self.update_windows()

    def reload_panel(self):
        """Reload the panel with current settings"""
        # Save current config
        config_manager = ConfigManager()
        config_manager.save_config(self.config)
        # Restart the application
        QApplication.quit()
        subprocess.Popen([sys.executable] + sys.argv)

    def quit_application(self):
        """Quit the application"""
        QApplication.quit()

    def setup_workspace_switcher(self, layout):
        """Setup workspace/desktop switcher"""
        self.workspace_widget = QWidget()
        workspace_layout = QHBoxLayout(self.workspace_widget)
        workspace_layout.setContentsMargins(0, 0, 0, 0)
        workspace_layout.setSpacing(2)
        # Get current workspace count
        try:
            result = subprocess.run("wmctrl -d", shell=True, capture_output=True, text=True)
            if result.returncode == 0:
                workspaces = result.stdout.splitlines()
                current_workspace = 0
                for i, line in enumerate(workspaces):
                    if "*" in line:
                        current_workspace = i
                        break
                # Create workspace buttons
                self.workspace_buttons = []
                for i in range(len(workspaces)):
                    btn = QPushButton(str(i+1))
                    btn.setFixedSize(28, 28)
                    btn.setProperty("workspace_id", i)
                    # Set initial style based on current workspace
                    if i == current_workspace:
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.BLUE}, 
                                    stop:1 {TokyoNight.PURPLE});
                                color: {TokyoNight.BACKGROUND};
                                border: none;
                                border-radius: 6px;
                                font-weight: bold;
                                font-size: 10pt;
                            }}
                            QPushButton:hover {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.CYAN}, 
                                    stop:1 {TokyoNight.BLUE});
                            }}
                        """)
                    else:
                        btn.setStyleSheet(f"""
                            QPushButton {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.SELECTION}, 
                                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                                color: {TokyoNight.FOREGROUND};
                                border: none;
                                border-radius: 6px;
                                font-size: 10pt;
                            }}
                            QPushButton:hover {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.BLUE}40, 
                                    stop:1 {TokyoNight.PURPLE}40);
                            }}
                        """)
                    btn.clicked.connect(lambda checked, w=i: self.switch_workspace(w))
                    workspace_layout.addWidget(btn)
                    self.workspace_buttons.append(btn)
                # Store current workspace
                self.current_workspace = current_workspace
        except Exception as e:
            print(f"Error setting up workspaces: {e}")
        layout.addWidget(self.workspace_widget)

    def switch_workspace(self, workspace_id):
        """Switch to the specified workspace"""
        try:
            subprocess.run(f"wmctrl -s {workspace_id}", shell=True)
            # Update button styles
            for i, btn in enumerate(self.workspace_buttons):
                if i == workspace_id:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.BLUE}, 
                                stop:1 {TokyoNight.PURPLE});
                            color: {TokyoNight.BACKGROUND};
                            border: none;
                            border-radius: 6px;
                            font-weight: bold;
                            font-size: 10pt;
                        }}
                        QPushButton:hover {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.CYAN}, 
                                    stop:1 {TokyoNight.BLUE});
                        }}
                    """)
                else:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.SELECTION}, 
                                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                                color: {TokyoNight.FOREGROUND};
                                border: none;
                                border-radius: 6px;
                                font-size: 10pt;
                            }}
                            QPushButton:hover {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.BLUE}40, 
                                    stop:1 {TokyoNight.PURPLE}40);
                            }}
                        """)
            # Update current workspace
            self.current_workspace = workspace_id
        except Exception as e:
            print(f"Error switching workspace: {e}")

    def update_workspace_display(self, workspace_id):
        """Update workspace display when workspace changes"""
        if hasattr(self, 'workspace_buttons') and workspace_id < len(self.workspace_buttons):
            # Update button styles
            for i, btn in enumerate(self.workspace_buttons):
                if i == workspace_id:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                stop:0 {TokyoNight.BLUE}, 
                                stop:1 {TokyoNight.PURPLE});
                            color: {TokyoNight.BACKGROUND};
                            border: none;
                            border-radius: 6px;
                            font-weight: bold;
                            font-size: 10pt;
                        }}
                        QPushButton:hover {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.CYAN}, 
                                    stop:1 {TokyoNight.BLUE});
                        }}
                    """)
                else:
                    btn.setStyleSheet(f"""
                        QPushButton {{
                            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.SELECTION}, 
                                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                                color: {TokyoNight.FOREGROUND};
                                border: none;
                                border-radius: 6px;
                                font-size: 10pt;
                            }}
                            QPushButton:hover {{
                                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                                    stop:0 {TokyoNight.BLUE}40, 
                                    stop:1 {TokyoNight.PURPLE}40);
                            }}
                        """)
            # Update current workspace
            self.current_workspace = workspace_id

    def setup_brightness_control(self, layout):
        """Setup brightness control slider"""
        # Brightness icon
        brightness_icon = QLabel("Û∞É†")
        brightness_icon.setStyleSheet(f"color: {TokyoNight.YELLOW}; font-size: 12pt;")
        layout.addWidget(brightness_icon)
        # Brightness slider
        self.brightness_slider = QSlider(Qt.Horizontal)
        self.brightness_slider.setRange(10, 100)
        self.brightness_slider.setFixedWidth(80)
        self.brightness_slider.valueChanged.connect(self.set_brightness)
        layout.addWidget(self.brightness_slider)

    def set_brightness(self, value):
        """Set screen brightness"""
        try:
            subprocess.run(f"brightnessctl set {value}%", shell=True,
                          stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        except Exception as e:
            print(f"Failed to set brightness: {e}")

    def setup_weather_widget(self, layout):
        """Setup weather widget"""
        self.weather_label = QLabel("Û∞ñê --¬∞C")
        self.weather_label.setStyleSheet(f"""
            padding: 4px 8px;
            background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                stop:0 {TokyoNight.SELECTION}, 
                stop:1 {TokyoNight.NIGHT_BOTTOM});
            border-radius: 6px;
            font-size: 9pt;
            color: {TokyoNight.FOREGROUND};
        """)
        layout.addWidget(self.weather_label)
        # Start weather update timer (update every 30 minutes)
        self.weather_timer = QTimer()
        self.weather_timer.timeout.connect(self.update_weather)
        self.weather_timer.start(1800000)  # 30 minutes
        # Initial weather update
        self.update_weather()

    def update_weather(self):
        """Update weather information"""
        # Check if weather_label exists
        if not hasattr(self, 'weather_label'):
            return
        try:
            # Build location parameter
            location = self.config.weather_location if self.config.weather_location else ""
            if location:
                location_url = f"{location}"
            else:
                location_url = ""
            # Using wttr.in for weather data
            result = subprocess.run(
                f"curl -s 'wttr.in/{location_url}?format=%C+%t'",
                shell=True, capture_output=True, text=True, timeout=5
            )
            if result.returncode == 0 and result.stdout.strip():
                weather_data = result.stdout.strip()
                # Format: "Condition +temp"
                parts = weather_data.split('+')
                if len(parts) == 2:
                    condition = parts[0].strip()
                    temp = parts[1].strip()
                    # Map weather conditions to icons
                    weather_icons = {
                        "Clear": "Û∞ñô", "Sunny": "Û∞ñô", "Partly cloudy": "Û∞ñï",
                        "Cloudy": "Û∞ñê", "Overcast": "Û∞ñê", "Fog": "Û∞ñë",
                        "Rain": "Û∞ñó", "Drizzle": "Û∞ñó", "Snow": "Û∞ñò",
                        "Thunderstorm": "Û∞ñì", "Mist": "Û∞ñë", "Patchy rain": "Û∞ñó",
                        "Light rain": "Û∞ñó", "Moderate rain": "Û∞ñó", "Heavy rain": "Û∞ñó"
                    }
                    icon = weather_icons.get(condition, "Û∞ñê")
                    self.weather_label.setText(f"{icon} {temp}")
            else:
                self.weather_label.setText("Û∞ñê --¬∞C")
        except Exception as e:
            print(f"Error updating weather: {e}")
            self.weather_label.setText("Û∞ñê --¬∞C")

    def setup_notification_center(self, layout):
        """Setup notification center"""
        self.notification_btn = QPushButton("Û∞Çö")
        self.notification_btn.setFixedSize(32, 32)
        self.notification_btn.clicked.connect(self.show_notifications)
        self.notification_btn.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-size: 12pt;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
        """)
        layout.addWidget(self.notification_btn)
        # Track notification count
        self.update_notification_count()
        # Start notification monitoring
        self.notification_timer = QTimer()
        self.notification_timer.timeout.connect(self.update_notification_count)
        self.notification_timer.start(5000)  # Check every 5 seconds

    def update_notification_count(self):
        """Update notification count"""
        # Check if notification_btn exists
        if not hasattr(self, 'notification_btn'):
            return
        try:
            # Try different notification systems
            count = 0
            # Try dunst
            result = subprocess.run(
                "dunstctl count 2>/dev/null || echo 0",
                shell=True, capture_output=True, text=True
            )
            if result.returncode == 0:
                # Parse the output to extract the waiting count
                output = result.stdout.strip()
                if output.isdigit():
                    count = int(output)
                else:
                    # Extract the waiting count from multi-line output
                    match = re.search(r'Waiting:\s+(\d+)', output)
                    if match:
                        count = int(match.group(1))
            else:
                # Try mako
                result = subprocess.run(
                    "makoctl list 2>/dev/null | grep -c 'app-name' || echo 0",
                    shell=True, capture_output=True, text=True
                )
                if result.returncode == 0:
                    count = int(result.stdout.strip())
            if count > 0:
                self.notification_btn.setText(f"Û∞Çö {count}")
                self.notification_btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}, 
                            stop:1 {TokyoNight.PURPLE});
                        color: {TokyoNight.BACKGROUND};
                        border: none;
                        border-radius: 6px;
                        font-size: 12pt;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.CYAN}, 
                            stop:1 {TokyoNight.BLUE});
                    }}
                """)
            else:
                self.notification_btn.setText("Û∞Çö")
                self.notification_btn.setStyleSheet(f"""
                    QPushButton {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.SELECTION}, 
                            stop:1 {TokyoNight.NIGHT_BOTTOM});
                        color: {TokyoNight.FOREGROUND};
                        border: none;
                        border-radius: 6px;
                        font-size: 12pt;
                    }}
                    QPushButton:hover {{
                        background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                            stop:0 {TokyoNight.BLUE}40, 
                            stop:1 {TokyoNight.PURPLE}40);
                    }}
                """)
        except Exception as e:
            print(f"Error updating notification count: {e}")

    def show_notifications(self):
        """Show notification history"""
        try:
            # Try dunst
            subprocess.run("dunstctl history-pop 2>/dev/null", shell=True)
        except:
            try:
                # Try mako
                subprocess.run("makoctl restore 2>/dev/null", shell=True)
            except:
                print("No supported notification system found")

    def get_stylesheet(self):
        """Return enhanced dark night themed stylesheet"""
        corner_radius = f"{self.config.corner_radius}px" if self.config.rounded_corners else "0px"
        return f"""
            QMainWindow {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}CC, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM}CC,
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT}CC);
                border: 1px solid {TokyoNight.NEBULA}60;
                border-radius: {corner_radius};
            }}
            QWidget#centralwidget {{
                background: transparent;
                border-radius: {corner_radius};
            }}
            QToolButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.SELECTION}, 
                    stop:1 {TokyoNight.NIGHT_BOTTOM});
                color: {TokyoNight.FOREGROUND};
                border: none;
                border-radius: 6px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QToolButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}40, 
                    stop:1 {TokyoNight.PURPLE}40);
            }}
            QToolButton:pressed {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}60, 
                    stop:1 {TokyoNight.PURPLE}60);
            }}
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
            QFrame[frameShape="4"] {{
                background: {TokyoNight.NEBULA}40;
                max-width: 1px;
            }}
            QSlider::groove:horizontal {{
                border: none;
                height: 4px;
                background: {TokyoNight.NEBULA};
                border-radius: 2px;
            }}
            QSlider::handle:horizontal {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                border: none;
                width: 12px;
                margin: -4px 0;
                border-radius: 6px;
            }}
            QSlider::handle:horizontal:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.BLUE}, 
                    stop:1 {TokyoNight.PURPLE});
                color: {TokyoNight.BACKGROUND};
                border: none;
                padding: 6px 12px;
                border-radius: 4px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.CYAN}, 
                    stop:1 {TokyoNight.BLUE});
            }}
            QFormLayout {{
                color: {TokyoNight.FOREGROUND};
            }}
            QLabel {{
                color: {TokyoNight.FOREGROUND};
            }}
        """

    def show_panel_context_menu(self, position):
        """Show context menu with clock customization options"""
        menu = QMenu(self)
        menu.setStyleSheet(f"""
            QMenu {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {TokyoNight.NIGHT_TOP}, 
                    stop:0.7 {TokyoNight.NIGHT_BOTTOM},
                    stop:1 {TokyoNight.NIGHT_HIGHLIGHT});
                color: {TokyoNight.FOREGROUND};
                border: 1px solid {TokyoNight.NEBULA};
                border-radius: 6px;
                padding: 4px;
            }}
            QMenu::item {{
                padding: 6px 16px;
                border-radius: 4px;
                font-family: "JetBrains Mono Nerd Font";
            }}
            QMenu::item:selected {{
                background: {TokyoNight.BLUE};
                color: {TokyoNight.BACKGROUND};
            }}
        """)
        
        # Clock quick settings submenu
        clock_menu = QMenu("Û∞•î Clock Settings", self)
        clock_menu.setStyleSheet(menu.styleSheet())
        
        # Font size quick adjustments
        font_size_menu = QMenu("Font Size", self)
        font_size_menu.setStyleSheet(menu.styleSheet())
        
        clock_sizes = [("Small (10pt)", 10), ("Medium (12pt)", 12), ("Large (14pt)", 14), ("X-Large (16pt)", 16)]
        for name, size in clock_sizes:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, s=size: self.set_clock_font_size(s))
            font_size_menu.addAction(action)
        
        date_sizes = [("Small (7pt)", 7), ("Medium (9pt)", 9), ("Large (11pt)", 11)]
        for name, size in date_sizes:
            action = QAction(f"Date {name}", self)
            action.triggered.connect(lambda checked, s=size: self.set_date_font_size(s))
            font_size_menu.addAction(action)
        
        clock_menu.addMenu(font_size_menu)
        
        # Color quick picks
        color_menu = QMenu("Colors", self)
        color_menu.setStyleSheet(menu.styleSheet())
        
        color_presets = [
            ("Moon Glow", TokyoNight.MOON_GLOW),
            ("Cyan", TokyoNight.CYAN),
            ("Green", TokyoNight.GREEN),
            ("Yellow", TokyoNight.YELLOW),
            ("Pink", TokyoNight.PINK),
            ("White", TokyoNight.BRIGHT_WHITE)
        ]
        
        for name, color in color_presets:
            action = QAction(name, self)
            action.triggered.connect(lambda checked, c=color: self.set_clock_color(c))
            color_menu.addAction(action)
        
        clock_menu.addMenu(color_menu)
        
        # Toggle seconds
        seconds_action = QAction("Show Seconds", self)
        seconds_action.setCheckable(True)
        seconds_action.setChecked(self.config.show_seconds)
        seconds_action.triggered.connect(self.toggle_seconds)
        clock_menu.addAction(seconds_action)
        
        menu.addMenu(clock_menu)
        menu.addSeparator()
        
        # Custom Launchers submenu
        launchers_menu = QMenu("Û∞Äª Custom Launchers", self)
        launchers_menu.setStyleSheet(menu.styleSheet())
        
        # Add current custom launchers as quick actions
        if hasattr(self, 'custom_apps') and self.custom_apps:
            for name, command, icon in self.custom_apps:
                action = QAction(name, self)
                action.triggered.connect(lambda checked, cmd=command: self.launch_application(cmd))
                launchers_menu.addAction(action)
            launchers_menu.addSeparator()
        
        # Management actions
        add_action = QAction("Û∞êï Add Launcher", self)
        add_action.triggered.connect(self.add_custom_launcher)
        launchers_menu.addAction(add_action)
        
        edit_action = QAction("Û∞è´ Edit Launchers", self)
        edit_action.triggered.connect(self.edit_custom_launchers)
        launchers_menu.addAction(edit_action)
        
        menu.addMenu(launchers_menu)
        menu.addSeparator()
        
        # Tiling submenu
        tiling_menu = QMenu("‚äû Window Tiling", self)
        tiling_menu.setStyleSheet(menu.styleSheet())
        
        # Toggle tiling
        toggle_action = QAction("‚äû Toggle Tiling", self)
        toggle_action.triggered.connect(self.toggle_tiling)
        tiling_menu.addAction(toggle_action)
        
        # Force apply layout
        force_apply_action = QAction("üîÑ Force Apply Layout", self)
        force_apply_action.triggered.connect(self.force_apply_tiling)
        tiling_menu.addAction(force_apply_action)
        
        if hasattr(self, 'tiling_control') and self.tiling_control.tiler.is_active:
            # Layout options
            tiling_menu.addSeparator()
            layout_menu = QMenu("üìê Layout", self)
            layout_menu.setStyleSheet(menu.styleSheet())
            
            layouts = ["tall", "wide", "grid", "monocle", "floating"]
            for layout in layouts:
                action = QAction(layout.capitalize(), self)
                action.setCheckable(True)
                action.setChecked(self.tiling_control.tiler.layouts[self.tiling_control.tiler.current_layout] == layout)
                action.triggered.connect(lambda checked, l=layout: self.set_tiling_layout(l))
                layout_menu.addAction(action)
            
            tiling_menu.addMenu(layout_menu)
            
            # Cycle layout
            cycle_action = QAction("üîÑ Cycle Layout", self)
            cycle_action.triggered.connect(self.cycle_tiling_layout)
            tiling_menu.addAction(cycle_action)
            
            # Set master
            master_action = QAction("üéØ Set Master", self)
            master_action.triggered.connect(self.set_tiling_master)
            tiling_menu.addAction(master_action)
            
            tiling_menu.addSeparator()
            
            # Auto-tile toggle
            auto_tile_action = QAction("ü§ñ Auto-tile", self)
            auto_tile_action.setCheckable(True)
            auto_tile_action.setChecked(self.tiling_control.tiler.auto_tile)
            auto_tile_action.triggered.connect(self.toggle_auto_tile)
            tiling_menu.addAction(auto_tile_action)
            
            # Refresh layout
            refresh_action = QAction("üîÑ Refresh Layout", self)
            refresh_action.triggered.connect(self.refresh_layout)
            tiling_menu.addAction(refresh_action)
            
            # Correct alignment
            align_action = QAction("üîß Correct Alignment", self)
            align_action.triggered.connect(self.correct_alignment)
            tiling_menu.addAction(align_action)
            
            # Restart tiler
            restart_action = QAction("üîÑ Restart Tiler", self)
            restart_action.triggered.connect(self.restart_tiler)
            tiling_menu.addAction(restart_action)
        
        menu.addMenu(tiling_menu)
        menu.addSeparator()
        
        # Panel settings
        settings_action = QAction("Û∞íì Panel Settings", self)
        settings_action.triggered.connect(self.show_settings)
        menu.addAction(settings_action)
        menu.addSeparator()
        
        # Position submenu
        position_menu = QMenu("Û∞ñØ Position", self)
        position_menu.setStyleSheet(menu.styleSheet())
        top_action = QAction("Û∞ñù Top", self)
        top_action.setCheckable(True)
        top_action.setChecked(self.config.position == "top")
        top_action.triggered.connect(lambda: self.set_panel_position("top"))
        position_menu.addAction(top_action)
        bottom_action = QAction("Û∞ñî Bottom", self)
        bottom_action.setCheckable(True)
        bottom_action.setChecked(self.config.position == "bottom")
        bottom_action.triggered.connect(lambda: self.set_panel_position("bottom"))
        position_menu.addAction(bottom_action)
        menu.addMenu(position_menu)
        menu.addSeparator()
        
        # Panel height
        height_action = QAction("Û∞ñä Height", self)
        height_action.triggered.connect(self.show_height_dialog)
        menu.addAction(height_action)
        
        # Opacity
        opacity_action = QAction("Û∞óä Opacity", self)
        opacity_action.triggered.connect(self.show_opacity_dialog)
        menu.addAction(opacity_action)
        
        # Auto-hide toggle
        auto_hide_action = QAction("Û∞ñØ Auto-Hide", self)
        auto_hide_action.setCheckable(True)
        auto_hide_action.setChecked(self.config.auto_hide)
        auto_hide_action.triggered.connect(self.toggle_auto_hide)
        menu.addAction(auto_hide_action)
        menu.addSeparator()
        
        # Reload/Restart panel
        reload_action = QAction("Û∞ú∫ Reload Panel", self)
        reload_action.triggered.connect(self.reload_panel)
        menu.addAction(reload_action)
        
        # Quit panel
        quit_action = QAction("Û∞óº Quit Panel", self)
        quit_action.triggered.connect(self.quit_application)
        menu.addAction(quit_action)
        
        menu.exec_(self.mapToGlobal(position))

    def set_clock_font_size(self, size):
        """Quick set clock font size"""
        self.config.clock_font_size = size
        self.update_clock_styles()
        self.save_config()

    def set_date_font_size(self, size):
        """Quick set date font size"""
        self.config.date_font_size = size
        self.update_clock_styles()
        self.save_config()

    def set_clock_color(self, color):
        """Quick set clock color"""
        self.config.clock_color = color
        self.update_clock_styles()
        self.save_config()

    def toggle_seconds(self):
        """Toggle seconds display"""
        self.config.show_seconds = not self.config.show_seconds
        self.update_clock_styles()
        self.save_config()

    def save_config(self):
        """Save configuration"""
        config_manager = ConfigManager()
        config_manager.save_config(self.config)

    # NEW: Tiling control methods
    def toggle_tiling(self):
        """Toggle window tiling"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.toggle_tiling()

    def set_tiling_layout(self, layout_name):
        """Set specific tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.set_layout(layout_name)

    def cycle_tiling_layout(self):
        """Cycle to next tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.cycle_layout()

    def set_tiling_master(self):
        """Set currently focused window as master"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.set_master()

    def restart_tiler(self):
        """Restart the tiler"""
        if hasattr(self, 'tiling_control'):
            print("üîÑ Restarting window tiler")
            self.tiling_control.tiler.is_active = False
            time.sleep(0.5)
            self.tiling_control.tiler.is_active = True
            self.tiling_control.tiler.auto_tile = True
            self.tiling_control.force_apply_layout()

    def set_panel_position(self, position):
        """Set panel position"""
        if position != self.config.position:
            self.config.position = position
            self.update_panel_geometry()
            # Save config
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def show_height_dialog(self):
        """Show dialog to change panel height"""
        height, ok = QInputDialog.getInt(
            self, "Panel Height",
            "Enter panel height (30-100):",
            self.config.height,
            30, 100
        )
        if ok and height != self.config.height:
            self.config.height = height
            self.update_panel_geometry()
            # Save config
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def show_opacity_dialog(self):
        """Show dialog to change panel opacity"""
        opacity, ok = QInputDialog.getDouble(
            self, "Panel Opacity",
            "Enter opacity (0.1-1.0):",
            self.config.opacity,
            0.1, 1.0, 2
        )
        if ok and abs(opacity - self.config.opacity) > 0.01:
            self.config.opacity = opacity
            self.setWindowOpacity(opacity)
            # Save config
            config_manager = ConfigManager()
            config_manager.save_config(self.config)

    def toggle_auto_hide(self):
        """Toggle auto-hide setting"""
        self.config.auto_hide = not self.config.auto_hide
        if self.config.auto_hide:
            self.auto_hide_timer.start(self.config.auto_hide_delay)
        else:
            self.auto_hide_timer.stop()
            if self.is_hidden:
                self.show_panel()
        # Save config
        config_manager = ConfigManager()
        config_manager.save_config(self.config)

    def update_panel_geometry(self):
        """Update panel position and size - STRETCHED TO FULL SCREEN WIDTH"""
        screen = QApplication.primaryScreen()
        screen_rect = screen.availableGeometry()
        # Use full screen width, not just available geometry
        full_screen_rect = screen.geometry()
        if self.config.position == 'top':
            self.setGeometry(0, 0, full_screen_rect.width(), self.config.height)
        else:  # bottom
            y_pos = full_screen_rect.height() - self.config.height
            self.setGeometry(0, y_pos, full_screen_rect.width(), self.config.height)
        # Update strut after geometry change
        QTimer.singleShot(100, self.setup_strut)

    def setup_strut(self):
        """Setup window strut to reserve space for the panel - USING FULL WIDTH"""
        try:
            screen = QApplication.primaryScreen()
            screen_rect = screen.geometry()  # Use full geometry, not available
            # Get the window ID
            window_id = int(self.winId())
            # Calculate strut values based on panel position
            if self.config.position == 'top':
                strut_left = 0
                strut_right = 0
                strut_top = self.config.height
                strut_bottom = 0
                # Partial strut values - use full screen width
                strut_partial = (
                    0, 0, self.config.height, 0,
                    0, 0, 0, 0,
                    0, screen_rect.width(),
                    0, 0
                )
            else:  # bottom
                strut_left = 0
                strut_right = 0
                strut_top = 0
                strut_bottom = self.config.height
                # Partial strut values - use full screen width
                strut_partial = (
                    0, 0, 0, self.config.height,
                    0, 0, 0, 0,
                    0, 0,
                    0, screen_rect.width()
                )
            # Set strut properties
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_STRUT", "32cccc",
                "-set", "_NET_WM_STRUT",
                f"{strut_left}, {strut_right}, {strut_top}, {strut_bottom}"
            ], check=False)
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_STRUT_PARTIAL", "32cccc",
                "-set", "_NET_WM_STRUT_PARTIAL",
                f"{strut_partial[0]}, {strut_partial[1]}, {strut_partial[2]}, {strut_partial[3]}, "
                f"{strut_partial[4]}, {strut_partial[5]}, {strut_partial[6]}, {strut_partial[7]}, "
                f"{strut_partial[8]}, {strut_partial[9]}, {strut_partial[10]}, {strut_partial[11]}"
            ], check=False)
            # Set window type to dock
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_WINDOW_TYPE", "32a",
                "-set", "_NET_WM_WINDOW_TYPE", "_NET_WM_WINDOW_TYPE_DOCK"
            ], check=False)
            # Set state to skip taskbar and pager
            subprocess.run([
                "xprop", "-id", str(window_id),
                "-f", "_NET_WM_STATE", "32a",
                "-set", "_NET_WM_STATE", 
                "_NET_WM_STATE_SKIP_TASKBAR,_NET_WM_STATE_SKIP_PAGER"
            ], check=False)
        except Exception as e:
            print(f"Failed to set strut: {e}")

    def start_timers(self):
        """Start all timers for updating UI elements"""
        # Clock timer
        self.clock_timer = QTimer()
        self.clock_timer.timeout.connect(self.update_clock)
        self.clock_timer.start(1000)  # Update every second
        # Window list timer
        self.window_timer = QTimer()
        self.window_timer.timeout.connect(self.update_windows)
        self.window_timer.start(2000)  # Update every 2 seconds
        # Initial updates
        self.update_clock()
        self.update_windows()




    def toggle_tiling(self):
        """Toggle window tiling"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.toggle_tiling()

    def set_tiling_layout(self, layout_name):
        """Set specific tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.set_layout(layout_name)

    def cycle_tiling_layout(self):
        """Cycle to next tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.cycle_layout()

    def set_tiling_master(self):
        """Set currently focused window as master"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.set_master()

    def force_apply_tiling(self):
        """Force apply tiling layout"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.force_apply_layout()

    def toggle_auto_tile(self):
        """Toggle auto-tiling"""
        if hasattr(self, 'tiling_control'):
            self.tiling_control.tiler.toggle_auto_tile()
            self.tiling_control.update_display()

    def restart_tiler(self):
        """Restart the tiler"""
        if hasattr(self, 'tiling_control'):
            print("üîÑ Restarting window tiler")
            self.tiling_control.tiler.is_active = False
            import time
            time.sleep(0.5)
            self.tiling_control.tiler.is_active = True
            self.tiling_control.tiler.auto_tile = True
            self.tiling_control.force_apply_layout()


















class ConfigManager:
    """Configuration manager for saving/loading settings"""
    def __init__(self, config_file=None):
        if config_file is None:
            config_dir = Path.home() / ".config" / "tokyo-night-panel"
            config_dir.mkdir(parents=True, exist_ok=True)
            config_file = config_dir / "panel.conf"
        self.config_file = Path(config_file)
        self.settings = QSettings(str(self.config_file), QSettings.IniFormat)

    def save_config(self, config: PanelConfig):
        """Save configuration to file"""
        # Basic appearance settings
        self.settings.setValue("position", config.position)
        self.settings.setValue("height", config.height)
        self.settings.setValue("opacity", config.opacity)
        self.settings.setValue("blur_effect", config.blur_effect)
        self.settings.setValue("show_date", config.show_date)
        self.settings.setValue("show_battery", config.show_battery)
        self.settings.setValue("show_volume", config.show_volume)
        self.settings.setValue("show_network", config.show_network)
        self.settings.setValue("show_tray", config.show_tray)
        self.settings.setValue("show_xfce_launchers", config.show_xfce_launchers)
        self.settings.setValue("theme_variant", config.theme_variant)
        self.settings.setValue("rounded_corners", config.rounded_corners)
        self.settings.setValue("corner_radius", config.corner_radius)
        
        # New features
        self.settings.setValue("show_workspace_switcher", config.show_workspace_switcher)
        self.settings.setValue("show_brightness_control", config.show_brightness_control)
        self.settings.setValue("show_weather", config.show_weather)
        self.settings.setValue("show_notifications", config.show_notifications)
        
        # NEW: Network and Bluetooth controls
        self.settings.setValue("show_network_control", config.show_network_control)
        self.settings.setValue("show_bluetooth_control", config.show_bluetooth_control)
        self.settings.setValue("weather_location", config.weather_location)
        
        # NEW: Tiling control
        self.settings.setValue("show_tiling_control", config.show_tiling_control)
        
        # Auto-hide settings
        self.settings.setValue("auto_hide", config.auto_hide)
        self.settings.setValue("auto_hide_delay", config.auto_hide_delay)
        self.settings.setValue("show_on_edge", config.show_on_edge)
        self.settings.setValue("edge_size", config.edge_size)

        # Save built-in launcher commands
        self.settings.setValue("terminal_command", config.terminal_command)
        self.settings.setValue("file_manager_command", config.file_manager_command)
        self.settings.setValue("browser_command", config.browser_command)
        self.settings.setValue("text_editor_command", config.text_editor_command)
        self.settings.setValue("settings_command", config.settings_command)
        self.settings.setValue("calculator_command", config.calculator_command)
        self.settings.setValue("screenshot_command", config.screenshot_command)
        self.settings.setValue("image_viewer_command", config.image_viewer_command)
        self.settings.setValue("music_player_command", config.music_player_command)
        self.settings.setValue("music_player_args", config.music_player_args)

        # Save custom launchers from panel context menu
        if hasattr(config, 'custom_launchers'):
            self.settings.setValue("custom_launchers", config.custom_launchers)
            print(f"DEBUG: Saved {len(config.custom_launchers)} custom launchers to config")
        else:
            self.settings.setValue("custom_launchers", [])
            print("DEBUG: No custom_launchers attribute found, saving empty list")

        # Save custom launchers (from SettingsDialog)
        if config.launcher_customizations:
            launchers_data = []
            for launcher in config.launcher_customizations:
                # Convert the Application dataclass to a dictionary
                launcher_dict = {
                    'name': launcher.name,
                    'command': launcher.command,
                    'icon': launcher.icon,
                    'args': launcher.args,
                    'workspace': launcher.workspace  # Save workspace setting
                }
                launchers_data.append(launcher_dict)
            self.settings.setValue("launcher_customizations", launchers_data)
            print(f"DEBUG: ConfigManager saved {len(launchers_data)} custom launchers from SettingsDialog")
        else:
            self.settings.setValue("launcher_customizations", [])
            print("DEBUG: ConfigManager saved empty custom launchers list from SettingsDialog")
        
        # NEW: Clock settings
        self.settings.setValue("clock_font_size", config.clock_font_size)
        self.settings.setValue("date_font_size", config.date_font_size)
        self.settings.setValue("clock_color", config.clock_color)
        self.settings.setValue("date_color", config.date_color)
        self.settings.setValue("clock_font_weight", config.clock_font_weight)
        self.settings.setValue("date_font_weight", config.date_font_weight)
        self.settings.setValue("show_seconds", config.show_seconds)
        self.settings.setValue("date_format", config.date_format)
        self.settings.setValue("time_format", config.time_format)
        
        self.settings.sync()
        print("DEBUG: ConfigManager finished saving all settings")

    def load_config(self) -> PanelConfig:
        """Load configuration from file"""
        config = PanelConfig()
        
        # Basic appearance settings
        config.position = self.settings.value("position", "top", type=str)
        config.height = self.settings.value("height", 40, type=int)
        config.opacity = self.settings.value("opacity", 0.95, type=float)
        config.blur_effect = self.settings.value("blur_effect", True, type=bool)
        config.show_date = self.settings.value("show_date", True, type=bool)
        config.show_battery = self.settings.value("show_battery", True, type=bool)
        config.show_volume = self.settings.value("show_volume", True, type=bool)
        config.show_network = self.settings.value("show_network", False, type=bool)
        config.show_tray = self.settings.value("show_tray", True, type=bool)
        config.show_xfce_launchers = self.settings.value("show_xfce_launchers", True, type=bool)
        config.theme_variant = self.settings.value("theme_variant", "tokyo_night", type=str)
        config.rounded_corners = self.settings.value("rounded_corners", True, type=bool)
        config.corner_radius = self.settings.value("corner_radius", 10, type=int)
        
        # New features
        config.show_workspace_switcher = self.settings.value("show_workspace_switcher", True, type=bool)
        config.show_brightness_control = self.settings.value("show_brightness_control", True, type=bool)
        config.show_weather = self.settings.value("show_weather", True, type=bool)
        config.show_notifications = self.settings.value("show_notifications", True, type=bool)
        
        # NEW: Network and Bluetooth controls
        config.show_network_control = self.settings.value("show_network_control", True, type=bool)
        config.show_bluetooth_control = self.settings.value("show_bluetooth_control", True, type=bool)
        config.weather_location = self.settings.value("weather_location", "", type=str)
        
        # NEW: Tiling control
        config.show_tiling_control = self.settings.value("show_tiling_control", True, type=bool)
        
        # Auto-hide settings
        config.auto_hide = self.settings.value("auto_hide", False, type=bool)
        config.auto_hide_delay = self.settings.value("auto_hide_delay", 2000, type=int)
        config.show_on_edge = self.settings.value("show_on_edge", True, type=bool)
        config.edge_size = self.settings.value("edge_size", 5, type=int)

        # Load built-in launcher commands
        config.terminal_command = self.settings.value("terminal_command", "xfce4-terminal", type=str)
        config.file_manager_command = self.settings.value("file_manager_command", "thunar", type=str)
        config.browser_command = self.settings.value("browser_command", "firefox", type=str)
        config.text_editor_command = self.settings.value("text_editor_command", "mousepad", type=str)
        config.settings_command = self.settings.value("settings_command", "xfce4-settings-manager", type=str)
        config.calculator_command = self.settings.value("calculator_command", "gnome-calculator", type=str)
        config.screenshot_command = self.settings.value("screenshot_command", "xfce4-screenshooter", type=str)
        config.image_viewer_command = self.settings.value("image_viewer_command", "ristretto", type=str)
        config.music_player_command = self.settings.value("music_player_command", "vlc", type=str)
        config.music_player_args = self.settings.value("music_player_args", "", type=str)

        # Load custom launchers from panel context menu
        config.custom_launchers = self.settings.value("custom_launchers", [], type=list)
        print(f"DEBUG: Loaded {len(config.custom_launchers)} custom launchers from config")

        # Load custom launchers (from SettingsDialog)
        config.launcher_customizations = []
        launchers_data = self.settings.value("launcher_customizations", [])
        
        if launchers_data:
            for launcher_dict in launchers_data:
                try:
                    # Handle both string and dict formats
                    if isinstance(launcher_dict, str):
                        # Legacy format - skip or convert if needed
                        continue
                    elif isinstance(launcher_dict, dict):
                        # Create Application object from dictionary
                        launcher = Application(
                            name=launcher_dict.get('name', ''),
                            command=launcher_dict.get('command', ''),
                            icon=launcher_dict.get('icon', 'üöÄ'),
                            args=launcher_dict.get('args', ''),
                            workspace=launcher_dict.get('workspace', -1)  # Load workspace setting
                        )
                        config.launcher_customizations.append(launcher)
                except Exception as e:
                    print(f"Error loading launcher: {e}")
        
        # NEW: Clock settings
        config.clock_font_size = self.settings.value("clock_font_size", 11, type=int)
        config.date_font_size = self.settings.value("date_font_size", 8, type=int)
        config.clock_color = self.settings.value("clock_color", TokyoNight.MOON_GLOW, type=str)
        config.date_color = self.settings.value("date_color", TokyoNight.FOREGROUND, type=str)
        config.clock_font_weight = self.settings.value("clock_font_weight", "bold", type=str)
        config.date_font_weight = self.settings.value("date_font_weight", "normal", type=str)
        config.show_seconds = self.settings.value("show_seconds", False, type=bool)
        config.date_format = self.settings.value("date_format", "ddd MMM d", type=str)
        config.time_format = self.settings.value("time_format", "hh:mm AP", type=str)
        
        print(f"DEBUG: ConfigManager loaded {len(config.launcher_customizations)} custom launchers from SettingsDialog")
        print(f"DEBUG: ConfigManager finished loading all settings")
        
        return config

class TrayIconManager:
    """System tray icon manager"""
    def __init__(self, panel):
        self.panel = panel
        self.tray_icon = QSystemTrayIcon(self.create_icon(), panel)
        self.setup_tray_menu()

    def create_icon(self):
        """Create tray icon with Tokyo Night colors"""
        pixmap = QPixmap(32, 32)
        pixmap.fill(QColor(TokyoNight.NIGHT_TOP))
        painter = QPainter(pixmap)
        painter.setRenderHint(QPainter.Antialiasing)
        # Draw Tokyo Night styled icon with moon theme
        gradient = QLinearGradient(0, 0, 32, 32)
        gradient.setColorAt(0, QColor(TokyoNight.MOON_GLOW))
        gradient.setColorAt(1, QColor(TokyoNight.BLUE))
        painter.setBrush(gradient)
        painter.setPen(Qt.NoPen)
        painter.drawRoundedRect(4, 4, 24, 24, 6, 6)
        # Draw moon crescent
        painter.setBrush(QColor(TokyoNight.NIGHT_TOP))
        painter.drawEllipse(18, 8, 10, 10)
        painter.end()
        return QIcon(pixmap)

    def setup_tray_menu(self):
        """Setup tray icon context menu"""
        menu = QMenu()
        menu.setStyleSheet(self.panel.get_stylesheet())
        show_action = QAction("Û∞Äæ Show Panel", self.panel)
        show_action.triggered.connect(self.panel.show_panel)
        menu.addAction(show_action)
        hide_action = QAction("Û∞ñØ Hide Panel", self.panel)
        hide_action.triggered.connect(self.panel.hide_panel)
        menu.addAction(hide_action)
        menu.addSeparator()
        settings_action = QAction("Û∞íì Settings", self.panel)
        settings_action.triggered.connect(self.panel.show_settings)
        menu.addAction(settings_action)
        menu.addSeparator()
        restart_action = QAction("Û∞ú∫ Restart", self.panel)
        restart_action.triggered.connect(self.panel.restart_panel)
        menu.addAction(restart_action)
        quit_action = QAction("Û∞óº Quit", self.panel)
        quit_action.triggered.connect(self.panel.quit_application)
        menu.addAction(quit_action)
        self.tray_icon.setContextMenu(menu)
        self.tray_icon.activated.connect(self.tray_icon_activated)

    def tray_icon_activated(self, reason):
        """Handle tray icon activation"""
        if reason == QSystemTrayIcon.DoubleClick:
            if self.panel.isVisible():
                self.panel.hide_panel()
            else:
                self.panel.show_panel()

    def show(self):
        """Show tray icon"""
        self.tray_icon.show()

    def show_message(self, title, message, timeout=3000):
        """Show tray notification"""
        self.tray_icon.showMessage(title, message, QSystemTrayIcon.Information, timeout)

class XfceLauncherReader:
    """Read XFCE panel launchers from configuration files"""
    def __init__(self):
        self.config_dir = Path.home() / ".config" / "xfce4" / "panel"
        self.launchers_dir = Path.home() / ".config" / "xfce4" / "panel" / "launchers"

    def get_xfce_launchers(self):
        """Get XFCE panel launchers"""
        launchers = []
        try:
            # Find launcher directories
            if not self.launchers_dir.exists():
                return launchers
            
            # Read each launcher file
            for launcher_file in self.launchers_dir.glob("*.desktop"):
                launcher = self.parse_launcher_file(launcher_file)
                if launcher:
                    launchers.append(launcher)
        except Exception as e:
            print(f"Error reading XFCE launchers: {e}")
        return launchers

    def parse_launcher_file(self, file_path):
        """Parse a single launcher .desktop file"""
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Parse desktop file
            name = ""
            command = ""
            icon = ""
            
            for line in content.splitlines():
                if line.startswith("Name="):
                    name = line.split("=", 1)[1]
                elif line.startswith("Exec="):
                    command = line.split("=", 1)[1]
                    # Remove %U, %F, etc. from command
                    command = re.sub(r'\s%[fFuU]', '', command)
                elif line.startswith("Icon="):
                    icon = line.split("=", 1)[1]
            
            if name and command:
                # Try to get icon from theme or use emoji fallback
                if icon:
                    # Check if it's a file path
                    if os.path.exists(icon):
                        # For file icons, we'll use a generic emoji
                        icon = "üöÄ"
                    else:
                        # For theme icons, we'll use a generic emoji
                        icon = "üöÄ"
                else:
                    # Fallback icon based on command
                    if "terminal" in command.lower():
                        icon = "Û∞Üç"
                    elif "browser" in command.lower() or "firefox" in command.lower():
                        icon = "Û∞àπ"
                    elif "file" in command.lower() or "thunar" in command.lower():
                        icon = "Û∞âã"
                    elif "text" in command.lower() or "editor" in command.lower():
                        icon = "Û∞à¨"
                    elif "settings" in command.lower():
                        icon = "Û∞É§"
                    elif "calculator" in command.lower():
                        icon = "Û∞éÅ"
                    elif "screenshot" in command.lower():
                        icon = "Û∞äì"
                    elif "image" in command.lower() or "viewer" in command.lower():
                        icon = "Û∞ª≠"
                    elif "music" in command.lower() or "vlc" in command.lower():
                        icon = "Û∞éÑ"
                    else:
                        icon = "üöÄ"
                
                return Application(name=name, command=command, icon=icon)
        except Exception as e:
            print(f"Error parsing launcher file {file_path}: {e}")
        return None

def main():
    """Main application entry point"""
    # Set up high DPI scaling
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)
    QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)
    app = QApplication(sys.argv)
    app.setApplicationName("Tokyo Night Panel")
    app.setApplicationVersion("1.0.0")
    # Set up system tray with better error handling
    tray_available = QSystemTrayIcon.isSystemTrayAvailable()
    if not tray_available:
        print("System tray is not available, panel will run without tray icon")
        # Don't set quit on last window closed, so panel stays open
        app.setQuitOnLastWindowClosed(False)
    else:
        app.setQuitOnLastWindowClosed(False)
    # Load configuration
    config_manager = ConfigManager()
    config = config_manager.load_config()
    # Create and show panel
    panel = TokyoNightPanelBar(config)
    panel.show()
    # Setup system tray only if available
    if tray_available:
        try:
            tray_manager = TrayIconManager(panel)
            tray_manager.show()
            tray_manager.show_message("Tokyo Night Panel", "Panel started successfully")
        except Exception as e:
            print(f"Failed to create system tray icon: {e}")
    # Save config on exit
    def save_on_exit():
        config_manager.save_config(panel.config)
    app.aboutToQuit.connect(save_on_exit)
    # Handle SIGTERM for graceful shutdown
    def handle_signal(signum, frame):
        save_on_exit()
        QApplication.quit()
    signal.signal(signal.SIGTERM, handle_signal)
    signal.signal(signal.SIGINT, handle_signal)
    return app.exec_()

if __name__ == "__main__":
    sys.exit(main())