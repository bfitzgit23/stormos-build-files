#!/usr/bin/env python3
import sys
import os
import shutil
import mimetypes
import json
from datetime import datetime
from pathlib import Path
from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *
import subprocess
import platform
import psutil
import stat
import tempfile
import time
import glob
import re
import getpass
import tarfile
import zipfile
import shlex

# Try to import PIL, make it optional
try:
    from PIL import Image
    PIL_AVAILABLE = True
except ImportError:
    PIL_AVAILABLE = False

class FileOperations:
    """Handles advanced file operations"""
    
    @staticmethod
    def create_symlink(source, destination):
        """Create symbolic link"""
        try:
            os.symlink(source, destination)
            return True
        except Exception as e:
            print(f"Error creating symlink: {e}")
            return False
    
    @staticmethod
    def change_permissions(path, mode):
        """Change file permissions"""
        try:
            os.chmod(path, mode)
            return True
        except Exception as e:
            print(f"Error changing permissions: {e}")
            return False
    
    @staticmethod
    def change_ownership(path, user=None, group=None):
        """Change file ownership (requires root)"""
        try:
            uid = -1
            gid = -1
            
            if user:
                import pwd
                uid = pwd.getpwnam(user).pw_uid
            if group:
                import grp
                gid = grp.getgrnam(group).gr_gid
            
            os.chown(path, uid, gid)
            return True
        except Exception as e:
            print(f"Error changing ownership: {e}")
            return False
    
    @staticmethod
    def create_archive(files, archive_path):
        """Create compressed archive"""
        try:
            if archive_path.endswith('.tar.gz') or archive_path.endswith('.tgz'):
                with tarfile.open(archive_path, 'w:gz') as tar:
                    for file_path in files:
                        tar.add(file_path, arcname=os.path.basename(file_path))
            elif archive_path.endswith('.tar.bz2'):
                with tarfile.open(archive_path, 'w:bz2') as tar:
                    for file_path in files:
                        tar.add(file_path, arcname=os.path.basename(file_path))
            elif archive_path.endswith('.zip'):
                with zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for file_path in files:
                        zipf.write(file_path, arcname=os.path.basename(file_path))
            else:
                # Default to zip
                with zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                    for file_path in files:
                        zipf.write(file_path, arcname=os.path.basename(file_path))
            return True
        except Exception as e:
            print(f"Error creating archive: {e}")
            return False
    
    @staticmethod
    def extract_archive(archive_path, extract_to=None):
        """Extract compressed archive"""
        try:
            if extract_to is None:
                extract_to = os.path.dirname(archive_path)
            
            if archive_path.endswith('.tar.gz') or archive_path.endswith('.tgz'):
                with tarfile.open(archive_path, 'r:gz') as tar:
                    tar.extractall(extract_to)
            elif archive_path.endswith('.tar.bz2'):
                with tarfile.open(archive_path, 'r:bz2') as tar:
                    tar.extractall(extract_to)
            elif archive_path.endswith('.tar'):
                with tarfile.open(archive_path, 'r:') as tar:
                    tar.extractall(extract_to)
            elif archive_path.endswith('.zip'):
                with zipfile.ZipFile(archive_path, 'r') as zipf:
                    zipf.extractall(extract_to)
            else:
                return False
            return True
        except Exception as e:
            print(f"Error extracting archive: {e}")
            return False

    @staticmethod
    def get_unique_filename(destination_path):
        """Generate a unique filename if the destination already exists"""
        if not os.path.exists(destination_path):
            return destination_path
        
        base, ext = os.path.splitext(destination_path)
        counter = 1
        while True:
            new_path = f"{base} ({counter}){ext}"
            if not os.path.exists(new_path):
                return new_path
            counter += 1

class TerminalLauncher:
    """Handles terminal operations"""
    
    @staticmethod
    def get_available_terminals():
        """Get list of available terminals"""
        terminals = [
            ('gnome-terminal', ['--working-directory']),
            ('konsole', ['--workdir']),
            ('xfce4-terminal', ['--default-working-directory']),
            ('terminator', ['--working-directory']),
            ('tilix', ['-w']),
            ('urxvt', ['-cd']),
            ('xterm', ['-e', 'bash -c "cd {}; bash"']),
            ('alacritty', ['--working-directory']),
            ('kitty', ['--directory']),
        ]
        available = []
        for term, args in terminals:
            if shutil.which(term):
                available.append((term, args))
        return available
    
    @staticmethod
    def open_terminal(path):
        """Open terminal at specified path"""
        terminals = TerminalLauncher.get_available_terminals()
        if not terminals:
            return False
        
        term, args = terminals[0]  # Use first available terminal
        try:
            if term == 'xterm':
                # Special handling for xterm
                cmd = ['xterm', '-e', f'bash -c "cd {shlex.quote(path)}; bash"']
            else:
                cmd = [term] + args + [path]
            
            subprocess.Popen(cmd)
            return True
        except Exception as e:
            print(f"Error opening terminal: {e}")
            return False

    @staticmethod
    def open_terminal_as_root(path):
        """Open terminal as root at specified path using sudo"""
        terminals = TerminalLauncher.get_available_terminals()
        if not terminals:
            return False
        
        term, args = terminals[0]  # Use first available terminal
        
        try:
            if term == 'xterm':
                # Special handling for xterm with sudo
                cmd = ['sudo', 'xterm', '-e', f'bash -c "cd {shlex.quote(path)}; bash"']
            else:
                cmd = ['sudo', term] + args + [path]
            
            subprocess.Popen(cmd)
            return True
        except Exception as e:
            print(f"Error opening terminal as root: {e}")
            return False

class FilePropertiesDialog(QDialog):
    """Advanced file properties dialog"""
    
    def __init__(self, paths, parent=None):
        super().__init__(parent)
        self.paths = paths if isinstance(paths, list) else [paths]
        self.setWindowTitle("Properties")
        self.setModal(True)
        self.setMinimumWidth(500)
        self.setup_ui()
        self.load_properties()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Tab widget for different property categories
        tabs = QTabWidget()
        
        # Basic tab
        basic_tab = QWidget()
        basic_layout = QVBoxLayout(basic_tab)
        self.basic_widget = self.create_basic_widget()
        basic_layout.addWidget(self.basic_widget)
        
        # Permissions tab
        perm_tab = QWidget()
        perm_layout = QVBoxLayout(perm_tab)
        self.perm_widget = self.create_permissions_widget()
        perm_layout.addWidget(self.perm_widget)
        
        tabs.addTab(basic_tab, "Basic")
        tabs.addTab(perm_tab, "Permissions")
        
        layout.addWidget(tabs)
        
        # Buttons
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
    
    def create_basic_widget(self):
        widget = QWidget()
        layout = QFormLayout(widget)
        
        self.name_label = QLabel()
        self.path_label = QLabel()
        self.type_label = QLabel()
        self.size_label = QLabel()
        self.modified_label = QLabel()
        self.accessed_label = QLabel()
        
        layout.addRow("Name:", self.name_label)
        layout.addRow("Path:", self.path_label)
        layout.addRow("Type:", self.type_label)
        layout.addRow("Size:", self.size_label)
        layout.addRow("Modified:", self.modified_label)
        layout.addRow("Accessed:", self.accessed_label)
        
        return widget
    
    def create_permissions_widget(self):
        widget = QWidget()
        layout = QVBoxLayout(widget)
        
        # Owner permissions
        owner_group = QGroupBox("Owner")
        owner_layout = QHBoxLayout(owner_group)
        
        self.owner_read = QCheckBox("Read")
        self.owner_write = QCheckBox("Write")
        self.owner_execute = QCheckBox("Execute")
        
        owner_layout.addWidget(self.owner_read)
        owner_layout.addWidget(self.owner_write)
        owner_layout.addWidget(self.owner_execute)
        
        # Group permissions
        group_group = QGroupBox("Group")
        group_layout = QHBoxLayout(group_group)
        
        self.group_read = QCheckBox("Read")
        self.group_write = QCheckBox("Write")
        self.group_execute = QCheckBox("Execute")
        
        group_layout.addWidget(self.group_read)
        group_layout.addWidget(self.group_write)
        group_layout.addWidget(self.group_execute)
        
        # Others permissions
        others_group = QGroupBox("Others")
        others_layout = QHBoxLayout(others_group)
        
        self.others_read = QCheckBox("Read")
        self.others_write = QCheckBox("Write")
        self.others_execute = QCheckBox("Execute")
        
        others_layout.addWidget(self.others_read)
        others_layout.addWidget(self.others_write)
        others_layout.addWidget(self.others_execute)
        
        layout.addWidget(owner_group)
        layout.addWidget(group_group)
        layout.addWidget(others_group)
        
        # Connect signals
        self.owner_read.toggled.connect(self.update_permissions)
        self.owner_write.toggled.connect(self.update_permissions)
        self.owner_execute.toggled.connect(self.update_permissions)
        self.group_read.toggled.connect(self.update_permissions)
        self.group_write.toggled.connect(self.update_permissions)
        self.group_execute.toggled.connect(self.update_permissions)
        self.others_read.toggled.connect(self.update_permissions)
        self.others_write.toggled.connect(self.update_permissions)
        self.others_execute.toggled.connect(self.update_permissions)
        
        return widget
    
    def load_properties(self):
        if not self.paths:
            return
        
        path = self.paths[0]
        stat_info = os.stat(path)
        
        # Basic info
        self.name_label.setText(os.path.basename(path))
        self.path_label.setText(path)
        
        if os.path.isdir(path):
            self.type_label.setText("Directory")
        else:
            mime_type, _ = mimetypes.guess_type(path)
            self.type_label.setText(mime_type or "Unknown")
        
        # Size
        if os.path.isfile(path):
            size = stat_info.st_size
            self.size_label.setText(self.format_size(size))
        else:
            self.size_label.setText("Calculating...")
            # Calculate directory size in background
            QTimer.singleShot(100, self.calculate_directory_size)
        
        # Dates
        self.modified_label.setText(datetime.fromtimestamp(stat_info.st_mtime).strftime('%Y-%m-%d %H:%M:%S'))
        self.accessed_label.setText(datetime.fromtimestamp(stat_info.st_atime).strftime('%Y-%m-%d %H:%M:%S'))
        
        # Permissions
        self.load_permissions(stat_info.st_mode)
    
    def calculate_directory_size(self):
        if not self.paths:
            return
        
        path = self.paths[0]
        if os.path.isdir(path):
            total_size = 0
            for dirpath, dirnames, filenames in os.walk(path):
                for filename in filenames:
                    filepath = os.path.join(dirpath, filename)
                    try:
                        total_size += os.path.getsize(filepath)
                    except OSError:
                        pass
            self.size_label.setText(self.format_size(total_size))
    
    def format_size(self, size):
        """Format file size in human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} PB"
    
    def load_permissions(self, mode):
        """Load current permissions into checkboxes"""
        # Owner permissions
        self.owner_read.setChecked(mode & stat.S_IRUSR)
        self.owner_write.setChecked(mode & stat.S_IWUSR)
        self.owner_execute.setChecked(mode & stat.S_IXUSR)
        
        # Group permissions
        self.group_read.setChecked(mode & stat.S_IRGRP)
        self.group_write.setChecked(mode & stat.S_IWGRP)
        self.group_execute.setChecked(mode & stat.S_IXGRP)
        
        # Others permissions
        self.others_read.setChecked(mode & stat.S_IROTH)
        self.others_write.setChecked(mode & stat.S_IWOTH)
        self.others_execute.setChecked(mode & stat.S_IXOTH)
    
    def update_permissions(self):
        """Update file permissions based on checkbox states"""
        if not self.paths:
            return
        
        mode = 0
        # Owner
        if self.owner_read.isChecked(): mode |= stat.S_IRUSR
        if self.owner_write.isChecked(): mode |= stat.S_IWUSR
        if self.owner_execute.isChecked(): mode |= stat.S_IXUSR
        # Group
        if self.group_read.isChecked(): mode |= stat.S_IRGRP
        if self.group_write.isChecked(): mode |= stat.S_IWGRP
        if self.group_execute.isChecked(): mode |= stat.S_IXGRP
        # Others
        if self.others_read.isChecked(): mode |= stat.S_IROTH
        if self.others_write.isChecked(): mode |= stat.S_IWOTH
        if self.others_execute.isChecked(): mode |= stat.S_IXOTH
        
        for path in self.paths:
            try:
                os.chmod(path, mode)
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Could not change permissions for {path}: {e}")

class SettingsManager:
    """Manages application settings persistence"""
    def __init__(self):
        self.settings_file = os.path.expanduser("~/.dark_nemo_settings.json")
        self.settings = {
            'default_view_mode': 'detail',  # Can be 'icon', 'list', or 'detail'
            'window_geometry': None,
            'window_state': None,
            'show_hidden_files': False,  # Add setting for hidden files
            'window_size': None,  # Store window size separately
            'window_position': None,  # Store window position
            'splitter_sizes': [300, 900]  # Store splitter sizes - FIXED: Default value instead of None
        }
        self.load_settings()

    def load_settings(self):
        """Load settings from file"""
        try:
            if os.path.exists(self.settings_file):
                with open(self.settings_file, 'r') as f:
                    loaded_settings = json.load(f)
                    # Update with loaded settings, but keep defaults for missing keys
                    for key, value in loaded_settings.items():
                        if key in self.settings:
                            self.settings[key] = value
        except Exception as e:
            print(f"Error loading settings: {e}")

    def save_settings(self):
        """Save settings to file"""
        try:
            with open(self.settings_file, 'w') as f:
                json.dump(self.settings, f)
            return True
        except Exception as e:
            print(f"Error saving settings: {e}")
            return False

    def get_setting(self, key, default=None):
        """Get a setting value"""
        value = self.settings.get(key, default)
        
        # Special handling for splitter_sizes to ensure it's always a list
        if key == 'splitter_sizes' and (value is None or not isinstance(value, list)):
            return [300, 900]  # Return default splitter sizes
            
        return value

    def set_setting(self, key, value):
        """Set a setting value"""
        if key in self.settings:
            self.settings[key] = value
            return self.save_settings()
        return False

class BookmarkManager:
    """Manages bookmark persistence"""
    def __init__(self):
        self.bookmarks_file = os.path.expanduser("~/.dark_nemo_bookmarks.json")
        self.bookmarks = []
        self.load_bookmarks()

    def load_bookmarks(self):
        """Load bookmarks from file"""
        try:
            if os.path.exists(self.bookmarks_file):
                with open(self.bookmarks_file, 'r') as f:
                    self.bookmarks = json.load(f)
        except Exception as e:
            print(f"Error loading bookmarks: {e}")
            self.bookmarks = []

    def save_bookmarks(self):
        """Save bookmarks to file"""
        try:
            with open(self.bookmarks_file, 'w') as f:
                json.dump(self.bookmarks, f)
            return True
        except Exception as e:
            print(f"Error saving bookmarks: {e}")
            return False

    def add_bookmark(self, name, path):
        """Add a new bookmark"""
        # Check if already bookmarked
        for bookmark in self.bookmarks:
            if bookmark['path'] == path:
                return False
        self.bookmarks.append({'name': name, 'path': path})
        return self.save_bookmarks()

    def remove_bookmark(self, path):
        """Remove a bookmark by path"""
        self.bookmarks = [b for b in self.bookmarks if b['path'] != path]
        return self.save_bookmarks()

    def update_bookmark(self, old_path, name, path):
        """Update an existing bookmark"""
        for bookmark in self.bookmarks:
            if bookmark['path'] == old_path:
                bookmark['name'] = name
                bookmark['path'] = path
                return self.save_bookmarks()
        return False

class ThumbnailCache:
    """Cache for storing generated thumbnails"""
    def __init__(self):
        self.cache_dir = os.path.join(tempfile.gettempdir(), "dark_nemo_thumbnails")
        os.makedirs(self.cache_dir, exist_ok=True)

    def get_thumbnail_path(self, file_path, size=(128, 128)):
        """Get cached thumbnail path or generate new one"""
        # Create a unique cache key
        try:
            mtime = os.path.getmtime(file_path)
        except OSError:
            return None
        cache_key = f"{hash(file_path)}_{mtime}_{size[0]}x{size[1]}.png"
        cache_path = os.path.join(self.cache_dir, cache_key)
        # Return cached thumbnail if exists
        if os.path.exists(cache_path):
            return cache_path
        # Generate new thumbnail
        if self.generate_thumbnail(file_path, cache_path, size):
            return cache_path
        return None

    def generate_thumbnail(self, file_path, cache_path, size):
        """Generate thumbnail for file"""
        try:
            mime_type, _ = mimetypes.guess_type(file_path)
            if mime_type and mime_type.startswith('image/') and PIL_AVAILABLE:
                # Generate image thumbnail
                with Image.open(file_path) as img:
                    img.thumbnail(size, Image.Resampling.LANCZOS if hasattr(Image, 'Resampling') else Image.ANTIALIAS)
                    img.save(cache_path, "PNG")
                    return True
            elif mime_type and mime_type.startswith('video/'):
                # Generate video thumbnail using ffmpegthumbnailer
                try:
                    cmd = [
                        'ffmpegthumbnailer',
                        '-i', file_path,
                        '-o', cache_path,
                        '-s', str(size[0]),
                        '-f', 'png',
                        '-t', '10'  # Thumbnail at 10 seconds
                    ]
                    subprocess.run(cmd, check=True, capture_output=True)
                    return True
                except (subprocess.CalledProcessError, FileNotFoundError):
                    # Fallback to ffmpeg if ffmpegthumbnailer is not available
                    try:
                        cmd = [
                            'ffmpeg',
                            '-i', file_path,
                            '-ss', '00:00:10.000',
                            '-vframes', '1',
                            '-vf', f'scale={size[0]}:{size[1]}',
                            '-y',
                            cache_path
                        ]
                        subprocess.run(cmd, check=True, capture_output=True)
                        return True
                    except (subprocess.CalledProcessError, FileNotFoundError):
                        pass
            return False
        except Exception:
            return False

class FileSystemModel(QFileSystemModel):
    """Custom file system model with thumbnail support"""
    def __init__(self):
        super().__init__()
        self.setRootPath(QDir.homePath())
        self.setFilter(QDir.AllEntries | QDir.NoDotAndDotDot)
        self.setNameFilterDisables(False)
        self.thumbnail_cache = ThumbnailCache()
        self.icon_provider = QFileIconProvider()
        # Get application style for icons
        self.app_style = QApplication.style()
        # Add a flag to track if hidden files should be shown
        self.show_hidden_files = False

    def setShowHiddenFiles(self, show):
        """Toggle visibility of hidden files"""
        if self.show_hidden_files != show:
            self.show_hidden_files = show
            # Update the filter based on the flag
            if show:
                self.setFilter(QDir.AllEntries | QDir.NoDotAndDotDot | QDir.Hidden)
            else:
                self.setFilter(QDir.AllEntries | QDir.NoDotAndDotDot)
            # Refresh the model
            self.setRootPath(self.rootPath())

    def data(self, index, role=Qt.DisplayRole):
        if role == Qt.DecorationRole and index.column() == 0:
            path = self.filePath(index)
            # Generate thumbnail for images and videos
            if os.path.isfile(path):
                thumbnail_path = self.thumbnail_cache.get_thumbnail_path(path)
                if thumbnail_path:
                    pixmap = QPixmap(thumbnail_path)
                    if not pixmap.isNull():
                        return QIcon(pixmap)
            # Fallback to default icons
            if os.path.isdir(path):
                return self.icon_provider.icon(QFileInfo(path))
            else:
                return self.get_file_icon(path)
        return super().data(index, role)

    def get_file_icon(self, path):
        """Get appropriate icon for file type"""
        ext = os.path.splitext(path)[1].lower()
        # Video files
        video_exts = ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v']
        if ext in video_exts:
            return self.app_style.standardIcon(QStyle.SP_MediaPlay)
        # Image files
        image_exts = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg', '.tiff', '.webp']
        if ext in image_exts:
            return self.app_style.standardIcon(QStyle.SP_DialogSaveButton)
        # Audio files
        audio_exts = ['.mp3', '.wav', '.flac', '.ogg', '.m4a', '.aac']
        if ext in audio_exts:
            return self.app_style.standardIcon(QStyle.SP_MediaVolume)
        # Archive files
        archive_exts = ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2']
        if ext in archive_exts:
            return self.app_style.standardIcon(QStyle.SP_DirIcon)
        # Code files
        code_exts = ['.py', '.js', '.html', '.css', '.cpp', '.c', '.java', '.php', '.rb', '.go']
        if ext in code_exts:
            return self.app_style.standardIcon(QStyle.SP_FileDialogDetailedView)
        # Document files
        doc_exts = ['.pdf', '.doc', '.docx', '.txt', '.odt']
        if ext in doc_exts:
            return self.app_style.standardIcon(QStyle.SP_FileIcon)
        return self.icon_provider.icon(QFileInfo(path))

class DragDropListView(QListView):
    """Custom ListView with drag and drop support"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDropIndicatorShown(True)
        self.setDragDropMode(QAbstractItemView.DragDrop)
        self.setDefaultDropAction(Qt.CopyAction)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        
    def dragEnterEvent(self, event):
        """Handle drag enter event"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            super().dragEnterEvent(event)
    
    def dragMoveEvent(self, event):
        """Handle drag move event"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            super().dragMoveEvent(event)
    
    def dropEvent(self, event):
        """Handle drop event"""
        if event.mimeData().hasUrls():
            # Get the parent file manager
            parent = self.parent()
            while parent and not hasattr(parent, 'handle_drop_event'):
                parent = parent.parent()
            
            if parent:
                parent.handle_drop_event(event, self)
        else:
            super().dropEvent(event)

class DragDropTreeView(QTreeView):
    """Custom TreeView with drag and drop support"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDragEnabled(True)
        self.setAcceptDrops(True)
        self.setDropIndicatorShown(True)
        self.setDragDropMode(QAbstractItemView.DragDrop)
        self.setDefaultDropAction(Qt.CopyAction)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)
        
    def dragEnterEvent(self, event):
        """Handle drag enter event"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            super().dragEnterEvent(event)
    
    def dragMoveEvent(self, event):
        """Handle drag move event"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            super().dragMoveEvent(event)
    
    def dropEvent(self, event):
        """Handle drop event"""
        if event.mimeData().hasUrls():
            # Get the parent file manager
            parent = self.parent()
            while parent and not hasattr(parent, 'handle_drop_event'):
                parent = parent.parent()
            
            if parent:
                parent.handle_drop_event(event, self)
        else:
            super().dropEvent(event)

class AutoMounter(QThread):
    """Thread for automatically mounting USB devices with proper permission handling"""
    mount_success = pyqtSignal(str, str)  # device, mount_point
    mount_failed = pyqtSignal(str, str)   # device, error

    def __init__(self):
        super().__init__()
        self.running = True
        self.mount_queue = []
        self.username = getpass.getuser()
        self.uid = os.getuid()
        self.gid = os.getgid()
        self.actual_mount_point = None  # Store the actual mount point

    def run(self):
        while self.running:
            if self.mount_queue:
                device = self.mount_queue.pop(0)
                self.try_mount_device(device)
            time.sleep(1)

    def add_device(self, device):
        """Add device to mount queue"""
        if device not in self.mount_queue:
            self.mount_queue.append(device)

    def try_mount_device(self, device):
        """Try to mount a device with proper permission handling"""
        if platform.system() != "Linux":
            return
        try:
            print(f"AutoMounter: Attempting to mount {device}")
            
            # Check if device is already mounted
            result = subprocess.run(['findmnt', '-n', '-o', 'TARGET', '-S', device], 
                                  capture_output=True, text=True)
            if result.returncode == 0 and result.stdout.strip():
                print(f"AutoMounter: {device} is already mounted at {result.stdout.strip()}")
                self.mount_success.emit(device, result.stdout.strip())
                return  # Already mounted
            
            # Try udisks2 first (recommended approach)
            if self.try_udisks_mount(device):
                return
                
            # If udisks2 fails, try manual mounting
            # Get device info
            device_name = os.path.basename(device)
            # Try multiple mount paths in order of preference
            mount_paths = self.get_mount_paths(device_name)
            # Detect filesystem type
            fstype = self.detect_filesystem(device)
            print(f"AutoMounter: Detected filesystem type: {fstype}")
            
            # Try each mount path
            for mount_path in mount_paths:
                success = self.mount_at_path(device, mount_path, fstype)
                if success:
                    return
            self.mount_failed.emit(device, "Mount failed - no suitable mount point")
        except Exception as e:
            print(f"AutoMounter: Error mounting {device}: {e}")
            self.mount_failed.emit(device, str(e))

    def get_mount_paths(self, device_name):
        """Get list of user-writable mount paths (avoid /media entirely)"""
        paths = []

        # ✅ Preferred: /run/media/$USER — created automatically by udisks2
        run_media = f"/run/media/{self.username}"
        if os.path.exists(run_media):
            paths.append(f"{run_media}/{device_name}")

        # ✅ Fallback: ~/media — fully user-controlled
        home_media = os.path.expanduser("~/media")
        os.makedirs(home_media, exist_ok=True)  # Safe: inside your home
        paths.append(f"{home_media}/{device_name}")

        # ✅ Last resort: temporary mount in /tmp (if needed for testing)
        tmp_mount = f"/tmp/mount_{device_name}_{os.getpid()}"
        paths.append(tmp_mount)

        return paths

    def try_udisks_mount(self, device):
        """Mount using udisks2 — let it choose the mount point"""
        try:
            print(f"AutoMounter: Trying udisks2 for {device}")
            result = subprocess.run(
                ['udisksctl', 'mount', '--block-device', device, '--no-user-interaction'],
                capture_output=True, text=True, timeout=15
            )
            print(f"AutoMounter: udisksctl output: {result.stdout}")
            print(f"AutoMounter: udisksctl error: {result.stderr}")
            print(f"AutoMounter: udisksctl return code: {result.returncode}")
            
            if result.returncode == 0:
                # Extract actual mount point from udisisksctl output
                # Example output: "Mounted /dev/sdb1 at /run/media/user/UNTITLED."
                for word in result.stdout.split():
                    if word.startswith('/run/media/'):
                        self.actual_mount_point = word
                        self.mount_success.emit(device, word)
                        return True
            return False
        except (FileNotFoundError, subprocess.SubprocessError) as e:
            print(f"AutoMounter: udisks2 exception: {e}")
            return False

    def mount_at_path(self, device, mount_path, fstype):
        """Mount device at specified path"""
        try:
            print(f"AutoMounter: Trying manual mount at {mount_path}")
            # Create mount directory if it doesn't exist
            os.makedirs(mount_path, exist_ok=True)
            
            # Get appropriate mount options for filesystem type
            mount_options = self.get_mount_options(fstype)
            
            # Try mounting with appropriate options
            cmd = ['mount'] + mount_options + [device, mount_path]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                self.actual_mount_point = mount_path
                self.mount_success.emit(device, mount_path)
                return True
                
            # If mount failed, try with different options
            fallback_options = [
                ['-t', fstype],
                ['-t', 'auto'],
                ['-o', 'rw'],
                []
            ]
            for opts in fallback_options:
                cmd = ['mount'] + opts + [device, mount_path]
                try:
                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                    if result.returncode == 0:
                        self.actual_mount_point = mount_path
                        self.mount_success.emit(device, mount_path)
                        return True
                except:
                    continue
        except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as e:
            print(f"AutoMounter: Manual mount exception: {e}")
        return False

    def detect_filesystem(self, device):
        """Detect filesystem type of device"""
        try:
            # Try blkid
            result = subprocess.run(['blkid', '-o', 'value', '-s', 'TYPE', device], 
                                  capture_output=True, text=True)
            print(f"AutoMounter: blkid output for {device}: {result.stdout}")
            if result.returncode == 0 and result.stdout.strip():
                return result.stdout.strip()
        except Exception as e:
            print(f"AutoMounter: blkid exception: {e}")
        try:
            # Try file command
            result = subprocess.run(['file', '-s', device], 
                                  capture_output=True, text=True)
            print(f"AutoMounter: file command output for {device}: {result.stdout}")
            if result.returncode == 0:
                output = result.stdout.lower()
                if 'fat' in output or 'vfat' in output:
                    return 'vfat'
                elif 'ntfs' in output:
                    return 'ntfs'
                elif 'ext' in output:
                    return 'ext4'
                elif 'exfat' in output:
                    return 'exfat'
        except Exception as e:
            print(f"AutoMounter: file command exception: {e}")
        return 'auto'

    def get_mount_options(self, fstype):
        """Get appropriate mount options for filesystem type"""
        options_map = {
            'vfat': ['-t', 'vfat', '-o', f'uid={self.uid},gid={self.gid},umask=000,shortname=mixed,utf8=1'],
            'ntfs': ['-t', 'ntfs-3g', '-o', f'uid={self.uid},gid={self.gid},umask=000,utf8=1'],
            'exfat': ['-t', 'exfat', '-o', f'uid={self.uid},gid={self.gid},umask=000'],
            'ext4': ['-t', 'ext4'],
            'ext3': ['-t', 'ext3'],
            'ext2': ['-t', 'ext2'],
        }
        return options_map.get(fstype, [])

    def stop(self):
        self.running = False

class USBMonitor(QThread):
    """Advanced USB monitoring thread with auto-mount capability"""
    usb_detected = pyqtSignal(list)  # Signal with list of USB devices
    status_message = pyqtSignal(str)  # Status message signal

    def __init__(self):
        super().__init__()
        self.running = True
        self.last_mounts = set()
        self.last_devices = set()
        self.auto_mounter = AutoMounter()
        self.auto_mounter.mount_success.connect(self.on_mount_success)
        self.auto_mounter.mount_failed.connect(self.on_mount_failed)
        self.auto_mounter.start()

    def run(self):
        while self.running:
            try:
                # Get current mounts and devices
                current_mounts = self.get_all_mounts()
                current_devices = self.get_all_usb_devices()
                
                # Check for new devices
                new_devices = current_devices - self.last_devices
                for device in new_devices:
                    print(f"USBMonitor: New device detected: {device}")
                    # For USB devices, we'll try to mount them regardless of filesystem detection
                    # since udisks2 can handle the mounting process
                    if device.startswith('/dev/sd') and not device.startswith('/dev/sda'):
                        print(f"USBMonitor: Adding USB device {device} to mount queue")
                        self.auto_mounter.add_device(device)
                        self.status_message.emit(f"Auto-mounting {device}...")
                
                # Check for changes
                if current_mounts != self.last_mounts or current_devices != self.last_devices:
                    all_devices = list(current_mounts.union(current_devices))
                    self.usb_detected.emit(all_devices)
                    self.last_mounts = current_mounts
                    self.last_devices = current_devices
                time.sleep(2)  # Check every 2 seconds
            except Exception as e:
                print(f"USB Monitor Error: {e}")
                time.sleep(5)  # Wait longer on error

    def has_filesystem(self, device):
        """Check if device has a recognizable filesystem"""
        # Since we're having permission issues, we'll just assume USB devices have filesystems
        # and let udisks2 handle the actual mounting
        if device.startswith('/dev/sd') and not device.startswith('/dev/sda'):
            return True
        return False

    def get_all_mounts(self):
        """Get all mount points that might be USB"""
        mounts = set()
        # Check psutil
        try:
            for partition in psutil.disk_partitions():
                if self.is_likely_usb(partition):
                    mounts.add(partition.mountpoint)
        except:
            pass
        # Check common mount directories
        mount_dirs = ['/media', '/mnt', '/run/media']
        for mount_dir in mount_dirs:
            if os.path.exists(mount_dir):
                try:
                    for user_dir in os.listdir(mount_dir):
                        user_path = os.path.join(mount_dir, user_dir)
                        if os.path.isdir(user_path):
                            for device in os.listdir(user_path):
                                device_path = os.path.join(user_path, device)
                                if os.path.ismount(device_path):
                                    mounts.add(device_path)
                except:
                    pass
        return mounts

    def get_all_usb_devices(self):
        """Get all USB block devices"""
        devices = set()
        # Method 1: Check /sys/block
        try:
            for device in os.listdir('/sys/block'):
                if device.startswith('sd') or device.startswith('hd'):
                    try:
                        with open(f'/sys/block/{device}/removable', 'r') as f:
                            if f.read().strip() == '1':
                                devices.add(f'/dev/{device}')
                    except:
                        pass
        except:
            pass
        # Method 2: Use lsblk
        try:
            result = subprocess.run(['lsblk', '-J'], capture_output=True, text=True)
            if result.returncode == 0:
                import json
                data = json.loads(result.stdout)
                for device in data.get('blockdevices', []):
                    if self.lsblk_is_usb(device):
                        devices.add(f"/dev/{device['name']}")
                        # Also add partitions
                        for child in device.get('children', []):
                            devices.add(f"/dev/{child['name']}")
        except:
            pass
        # Method 3: Check /dev/disk/by-id
        try:
            if os.path.exists('/dev/disk/by-id'):
                for device_id in os.listdir('/dev/disk/by-id'):
                    if 'usb' in device_id.lower():
                        try:
                            device_path = os.path.realpath(f'/dev/disk/by-id/{device_id}')
                            if os.path.exists(device_path):
                                devices.add(device_path)
                        except:
                            pass
        except:
            pass
        return devices

    def is_likely_usb(self, partition):
        """Check if partition is likely a USB device"""
        try:
            # Check device path
            if '/dev/sd' in partition.device:
                # Exclude system drive (usually sda)
                device_name = os.path.basename(partition.device)
                if not device_name.startswith('sda'):
                    return True
            # Check mount options
            if 'usb' in partition.opts.lower():
                return True
            # Check mount point
            if any(path in partition.mountpoint for path in ['/media/', '/mnt/', '/run/media/']):
                return True
            # Check filesystem type
            if partition.fstype.lower() in ['vfat', 'exfat', 'ntfs', 'msdos', 'fat32']:
                return True
        except:
            pass
        return False

    def lsblk_is_usb(self, device):
        """Check if lsblk device is USB"""
        try:
            if device.get('rm') == '1':  # Removable flag
                return True
            if device.get('type') == 'disk' and not device['name'].startswith('sda'):
                return True
        except:
            pass
        return False

    def on_mount_success(self, device, mount_point):
        """Handle successful mount"""
        self.status_message.emit(f"Mounted {device} at {mount_point}")
        # Refresh drives list after a short delay to ensure mount is fully registered
        QTimer.singleShot(1000, lambda: self.usb_detected.emit(list(self.get_all_mounts().union(self.get_all_usb_devices()))))

    def on_mount_failed(self, device, error):
        """Handle failed mount"""
        self.status_message.emit(f"Failed to auto-mount {device}: {error}")

    def stop(self):
        self.running = False
        if hasattr(self, 'auto_mounter'):
            self.auto_mounter.stop()
            self.auto_mounter.wait()

class MountPointWatcher(QFileSystemWatcher):
    """Watch for changes in mount points"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.mount_paths = []
        self.update_watch_paths()

    def update_watch_paths(self):
        """Update paths to watch"""
        # Remove old paths
        for path in self.mount_paths:
            if self.files():
                self.removePath(path)
        # Add new paths
        self.mount_paths = ['/media', '/mnt', '/run/media']
        for path in self.mount_paths:
            if os.path.exists(path):
                self.addPath(path)
                # Also watch subdirectories
                try:
                    for item in os.listdir(path):
                        item_path = os.path.join(path, item)
                        if os.path.isdir(item_path):
                            self.addPath(item_path)
                except:
                    pass

class TabWidget(QTabWidget):
    """Custom tab widget with close buttons"""
    tab_closed = pyqtSignal(int)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setTabsClosable(True)
        self.tabCloseRequested.connect(self.close_tab)
        self.setMovable(True)
        self.setUsesScrollButtons(True)
        self.setAcceptDrops(True)  # Enable drag and drop on tabs

    def close_tab(self, index):
        if self.count() > 1:  # Don't close the last tab
            self.tab_closed.emit(index)

    def dragEnterEvent(self, event):
        """Handle drag enter event on tab bar"""
        if event.mimeData().hasUrls():
            event.acceptProposedAction()
        else:
            super().dragEnterEvent(event)

    def dropEvent(self, event):
        """Handle drop event on tab bar"""
        if event.mimeData().hasUrls():
            # Get the tab at the drop position
            tab_index = self.tabBar().tabAt(event.pos())
            if tab_index >= 0:
                # Get the browser widget for this tab
                browser = self.widget(tab_index)
                if browser and hasattr(browser, 'current_path'):
                    # Get the parent file manager
                    parent = self.parent()
                    while parent and not hasattr(parent, 'handle_urls_drop'):
                        parent = parent.parent()
                    
                    if parent:
                        # Create a custom drop event
                        mime_data = event.mimeData()
                        drop_action = event.dropAction()
                        parent.handle_urls_drop(mime_data.urls(), browser.current_path, drop_action)
                        event.acceptProposedAction()
                        return
        super().dropEvent(event)

    def add_new_tab(self, path=None, label="New Tab", default_view_mode="detail", show_hidden=False):
        """Add a new tab with a file browser"""
        from PyQt5.QtWidgets import QStackedWidget, QListView, QTreeView
        # Create a new file browser widget
        browser = QWidget()
        layout = QVBoxLayout(browser)
        layout.setContentsMargins(0, 0, 0, 0)
        # Create file system model for this tab
        file_model = FileSystemModel()
        file_model.setShowHiddenFiles(show_hidden)
        # Create stacked widget for views
        view_stack = QStackedWidget()
        # Create different views with drag and drop support
        icon_view = DragDropListView()
        icon_view.setModel(file_model)
        icon_view.setViewMode(QListView.IconMode)
        icon_view.setIconSize(QSize(96, 96))
        icon_view.setGridSize(QSize(120, 120))
        icon_view.setResizeMode(QListView.Adjust)
        icon_view.setWordWrap(True)
        icon_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        icon_view.setContextMenuPolicy(Qt.CustomContextMenu)
        list_view = DragDropListView()
        list_view.setModel(file_model)
        list_view.setViewMode(QListView.ListMode)
        list_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        list_view.setContextMenuPolicy(Qt.CustomContextMenu)
        detail_view = DragDropTreeView()
        detail_view.setModel(file_model)
        detail_view.setRootIsDecorated(False)
        detail_view.setAlternatingRowColors(True)
        detail_view.setSortingEnabled(True)
        detail_view.setEditTriggers(QAbstractItemView.NoEditTriggers)
        detail_view.setContextMenuPolicy(Qt.CustomContextMenu)
        # Add all views to stacked widget
        view_stack.addWidget(icon_view)
        view_stack.addWidget(list_view)
        view_stack.addWidget(detail_view)
        # Set default view based on saved preference
        if default_view_mode == 'icon':
            view_stack.setCurrentWidget(icon_view)
            browser.current_view = icon_view
        elif default_view_mode == 'list':
            view_stack.setCurrentWidget(list_view)
            browser.current_view = list_view
        else:  # detail
            view_stack.setCurrentWidget(detail_view)
            browser.current_view = detail_view
        layout.addWidget(view_stack)
        # Store references in the browser widget
        browser.file_model = file_model
        browser.view_stack = view_stack
        browser.icon_view = icon_view
        browser.list_view = list_view
        browser.detail_view = detail_view
        # Load initial path
        if path and os.path.exists(path):
            index = file_model.setRootPath(path)
            icon_view.setRootIndex(index)
            list_view.setRootIndex(index)
            detail_view.setRootIndex(index)
            browser.current_path = path
        else:
            file_model.setRootPath(QDir.homePath())
            browser.current_path = QDir.homePath()
        # Add tab
        tab_index = self.addTab(browser, label)
        self.setCurrentIndex(tab_index)
        return browser

class DarkNemo(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Dark File Manager")
        
        # Initialize variables
        self.clipboard_paths = []
        self.clipboard_operation = None  # 'copy' or 'cut'
        self.current_path = QDir.homePath()
        # Initialize settings manager
        self.settings_manager = SettingsManager()
        # Initialize bookmark manager
        self.bookmark_manager = BookmarkManager()
        # Setup USB monitoring
        self.usb_monitor = USBMonitor()
        self.usb_monitor.usb_detected.connect(self.on_usb_detected)
        self.usb_monitor.status_message.connect(self.update_status_message)
        self.usb_monitor.start()
        # Setup mount point watcher
        self.mount_watcher = MountPointWatcher(self)
        self.mount_watcher.directoryChanged.connect(self.on_mount_changed)
        
        # Apply black theme
        self.setStyleSheet(self.get_black_stylesheet())
        
        # Setup UI
        self.setup_ui()
        self.setup_connections()
        
        # Restore window geometry and state if available
        self.restore_window_state()
        
        # Load initial directory
        QTimer.singleShot(100, self.load_initial_directory)
        
        # Auto-refresh drives every 10 seconds
        self.drive_refresh_timer = QTimer()
        self.drive_refresh_timer.timeout.connect(self.load_drives)
        self.drive_refresh_timer.start(10000)  # 10 seconds
        
        # Timer to save window state after resize/move
        self.save_state_timer = QTimer()
        self.save_state_timer.setSingleShot(True)
        self.save_state_timer.timeout.connect(self.save_window_state)

    def resizeEvent(self, event):
        """Handle window resize event"""
        super().resizeEvent(event)
        # Save window state after a short delay to avoid too many saves
        self.save_state_timer.start(500)  # 500ms delay

    def moveEvent(self, event):
        """Handle window move event"""
        super().moveEvent(event)
        # Save window state after a short delay to avoid too many saves
        self.save_state_timer.start(500)  # 500ms delay

    def closeEvent(self, event):
        """Clean up when closing"""
        # Save window geometry and state
        self.save_window_state()
        if hasattr(self, 'usb_monitor'):
            self.usb_monitor.stop()
            self.usb_monitor.wait()
        if hasattr(self, 'drive_refresh_timer'):
            self.drive_refresh_timer.stop()
        if hasattr(self, 'save_state_timer'):
            self.save_state_timer.stop()
        event.accept()

    def save_window_state(self):
        """Save window geometry and state"""
        try:
            geometry = self.saveGeometry()
            state = self.saveState()
            self.settings_manager.set_setting('window_geometry', geometry.data().hex())
            self.settings_manager.set_setting('window_state', state.data().hex())
            
            # Also save splitter sizes
            if hasattr(self, 'splitter'):
                splitter_sizes = self.splitter.sizes()
                self.settings_manager.set_setting('splitter_sizes', splitter_sizes)
                
            # Save window size and position
            self.settings_manager.set_setting('window_size', [self.width(), self.height()])
            self.settings_manager.set_setting('window_position', [self.x(), self.y()])
        except Exception as e:
            print(f"Error saving window state: {e}")

    def restore_window_state(self):
        """Restore window geometry and state - FIXED: Handle splitter_sizes properly"""
        try:
            geometry_hex = self.settings_manager.get_setting('window_geometry')
            state_hex = self.settings_manager.get_setting('window_state')
            
            if geometry_hex:
                geometry = QByteArray.fromHex(geometry_hex.encode())
                self.restoreGeometry(geometry)
            else:
                # Default size if no saved geometry
                self.setGeometry(100, 100, 1200, 800)
            
            if state_hex:
                state = QByteArray.fromHex(state_hex.encode())
                self.restoreState(state)
                
            # Restore splitter sizes - FIX: Ensure we never pass None
            splitter_sizes = self.settings_manager.get_setting('splitter_sizes')
            if splitter_sizes and hasattr(self, 'splitter'):
                self.splitter.setSizes(splitter_sizes)
            elif hasattr(self, 'splitter'):
                # Set default splitter sizes if none are saved
                self.splitter.setSizes([300, 900])
                
            # Restore window size and position if geometry restoration failed
            window_size = self.settings_manager.get_setting('window_size')
            window_position = self.settings_manager.get_setting('window_position')
            
            if window_size and not geometry_hex:
                self.resize(window_size[0], window_size[1])
                
            if window_position and not geometry_hex:
                self.move(window_position[0], window_position[1])
                
        except Exception as e:
            print(f"Error restoring window state: {e}")
            # Set default geometry if restoration fails
            self.setGeometry(100, 100, 1200, 800)
            # Set default splitter sizes
            if hasattr(self, 'splitter'):
                self.splitter.setSizes([300, 900])

    def on_usb_detected(self, devices):
        """Handle USB detection"""
        self.load_drives()
        if devices:
            self.status_label.setText(f"USB device detected: {len(devices)} device(s)")

    def on_mount_changed(self, path):
        """Handle mount point changes"""
        QTimer.singleShot(1000, self.load_drives)  # Delay to let mount complete

    def update_status_message(self, message):
        """Update status bar with message"""
        self.status_label.setText(message)
        QTimer.singleShot(5000, lambda: self.status_label.setText("Ready"))  # Clear after 5 seconds

    def load_initial_directory(self):
        """Load initial directory after UI is ready"""
        if os.path.exists(self.current_path):
            self.load_directory(self.current_path)

    def get_black_stylesheet(self):
        return """
            QMainWindow {
                background-color: #000000;
                color: #ffffff;
            }
            QWidget {
                background-color: #000000;
                color: #ffffff;
                font-family: 'Cantarell', 'Ubuntu', 'Segoe UI', Arial, sans-serif;
                font-size: 11pt;
            }
            QMenuBar {
                background-color: #1a1a1a;
                color: #ffffff;
                border-bottom: 1px solid #333333;
                padding: 2px;
            }
            QMenuBar::item {
                background-color: transparent;
                padding: 6px 12px;
                border-radius: 4px;
            }
            QMenuBar::item:selected {
                background-color: #333333;
            }
            QMenu {
                background-color: #1a1a1a;
                color: #ffffff;
                border: 1px solid #333333;
                border-radius: 6px;
                padding: 4px;
            }
            QMenu::item {
                padding: 8px 20px;
                border-radius: 4px;
                color: #ffffff;
            }
            QMenu::item:selected {
                background-color: #333333;
                color: #ffffff;
            }
            QToolBar {
                background-color: #1a1a1a;
                border: none;
                spacing: 3px;
                padding: 6px;
            }
            QPushButton {
                background-color: #2a2a2a;
                border: 1px solid #444444;
                border-radius: 6px;
                padding: 8px;
                color: #ffffff;
                font-size: 11pt;
                font-weight: bold;
                min-width: 40px;
                min-height: 30px;
            }
            QPushButton:hover {
                background-color: #3a3a3a;
                border-color: #555555;
            }
            QPushButton:pressed {
                background-color: #4a4a4a;
            }
            QPushButton:disabled {
                background-color: #1a1a1a;
                color: #666666;
                border-color: #333333;
            }
            /* Extra small navigation buttons */
            QPushButton#navButton {
                background-color: #2a2a2a;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 2px;
                color: #ffffff;
                font-size: 9pt;
                min-width: 22px;
                min-height: 20px;
                max-width: 22px;
                max-height: 20px;
            }
            QPushButton#navButton:hover {
                background-color: #3a3a3a;
                border-color: #555555;
            }
            QPushButton#navButton:pressed {
                background-color: #4a4a4a;
            }
            QPushButton#navButton:checked {
                background-color: #0066cc;
                border-color: #0088ff;
            }
            QPushButton#goButton {
                background-color: #2a2a2a;
                border: 1px solid #444444;
                border-radius: 3px;
                padding: 2px;
                color: #ffffff;
                font-size: 9pt;
                font-weight: bold;
                min-width: 22px;
                min-height: 20px;
                max-width: 22px;
                max-height: 20px;
            }
            QPushButton#goButton:hover {
                background-color: #3a3a3a;
                border-color: #555555;
            }
            QPushButton#goButton:pressed {
                background-color: #4a4a4a;
            }
            QLineEdit {
                background-color: #1a1a1a;
                border: 1px solid #444444;
                border-radius: 6px;
                padding: 8px;
                color: #ffffff;
                font-size: 11pt;
            }
            QLineEdit:focus {
                border: 2px solid #00aaff;
            }
            QTreeView {
                background-color: #0a0a0a;
                border: 1px solid #333333;
                alternate-background-color: #111111;
                selection-background-color: #0066cc;
                color: #ffffff;
                font-size: 11pt;
            }
            QTreeView::item {
                padding: 6px;
                border: none;
                height: 28px;
                color: #ffffff;
            }
            QTreeView::item:selected {
                background-color: #0066cc;
                color: #ffffff;
            }
            QTreeView::item:hover {
                background-color: #222222;
                color: #ffffff;
            }
            QHeaderView::section {
                background-color: #1a1a1a;
                color: #ffffff;
                padding: 8px;
                border: 1px solid #333333;
                font-weight: bold;
                font-size: 11pt;
            }
            QStatusBar {
                background-color: #1a1a1a;
                color: #ffffff;
                border-top: 1px solid #333333;
                font-size: 10pt;
            }
            QSplitter::handle {
                background-color: #333333;
            }
            QSplitter::handle:horizontal {
                width: 3px;
            }
            QSplitter::handle:vertical {
                height: 3px;
            }
            QLabel {
                color: #ffffff;
                font-size: 11pt;
            }
            QProgressBar {
                border: 1px solid #444444;
                border-radius: 4px;
                text-align: center;
                background-color: #1a1a1a;
                height: 12px;
                font-size: 9pt;
                color: #ffffff;
            }
            QProgressBar::chunk {
                background-color: #0066cc;
                border-radius: 3px;
            }
            QTabWidget::pane {
                border: 1px solid #333333;
                background-color: #0a0a0a;
                border-radius: 6px;
            }
            QTabBar::tab {
                background-color: #2a2a2a;
                color: #ffffff;
                padding: 8px 16px;
                border: 1px solid #333333;
                border-bottom: none;
                border-top-left-radius: 6px;
                border-top-right-radius: 6px;
                font-weight: bold;
                margin-right: 2px;
            }
            QTabBar::tab:selected {
                background-color: #0a0a0a;
                color: #ffffff;
            }
            QTabBar::tab:hover {
                background-color: #333333;
                color: #ffffff;
            }
            QScrollArea {
                background-color: #0a0a0a;
                border: 1px solid #333333;
                border-radius: 6px;
            }
            QListWidget {
                background-color: #0a0a0a;
                border: 1px solid #333333;
                border-radius: 6px;
                font-size: 11pt;
                color: #ffffff;
            }
            QListWidget::item {
                padding: 8px;
                border-radius: 4px;
                color: #ffffff;
            }
            QListWidget::item:selected {
                background-color: #0066cc;
                color: #ffffff;
            }
            QListWidget::item:hover {
                background-color: #222222;
                color: #ffffff;
            }
            QGroupBox {
                font-weight: bold;
                font-size: 12pt;
                border: 1px solid #333333;
                border-radius: 6px;
                margin-top: 12px;
                padding-top: 12px;
                color: #ffffff;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: #ffffff;
            }
            QListView {
                background-color: #0a0a0a;
                border: 1px solid #333333;
                border-radius: 6px;
                font-size: 11pt;
                color: #ffffff;
            }
            QListView::item {
                padding: 6px;
                border-radius: 4px;
                color: #ffffff;
            }
            QListView::item:selected {
                background-color: #0066cc;
                color: #ffffff;
            }
            QListView::item:hover {
                background-color: #222222;
                color: #ffffff;
            }
            QFrame[frameShape="5"] {
                color: #444444;
            }
            QDialog {
                background-color: #000000;
                color: #ffffff;
            }
            QCheckBox {
                color: #ffffff;
            }
            QCheckBox::indicator {
                width: 16px;
                height: 16px;
            }
            QCheckBox::indicator:unchecked {
                border: 1px solid #666666;
                background-color: #1a1a1a;
            }
            QCheckBox::indicator:checked {
                border: 1px solid #0066cc;
                background-color: #0066cc;
            }
            QRadioButton {
                color: #ffffff;
            }
            QRadioButton::indicator {
                width: 16px;
                height: 16px;
            }
            QRadioButton::indicator:unchecked {
                border: 1px solid #666666;
                background-color: #1a1a1a;
                border-radius: 8px;
            }
            QRadioButton::indicator:checked {
                border: 1px solid #0066cc;
                background-color: #0066cc;
                border-radius: 8px;
            }
            QTextEdit {
                background-color: #1a1a1a;
                color: #ffffff;
                border: 1px solid #444444;
                border-radius: 6px;
            }
            QInputDialog {
                background-color: #000000;
                color: #ffffff;
            }
        """

    def setup_ui(self):
        # Central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        # Main layout
        main_layout = QVBoxLayout(central_widget)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        # Create combined navigation and path bar
        self.create_navigation_path_bar()
        main_layout.addWidget(self.navigation_path_bar)
        # Main content area with splitter
        self.splitter = QSplitter(Qt.Horizontal)
        # Sidebar (Places and Tree)
        self.create_sidebar()
        self.splitter.addWidget(self.sidebar)
        # Tab widget for multiple tabs
        self.tab_widget = TabWidget()
        self.tab_widget.tab_closed.connect(self.close_tab)
        # Get default view mode and hidden files setting from settings
        default_view_mode = self.settings_manager.get_setting('default_view_mode', 'detail')
        show_hidden = self.settings_manager.get_setting('show_hidden_files', False)
        # Add initial tab with saved settings
        initial_browser = self.tab_widget.add_new_tab(QDir.homePath(), "Home", default_view_mode, show_hidden)
        # Connect context menu for the initial tab
        initial_browser.icon_view.customContextMenuRequested.connect(self.show_context_menu)
        initial_browser.list_view.customContextMenuRequested.connect(self.show_context_menu)
        initial_browser.detail_view.customContextMenuRequested.connect(self.show_context_menu)
        initial_browser.icon_view.doubleClicked.connect(self.item_double_clicked)
        initial_browser.list_view.doubleClicked.connect(self.item_double_clicked)
        initial_browser.detail_view.doubleClicked.connect(self.item_double_clicked)
        self.splitter.addWidget(self.tab_widget)
        # Set proper stretch factors for the splitter
        self.splitter.setStretchFactor(0, 0)  # Sidebar doesn't stretch
        self.splitter.setStretchFactor(1, 1)  # Main content stretches
        # Set initial splitter sizes - FIXED: Ensure splitter_sizes is never None
        splitter_sizes = self.settings_manager.get_setting('splitter_sizes')
        if not splitter_sizes:  # If None or empty list
            splitter_sizes = [300, 900]  # Default sizes
        self.splitter.setSizes(splitter_sizes)
        main_layout.addWidget(self.splitter)
        # Status bar
        self.create_status_bar()
        self.setStatusBar(self.status_bar)
        # Create menu bar
        self.create_menu_bar()
        # Set initial state of hidden files button
        self.hidden_files_button.setChecked(show_hidden)
        
        # Set size policies for proper resizing
        central_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.splitter.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.tab_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.sidebar.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)

    def create_navigation_path_bar(self):
        """Create the navigation and path bar with hidden files toggle"""
        self.navigation_path_bar = QWidget()
        nav_layout = QHBoxLayout(self.navigation_path_bar)
        nav_layout.setContentsMargins(5, 5, 5, 5)
        
        # Back button
        self.back_button = QPushButton("◀")
        self.back_button.setObjectName("navButton")
        self.back_button.setToolTip("Back")
        nav_layout.addWidget(self.back_button)
        
        # Forward button
        self.forward_button = QPushButton("▶")
        self.forward_button.setObjectName("navButton")
        self.forward_button.setToolTip("Forward")
        nav_layout.addWidget(self.forward_button)
        
        # Up button
        self.up_button = QPushButton("▲")
        self.up_button.setObjectName("navButton")
        self.up_button.setToolTip("Up")
        nav_layout.addWidget(self.up_button)
        
        # Home button
        self.home_button = QPushButton("⌂")
        self.home_button.setObjectName("navButton")
        self.home_button.setToolTip("Home")
        nav_layout.addWidget(self.home_button)
        
        # Path entry
        self.path_entry = QLineEdit()
        nav_layout.addWidget(self.path_entry)
        
        # Go button
        self.go_button = QPushButton("Go")
        self.go_button.setObjectName("goButton")
        self.go_button.setToolTip("Go to path")
        nav_layout.addWidget(self.go_button)
        
        # Hidden files toggle button
        self.hidden_files_button = QPushButton("👁")
        self.hidden_files_button.setObjectName("navButton")
        self.hidden_files_button.setToolTip("Show/Hide Hidden Files")
        self.hidden_files_button.setCheckable(True)
        nav_layout.addWidget(self.hidden_files_button)

    def create_menu_bar(self):
        menubar = self.menuBar()
        # File menu
        file_menu = menubar.addMenu('File')
        new_tab_action = QAction('New Tab', self)
        new_tab_action.setShortcut('Ctrl+T')
        new_tab_action.triggered.connect(self.new_tab)
        file_menu.addAction(new_tab_action)
        new_window_action = QAction('New Window', self)
        new_window_action.setShortcut('Ctrl+N')
        new_window_action.triggered.connect(self.new_window)
        file_menu.addAction(new_window_action)
        file_menu.addSeparator()
        new_folder_action = QAction('New Folder', self)
        new_folder_action.setShortcut('Ctrl+Shift+N')
        new_folder_action.triggered.connect(self.new_folder)
        file_menu.addAction(new_folder_action)
        new_file_action = QAction('New File', self)
        new_file_action.setShortcut('Ctrl+Shift+F')
        new_file_action.triggered.connect(self.new_file)
        file_menu.addAction(new_file_action)
        file_menu.addSeparator()
        exit_action = QAction('Exit', self)
        exit_action.setShortcut('Ctrl+Q')
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # Edit menu
        edit_menu = menubar.addMenu('Edit')
        copy_action = QAction('Copy', self)
        copy_action.setShortcut('Ctrl+C')
        copy_action.triggered.connect(self.copy_files)
        edit_menu.addAction(copy_action)
        cut_action = QAction('Cut', self)
        cut_action.setShortcut('Ctrl+X')
        cut_action.triggered.connect(self.cut_files)
        edit_menu.addAction(cut_action)
        paste_action = QAction('Paste', self)
        paste_action.setShortcut('Ctrl+V')
        paste_action.triggered.connect(self.paste_files)
        edit_menu.addAction(paste_action)
        edit_menu.addSeparator()
        select_all_action = QAction('Select All', self)
        select_all_action.setShortcut('Ctrl+A')
        select_all_action.triggered.connect(self.select_all)
        edit_menu.addAction(select_all_action)
        
        # View menu
        view_menu = menubar.addMenu('View')
        show_hidden_action = QAction('Show Hidden Files', self)
        show_hidden_action.setCheckable(True)
        show_hidden_action.setShortcut('Ctrl+H')
        show_hidden_action.triggered.connect(self.toggle_hidden_files_menu)
        view_menu.addAction(show_hidden_action)
        view_menu.addSeparator()
        icon_view_action = QAction('Icon View', self)
        icon_view_action.triggered.connect(lambda: self.change_view('icon'))
        view_menu.addAction(icon_view_action)
        list_view_action = QAction('List View', self)
        list_view_action.triggered.connect(lambda: self.change_view('list'))
        view_menu.addAction(list_view_action)
        detail_view_action = QAction('Detail View', self)
        detail_view_action.triggered.connect(lambda: self.change_view('detail'))
        view_menu.addAction(detail_view_action)
        
        # Bookmarks menu
        bookmarks_menu = menubar.addMenu('Bookmarks')
        add_bookmark_action = QAction('Add Bookmark', self)
        add_bookmark_action.setShortcut('Ctrl+D')
        add_bookmark_action.triggered.connect(self.add_bookmark)
        bookmarks_menu.addAction(add_bookmark_action)
        
        # Help menu
        help_menu = menubar.addMenu('Help')
        about_action = QAction('About', self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)

    def create_sidebar(self):
        """Create the sidebar with places and drives"""
        self.sidebar = QWidget()
        sidebar_layout = QVBoxLayout(self.sidebar)
        sidebar_layout.setContentsMargins(5, 5, 5, 5)
        
        # Places section
        places_group = QGroupBox("Places")
        places_layout = QVBoxLayout(places_group)
        
        self.places_list = QListWidget()
        self.places_list.setMaximumHeight(150)
        places_layout.addWidget(self.places_list)
        
        # Add common places
        self.places_list.addItem(QListWidgetItem(QApplication.style().standardIcon(QStyle.SP_DirHomeIcon), "Home"))
        self.places_list.addItem(QListWidgetItem(QApplication.style().standardIcon(QStyle.SP_DesktopIcon), "Desktop"))
        self.places_list.addItem(QListWidgetItem(QApplication.style().standardIcon(QStyle.SP_DirIcon), "Documents"))
        self.places_list.addItem(QListWidgetItem(QApplication.style().standardIcon(QStyle.SP_DirIcon), "Downloads"))
        self.places_list.addItem(QListWidgetItem(QApplication.style().standardIcon(QStyle.SP_DirIcon), "Pictures"))
        self.places_list.addItem(QListWidgetItem(QApplication.style().standardIcon(QStyle.SP_DirIcon), "Music"))
        self.places_list.addItem(QListWidgetItem(QApplication.style().standardIcon(QStyle.SP_DirIcon), "Videos"))
        
        sidebar_layout.addWidget(places_group)
        
        # Bookmarks section
        bookmarks_group = QGroupBox("Bookmarks")
        bookmarks_layout = QVBoxLayout(bookmarks_group)
        
        self.bookmarks_list = QListWidget()
        self.bookmarks_list.setMaximumHeight(150)
        bookmarks_layout.addWidget(self.bookmarks_list)
        
        sidebar_layout.addWidget(bookmarks_group)
        
        # Drives section
        drives_group = QGroupBox("Drives")
        drives_layout = QVBoxLayout(drives_group)
        
        self.drives_list = QListWidget()
        drives_layout.addWidget(self.drives_list)
        
        sidebar_layout.addWidget(drives_group)
        
        # Load bookmarks
        self.load_bookmarks()
        
        # Load drives
        self.load_drives()

    def create_status_bar(self):
        """Create the status bar"""
        self.status_bar = QStatusBar()
        self.status_label = QLabel("Ready")
        self.status_bar.addWidget(self.status_label)

    def setup_connections(self):
        """Setup signal connections"""
        # Navigation buttons
        self.back_button.clicked.connect(self.go_back)
        self.forward_button.clicked.connect(self.go_forward)
        self.up_button.clicked.connect(self.go_up)
        self.home_button.clicked.connect(self.go_home)
        self.go_button.clicked.connect(self.navigate_to_path)
        self.path_entry.returnPressed.connect(self.navigate_to_path)
        
        # Hidden files toggle
        self.hidden_files_button.toggled.connect(self.toggle_hidden_files)
        
        # Tab widget
        self.tab_widget.currentChanged.connect(self.on_tab_changed)
        
        # Places list
        self.places_list.itemClicked.connect(self.place_clicked)
        
        # Drives list
        self.drives_list.itemClicked.connect(self.drive_clicked)
        
        # Bookmarks
        self.bookmarks_list.itemClicked.connect(self.bookmark_clicked)
        self.bookmarks_list.setContextMenuPolicy(Qt.CustomContextMenu)
        self.bookmarks_list.customContextMenuRequested.connect(self.bookmark_context_menu)
        
        # Splitter
        self.splitter.splitterMoved.connect(self.on_splitter_moved)

    def on_splitter_moved(self):
        """Handle splitter movement"""
        # Save splitter state after a short delay
        self.save_state_timer.start(500)

    def toggle_hidden_files(self, checked):
        """Toggle visibility of hidden files in the current tab"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'file_model'):
            current_browser.file_model.setShowHiddenFiles(checked)
            # Update the button tooltip
            if checked:
                self.hidden_files_button.setToolTip("Hide Hidden Files")
            else:
                self.hidden_files_button.setToolTip("Show Hidden Files")
            # Save setting
            self.settings_manager.set_setting('show_hidden_files', checked)

    def toggle_hidden_files_menu(self):
        """Toggle hidden files from menu"""
        self.hidden_files_button.setChecked(not self.hidden_files_button.isChecked())

    def on_tab_changed(self, index):
        """Handle tab change"""
        if index >= 0:
            browser = self.tab_widget.widget(index)
            if browser and hasattr(browser, 'current_path'):
                self.current_path = browser.current_path
                self.path_entry.setText(self.current_path)
                # Update the hidden files button state to match the current tab
                if hasattr(browser, 'file_model'):
                    self.hidden_files_button.blockSignals(True)  # Prevent triggering the toggle
                    self.hidden_files_button.setChecked(browser.file_model.show_hidden_files)
                    if browser.file_model.show_hidden_files:
                        self.hidden_files_button.setToolTip("Hide Hidden Files")
                    else:
                        self.hidden_files_button.setToolTip("Show Hidden Files")
                    self.hidden_files_button.blockSignals(False)

    def new_tab(self):
        """Create a new tab"""
        default_view_mode = self.settings_manager.get_setting('default_view_mode', 'detail')
        show_hidden = self.settings_manager.get_setting('show_hidden_files', False)
        browser = self.tab_widget.add_new_tab(self.current_path, "New Tab", default_view_mode, show_hidden)
        # Connect signals for the new tab
        browser.icon_view.customContextMenuRequested.connect(self.show_context_menu)
        browser.list_view.customContextMenuRequested.connect(self.show_context_menu)
        browser.detail_view.customContextMenuRequested.connect(self.show_context_menu)
        browser.icon_view.doubleClicked.connect(self.item_double_clicked)
        browser.list_view.doubleClicked.connect(self.item_double_clicked)
        browser.detail_view.doubleClicked.connect(self.item_double_clicked)

    def new_window(self):
        """Create a new window"""
        # This would create a new instance of the application
        # For simplicity, we'll just create a new window
        new_app = QApplication.instance()
        if new_app is None:
            new_app = QApplication(sys.argv)
        window = DarkNemo()
        window.show()

    def close_tab(self, index):
        """Close a tab"""
        self.tab_widget.removeTab(index)

    def go_back(self):
        """Navigate back"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_view'):
            # Implement back navigation
            pass

    def go_forward(self):
        """Navigate forward"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_view'):
            # Implement forward navigation
            pass

    def go_up(self):
        """Navigate up one directory"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_path'):
            parent_path = os.path.dirname(current_browser.current_path)
            if parent_path and parent_path != current_browser.current_path:
                self.load_directory(parent_path)

    def go_home(self):
        """Navigate to home directory"""
        self.load_directory(QDir.homePath())

    def navigate_to_path(self):
        """Navigate to the path in the entry field"""
        path = self.path_entry.text()
        if os.path.exists(path):
            self.load_directory(path)

    def load_directory(self, path):
        """Load a directory in the current tab"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'file_model'):
            index = current_browser.file_model.setRootPath(path)
            current_browser.icon_view.setRootIndex(index)
            current_browser.list_view.setRootIndex(index)
            current_browser.detail_view.setRootIndex(index)
            current_browser.current_path = path
            self.current_path = path
            self.path_entry.setText(path)
            # Update tab title
            tab_index = self.tab_widget.indexOf(current_browser)
            self.tab_widget.setTabText(tab_index, os.path.basename(path) or path)

    def place_clicked(self, item):
        """Handle place click"""
        place_name = item.text()
        home_path = QDir.homePath()
        
        places_map = {
            "Home": home_path,
            "Desktop": os.path.join(home_path, "Desktop"),
            "Documents": os.path.join(home_path, "Documents"),
            "Downloads": os.path.join(home_path, "Downloads"),
            "Pictures": os.path.join(home_path, "Pictures"),
            "Music": os.path.join(home_path, "Music"),
            "Videos": os.path.join(home_path, "Videos")
        }
        
        if place_name in places_map:
            path = places_map[place_name]
            if os.path.exists(path):
                self.load_directory(path)

    def drive_clicked(self, item):
        """Handle drive click"""
        drive_path = item.data(Qt.UserRole)
        if drive_path and os.path.exists(drive_path):
            self.load_directory(drive_path)

    def load_drives(self):
        """Load available drives"""
        self.drives_list.clear()
        
        # Get all mount points
        mounts = []
        try:
            for partition in psutil.disk_partitions():
                if os.path.exists(partition.mountpoint):
                    mounts.append((partition.device, partition.mountpoint, partition.fstype))
        except:
            pass
        
        # Add drives to list
        for device, mountpoint, fstype in mounts:
            if mountpoint.startswith('/run/media/') or mountpoint.startswith('/media/') or mountpoint.startswith('/mnt/'):
                # External drive
                item = QListWidgetItem(QApplication.style().standardIcon(QStyle.SP_DriveHDIcon), 
                                     f"{os.path.basename(mountpoint)} ({fstype})")
                item.setData(Qt.UserRole, mountpoint)
                self.drives_list.addItem(item)
            elif mountpoint == '/':
                # Root filesystem
                item = QListWidgetItem(QApplication.style().standardIcon(QStyle.SP_ComputerIcon), 
                                     "Filesystem")
                item.setData(Qt.UserRole, mountpoint)
                self.drives_list.addItem(item)

    def load_bookmarks(self):
        """Load bookmarks"""
        self.bookmarks_list.clear()
        for bookmark in self.bookmark_manager.bookmarks:
            item = QListWidgetItem(QApplication.style().standardIcon(QStyle.SP_DirIcon), 
                                 bookmark['name'])
            item.setData(Qt.UserRole, bookmark['path'])
            self.bookmarks_list.addItem(item)

    def bookmark_clicked(self, item):
        """Handle bookmark click"""
        bookmark_path = item.data(Qt.UserRole)
        if bookmark_path and os.path.exists(bookmark_path):
            self.load_directory(bookmark_path)

    def add_bookmark(self):
        """Add current directory to bookmarks"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_path'):
            path = current_browser.current_path
            name = os.path.basename(path) or path
            if self.bookmark_manager.add_bookmark(name, path):
                self.load_bookmarks()
                QMessageBox.information(self, "Bookmark Added", f"Added bookmark for {path}")

    def bookmark_context_menu(self, position):
        """Show bookmark context menu"""
        item = self.bookmarks_list.itemAt(position)
        if item:
            menu = QMenu()
            remove_action = menu.addAction("Remove Bookmark")
            action = menu.exec_(self.bookmarks_list.mapToGlobal(position))
            if action == remove_action:
                bookmark_path = item.data(Qt.UserRole)
                if bookmark_path:
                    self.bookmark_manager.remove_bookmark(bookmark_path)
                    self.load_bookmarks()

    def item_double_clicked(self, index):
        """Handle item double click"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'file_model'):
            path = current_browser.file_model.filePath(index)
            if os.path.isdir(path):
                self.load_directory(path)
            else:
                # Open file with default application
                try:
                    if platform.system() == "Linux":
                        subprocess.run(['xdg-open', path])
                    elif platform.system() == "Darwin":  # macOS
                        subprocess.run(['open', path])
                    elif platform.system() == "Windows":
                        os.startfile(path)
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Could not open file: {e}")

    def show_context_menu(self, position):
        """Enhanced context menu with comprehensive options"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_view'):
            view = current_browser.current_view
            menu = QMenu()
            
            # Get selected items
            selected = view.selectedIndexes()
            selected_paths = []
            if selected:
                selected_paths = [current_browser.file_model.filePath(index) for index in selected]
            
            # Single file/directory context
            if len(selected_paths) == 1:
                self.add_single_item_context(menu, selected_paths[0], current_browser)
            # Multiple selection context
            elif len(selected_paths) > 1:
                self.add_multi_item_context(menu, selected_paths, current_browser)
            # Empty space context
            else:
                self.add_empty_space_context(menu, current_browser)
            
            # Show the menu
            action = menu.exec_(view.mapToGlobal(position))

    def add_single_item_context(self, menu, path, browser):
        """Add context menu items for single selection"""
        is_dir = os.path.isdir(path)
        is_file = os.path.isfile(path)
        is_symlink = os.path.islink(path)
        is_executable = os.access(path, os.X_OK) and is_file
        
        # Open actions
        open_menu = menu.addMenu("Open")
        if is_dir:
            open_action = open_menu.addAction("Open in New Tab")
            open_action.triggered.connect(lambda: self.open_in_new_tab(path))
            
            open_terminal_action = open_menu.addAction("Open in Terminal")
            open_terminal_action.triggered.connect(lambda: TerminalLauncher.open_terminal(path))
            
            open_terminal_root_action = open_menu.addAction("Open in Terminal as Root")
            open_terminal_root_action.triggered.connect(lambda: TerminalLauncher.open_terminal_as_root(path))
            
            open_as_root_action = open_menu.addAction("Open as Root")
            open_as_root_action.triggered.connect(lambda: self.open_as_root(path))
            
            # Add "Open Folder as Root" as a separate top-level menu item
            open_folder_root_action = menu.addAction("Open Folder as Root")
            open_folder_root_action.triggered.connect(lambda: self.open_folder_as_root(path))
        else:
            open_action = open_menu.addAction("Open with Default Application")
            open_action.triggered.connect(lambda: self.open_with_default(path))
            
            open_with_menu = open_menu.addMenu("Open With")
            self.add_open_with_apps(open_with_menu, path)
            
            open_as_root_action = open_menu.addAction("Open as Root")
            open_as_root_action.triggered.connect(lambda: self.open_as_root(path))
        
        # If it's an executable file
        if is_executable:
            run_action = menu.addAction("Run")
            run_action.triggered.connect(lambda: self.run_executable(path))
            
            run_as_root_action = menu.addAction("Run as Root")
            run_as_root_action.triggered.connect(lambda: self.run_executable_as_root(path))
        
        menu.addSeparator()
        
        # Cut, Copy, Paste operations
        cut_action = menu.addAction("Cut")
        cut_action.triggered.connect(self.cut_files)
        
        copy_action = menu.addAction("Copy")
        copy_action.triggered.connect(self.copy_files)
        
        paste_action = menu.addAction("Paste")
        paste_action.triggered.connect(self.paste_files)
        paste_action.setEnabled(bool(self.clipboard_paths))
        
        menu.addSeparator()
        
        # Rename and Delete
        rename_action = menu.addAction("Rename")
        rename_action.triggered.connect(self.rename_file)
        
        delete_action = menu.addAction("Move to Trash" if self.has_trash() else "Delete")
        delete_action.triggered.connect(self.move_to_trash_or_delete)
        
        menu.addSeparator()
        
        # Create links and shortcuts
        link_menu = menu.addMenu("Create Link")
        
        symlink_action = link_menu.addAction("Create Symbolic Link")
        symlink_action.triggered.connect(lambda: self.create_symlink(path, browser.current_path))
        
        hardlink_action = link_menu.addAction("Create Hard Link")
        hardlink_action.triggered.connect(lambda: self.create_hardlink(path, browser.current_path))
        
        # Compression
        compress_menu = menu.addMenu("Compress")
        
        zip_action = compress_menu.addAction("Create .zip Archive")
        zip_action.triggered.connect(lambda: self.compress_files([path], 'zip'))
        
        tar_gz_action = compress_menu.addAction("Create .tar.gz Archive")
        tar_gz_action.triggered.connect(lambda: self.compress_files([path], 'tar.gz'))
        
        # If it's an archive
        if self.is_archive(path):
            extract_menu = menu.addMenu("Extract")
            
            extract_here_action = extract_menu.addAction("Extract Here")
            extract_here_action.triggered.connect(lambda: self.extract_archive(path))
            
            extract_to_action = extract_menu.addAction("Extract To...")
            extract_to_action.triggered.connect(lambda: self.extract_archive_to(path))
        
        # Send To menu
        send_to_menu = menu.addMenu("Send To")
        self.add_send_to_options(send_to_menu, path)
        
        menu.addSeparator()
        
        # Bookmark if directory
        if is_dir:
            bookmark_action = menu.addAction("Add to Bookmarks")
            bookmark_action.triggered.connect(lambda: self.add_bookmark_from_path(path))
        
        # Properties
        properties_action = menu.addAction("Properties")
        properties_action.triggered.connect(lambda: self.show_properties([path]))
        
        # Advanced permissions submenu
        if platform.system() == "Linux":
            perm_menu = menu.addMenu("Permissions")
            self.add_permission_options(perm_menu, path)

    def add_multi_item_context(self, menu, paths, browser):
        """Add context menu items for multiple selection"""
        # Basic operations
        cut_action = menu.addAction("Cut")
        cut_action.triggered.connect(self.cut_files)
        
        copy_action = menu.addAction("Copy")
        copy_action.triggered.connect(self.copy_files)
        
        menu.addSeparator()
        
        delete_action = menu.addAction("Move to Trash" if self.has_trash() else "Delete")
        delete_action.triggered.connect(self.move_to_trash_or_delete)
        
        menu.addSeparator()
        
        # Compression for multiple files
        compress_menu = menu.addMenu("Compress")
        
        zip_action = compress_menu.addAction("Create .zip Archive")
        zip_action.triggered.connect(lambda: self.compress_files(paths, 'zip'))
        
        tar_gz_action = compress_menu.addAction("Create .tar.gz Archive")
        tar_gz_action.triggered.connect(lambda: self.compress_files(paths, 'tar.gz'))
        
        # Compare files (if exactly 2 files selected)
        if len(paths) == 2 and all(os.path.isfile(p) for p in paths):
            compare_action = menu.addAction("Compare Files")
            compare_action.triggered.connect(lambda: self.compare_files(paths[0], paths[1]))
        
        menu.addSeparator()
        
        # Properties for multiple selection
        properties_action = menu.addAction("Properties")
        properties_action.triggered.connect(lambda: self.show_properties(paths))

    def add_empty_space_context(self, menu, browser):
        """Add context menu items for empty space"""
        # New items
        new_menu = menu.addMenu("New")
        
        folder_action = new_menu.addAction("Folder")
        folder_action.triggered.connect(self.new_folder)
        
        file_action = new_menu.addAction("File")
        file_action.triggered.connect(self.new_file)
        
        # Template files can be added here
        template_menu = new_menu.addMenu("From Template")
        self.add_template_options(template_menu, browser.current_path)
        
        menu.addSeparator()
        
        # Paste if clipboard has content
        paste_action = menu.addAction("Paste")
        paste_action.triggered.connect(self.paste_files)
        paste_action.setEnabled(bool(self.clipboard_paths))
        
        menu.addSeparator()
        
        # Open terminal here
        open_terminal_action = menu.addAction("Open Terminal Here")
        open_terminal_action.triggered.connect(lambda: TerminalLauncher.open_terminal(browser.current_path))
        
        open_terminal_root_action = menu.addAction("Open Terminal Here as Root")
        open_terminal_root_action.triggered.connect(lambda: TerminalLauncher.open_terminal_as_root(browser.current_path))
        
        # Open folder as root
        open_folder_root_action = menu.addAction("Open Folder as Root")
        open_folder_root_action.triggered.connect(lambda: self.open_folder_as_root(browser.current_path))
        
        # Refresh
        refresh_action = menu.addAction("Refresh")
        refresh_action.triggered.connect(lambda: self.load_directory(browser.current_path))
        
        menu.addSeparator()
        
        # Customize folder (view options, etc.)
        customize_action = menu.addAction("Customize This Folder...")
        customize_action.triggered.connect(lambda: self.customize_folder(browser))
        
        # Properties of current directory
        properties_action = menu.addAction("Properties")
        properties_action.triggered.connect(lambda: self.show_properties([browser.current_path]))

    def add_open_with_apps(self, menu, path):
        """Add applications to Open With submenu"""
        mime_type, _ = mimetypes.guess_type(path)
        if not mime_type:
            return
        
        # Common applications for different mime types
        apps = []
        
        if mime_type.startswith('text/'):
            apps = ['gedit', 'kate', 'vim', 'nano', 'code']
        elif mime_type.startswith('image/'):
            apps = ['gimp', 'eog', 'feh', 'ristretto']
        elif mime_type.startswith('video/'):
            apps = ['vlc', 'mpv', 'smplayer']
        elif mime_type.startswith('audio/'):
            apps = ['vlc', 'audacious', 'clementine']
        elif mime_type == 'application/pdf':
            apps = ['evince', 'okular', 'acroread']
        
        for app in apps:
            if shutil.which(app):
                action = menu.addAction(app)
                action.triggered.connect(lambda checked, a=app: self.open_with_application(path, a))

    def add_send_to_options(self, menu, path):
        """Add Send To options"""
        # Email as attachment (if file)
        if os.path.isfile(path):
            email_action = menu.addAction("Email as Attachment")
            email_action.triggered.connect(lambda: self.email_file(path))
        
        # Send to removable drives
        removable_drives = self.get_removable_drives()
        if removable_drives:
            drives_menu = menu.addMenu("Send To Removable Drive")
            for drive in removable_drives:
                action = drives_menu.addAction(drive)
                action.triggered.connect(lambda checked, d=drive, p=path: self.copy_to_drive(p, d))
        
        # Send to Bluetooth (if available)
        if shutil.which('bluetooth-sendto'):
            bluetooth_action = menu.addAction("Send via Bluetooth")
            bluetooth_action.triggered.connect(lambda: self.send_via_bluetooth(path))

    def add_permission_options(self, menu, path):
        """Add permission options for Linux"""
        try:
            stat_info = os.stat(path)
            current_mode = stat_info.st_mode
            
            # Read-only option
            read_only_action = menu.addAction("Read-Only")
            read_only_action.triggered.connect(lambda: FileOperations.change_permissions(path, 0o444))
            
            # Read-write option
            read_write_action = menu.addAction("Read-Write")
            read_write_action.triggered.connect(lambda: FileOperations.change_permissions(path, 0o666))
            
            # Executable option
            if os.path.isfile(path):
                executable_action = menu.addAction("Executable")
                executable_action.triggered.connect(lambda: FileOperations.change_permissions(path, current_mode | stat.S_IXUSR))
            
            menu.addSeparator()
            
            # Advanced permissions dialog
            advanced_action = menu.addAction("Advanced Permissions...")
            advanced_action.triggered.connect(lambda: self.show_advanced_permissions(path))
            
        except Exception as e:
            print(f"Error with permissions: {e}")

    def add_template_options(self, menu, current_path):
        """Add template file options"""
        templates = [
            ("Text File", ".txt"),
            ("HTML File", ".html"),
            ("Python Script", ".py"),
            ("Shell Script", ".sh"),
            ("XML File", ".xml"),
            ("JSON File", ".json"),
        ]
        
        for name, ext in templates:
            action = menu.addAction(name)
            action.triggered.connect(lambda checked, n=name, e=ext: self.create_from_template(current_path, n, e))

    # New action implementations
    
    def open_in_new_tab(self, path):
        """Open directory in new tab"""
        self.new_tab()
        current_browser = self.tab_widget.currentWidget()
        if current_browser:
            self.load_directory(path)

    def open_with_default(self, path):
        """Open file with default application"""
        try:
            if platform.system() == "Linux":
                subprocess.run(['xdg-open', path])
            elif platform.system() == "Darwin":
                subprocess.run(['open', path])
            elif platform.system() == "Windows":
                os.startfile(path)
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open file: {e}")

    def open_with_application(self, path, application):
        """Open file with specific application"""
        try:
            subprocess.Popen([application, path])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open with {application}: {e}")

    def open_as_root(self, path):
        """Open file or directory as root using Thunar"""
        try:
            if os.path.isdir(path):
                # For directories, open in Thunar as root
                subprocess.Popen(['sudo', 'thunar', path])
            else:
                # For files, open the parent directory in Thunar as root
                parent_dir = os.path.dirname(path)
                subprocess.Popen(['sudo', 'thunar', parent_dir])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open as root: {e}")

    def open_folder_as_root(self, path):
        """Open folder as root in Thunar"""
        try:
            subprocess.Popen(['sudo', 'thunar', path])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open folder as root: {e}")

    def run_executable(self, path):
        """Run executable file"""
        try:
            subprocess.Popen([path])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not run executable: {e}")

    def run_executable_as_root(self, path):
        """Run executable file as root using sudo"""
        try:
            subprocess.Popen(['sudo', path])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not run executable as root: {e}")

    def create_symlink(self, source_path, dest_dir):
        """Create symbolic link"""
        source_name = os.path.basename(source_path)
        link_name = f"{source_name} (Link)"
        link_path = os.path.join(dest_dir, link_name)
        
        if FileOperations.create_symlink(source_path, link_path):
            self.load_directory(dest_dir)
        else:
            QMessageBox.warning(self, "Error", "Could not create symbolic link")

    def create_hardlink(self, source_path, dest_dir):
        """Create hard link"""
        source_name = os.path.basename(source_path)
        link_name = f"{source_name} (Hard Link)"
        link_path = os.path.join(dest_dir, link_name)
        
        try:
            os.link(source_path, link_path)
            self.load_directory(dest_dir)
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not create hard link: {e}")

    def compress_files(self, files, format_type):
        """Compress files into archive"""
        if not files:
            return
        
        dest_dir = os.path.dirname(files[0])
        default_name = f"archive.{format_type}"
        
        file_path, _ = QFileDialog.getSaveFileName(
            self, "Save Archive As", os.path.join(dest_dir, default_name),
            f"Archive (*.{format_type})"
        )
        
        if file_path:
            if FileOperations.create_archive(files, file_path):
                QMessageBox.information(self, "Success", "Archive created successfully")
            else:
                QMessageBox.warning(self, "Error", "Could not create archive")

    def is_archive(self, path):
        """Check if file is a supported archive"""
        archive_extensions = ['.zip', '.tar', '.tar.gz', '.tgz', '.tar.bz2', '.rar', '.7z']
        return any(path.lower().endswith(ext) for ext in archive_extensions)

    def extract_archive(self, archive_path):
        """Extract archive to current directory"""
        if FileOperations.extract_archive(archive_path):
            self.load_directory(os.path.dirname(archive_path))
        else:
            QMessageBox.warning(self, "Error", "Could not extract archive")

    def extract_archive_to(self, archive_path):
        """Extract archive to selected directory"""
        dest_dir = QFileDialog.getExistingDirectory(self, "Extract To")
        if dest_dir:
            if FileOperations.extract_archive(archive_path, dest_dir):
                QMessageBox.information(self, "Success", "Archive extracted successfully")
            else:
                QMessageBox.warning(self, "Error", "Could not extract archive")

    def has_trash(self):
        """Check if system has trash functionality"""
        return platform.system() == "Linux" and shutil.which('gio')

    def move_to_trash_or_delete(self):
        """Move files to trash or delete permanently"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_view'):
            view = current_browser.current_view
            selected = view.selectedIndexes()
            if selected:
                paths = [current_browser.file_model.filePath(index) for index in selected]
                
                if self.has_trash():
                    # Use gio trash on Linux
                    try:
                        for path in paths:
                            subprocess.run(['gio', 'trash', path], check=True)
                    except subprocess.CalledProcessError as e:
                        QMessageBox.warning(self, "Error", f"Could not move to trash: {e}")
                        return
                else:
                    # Permanent deletion with confirmation
                    reply = QMessageBox.question(
                        self, "Confirm Delete",
                        f"Permanently delete {len(paths)} item(s)?",
                        QMessageBox.Yes | QMessageBox.No
                    )
                    if reply == QMessageBox.Yes:
                        for path in paths:
                            try:
                                if os.path.isdir(path):
                                    shutil.rmtree(path)
                                else:
                                    os.remove(path)
                            except Exception as e:
                                QMessageBox.warning(self, "Error", f"Could not delete {path}: {e}")
                
                # Refresh view
                self.load_directory(current_browser.current_path)

    def show_properties(self, paths):
        """Show file properties dialog"""
        dialog = FilePropertiesDialog(paths, self)
        dialog.exec_()

    def show_advanced_permissions(self, path):
        """Show advanced permissions dialog"""
        # This would be a more detailed permissions editor
        # For now, we'll use the properties dialog
        self.show_properties([path])

    def create_from_template(self, current_path, name, extension):
        """Create file from template"""
        file_name = f"New{name.replace(' ', '')}{extension}"
        file_path = os.path.join(current_path, file_name)
        
        try:
            with open(file_path, 'w') as f:
                # Add basic template content based on file type
                if extension == '.py':
                    f.write('#!/usr/bin/env python3\n\n')
                elif extension == '.sh':
                    f.write('#!/bin/bash\n\n')
                elif extension == '.html':
                    f.write('<!DOCTYPE html>\n<html>\n<head>\n<title>Page Title</title>\n</head>\n<body>\n\n</body>\n</html>')
            
            self.load_directory(current_path)
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not create file: {e}")

    def get_removable_drives(self):
        """Get list of removable drives"""
        drives = []
        try:
            for partition in psutil.disk_partitions():
                if 'removable' in partition.opts or any(x in partition.mountpoint for x in ['/media/', '/run/media/']):
                    drives.append(partition.mountpoint)
        except:
            pass
        return drives

    def copy_to_drive(self, source_path, drive_path):
        """Copy file to removable drive"""
        try:
            dest_path = os.path.join(drive_path, os.path.basename(source_path))
            if os.path.isdir(source_path):
                shutil.copytree(source_path, dest_path)
            else:
                shutil.copy2(source_path, dest_path)
            QMessageBox.information(self, "Success", "File copied to drive")
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not copy to drive: {e}")

    def send_via_bluetooth(self, path):
        """Send file via Bluetooth"""
        try:
            subprocess.Popen(['bluetooth-sendto', path])
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not send via Bluetooth: {e}")

    def email_file(self, path):
        """Email file as attachment"""
        try:
            # Try to open default email client with attachment
            if platform.system() == "Linux":
                subprocess.Popen(['xdg-email', '--attach', path])
            else:
                QMessageBox.information(self, "Info", "Please attach the file to your email manually")
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not open email client: {e}")

    def compare_files(self, file1, file2):
        """Compare two files"""
        try:
            # Use diff command for comparison
            result = subprocess.run(['diff', '-u', file1, file2], capture_output=True, text=True)
            
            # Show comparison result in dialog
            dialog = QDialog(self)
            dialog.setWindowTitle("File Comparison")
            dialog.setMinimumSize(600, 400)
            
            layout = QVBoxLayout(dialog)
            text_edit = QTextEdit()
            text_edit.setFont(QFont("Monospace"))
            
            if result.returncode == 0:
                text_edit.setText("Files are identical")
            else:
                text_edit.setText(result.stdout or "No differences found" if result.returncode == 1 else result.stderr)
            
            layout.addWidget(text_edit)
            
            button_box = QDialogButtonBox(QDialogButtonBox.Ok)
            button_box.accepted.connect(dialog.accept)
            layout.addWidget(button_box)
            
            dialog.exec_()
        except Exception as e:
            QMessageBox.warning(self, "Error", f"Could not compare files: {e}")

    def customize_folder(self, browser):
        """Customize folder view options"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Customize Folder")
        dialog.setMinimumWidth(400)
        
        layout = QVBoxLayout(dialog)
        
        # View mode
        view_group = QGroupBox("View Mode")
        view_layout = QVBoxLayout(view_group)
        
        icon_radio = QRadioButton("Icon View")
        list_radio = QRadioButton("List View")
        detail_radio = QRadioButton("Detail View")
        
        # Set current view
        if browser.view_stack.currentWidget() == browser.icon_view:
            icon_radio.setChecked(True)
        elif browser.view_stack.currentWidget() == browser.list_view:
            list_radio.setChecked(True)
        else:
            detail_radio.setChecked(True)
        
        view_layout.addWidget(icon_radio)
        view_layout.addWidget(list_radio)
        view_layout.addWidget(detail_radio)
        
        # Sort options
        sort_group = QGroupBox("Sort By")
        sort_layout = QVBoxLayout(sort_group)
        
        name_radio = QRadioButton("Name")
        size_radio = QRadioButton("Size")
        date_radio = QRadioButton("Date")
        type_radio = QRadioButton("Type")
        
        name_radio.setChecked(True)  # Default
        
        sort_layout.addWidget(name_radio)
        sort_layout.addWidget(size_radio)
        sort_layout.addWidget(date_radio)
        sort_layout.addWidget(type_radio)
        
        layout.addWidget(view_group)
        layout.addWidget(sort_group)
        
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        button_box.accepted.connect(dialog.accept)
        button_box.rejected.connect(dialog.reject)
        layout.addWidget(button_box)
        
        if dialog.exec_() == QDialog.Accepted:
            # Apply view mode
            if icon_radio.isChecked():
                self.change_view('icon')
            elif list_radio.isChecked():
                self.change_view('list')
            else:
                self.change_view('detail')

    def add_bookmark_from_path(self, path):
        """Add bookmark from context menu"""
        name = os.path.basename(path) or path
        if self.bookmark_manager.add_bookmark(name, path):
            self.load_bookmarks()
            QMessageBox.information(self, "Bookmark Added", f"Added bookmark for {path}")

    def copy_files(self):
        """Copy selected files"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_view'):
            view = current_browser.current_view
            selected = view.selectedIndexes()
            if selected:
                self.clipboard_paths = []
                for index in selected:
                    path = current_browser.file_model.filePath(index)
                    self.clipboard_paths.append(path)
                self.clipboard_operation = 'copy'

    def cut_files(self):
        """Cut selected files"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_view'):
            view = current_browser.current_view
            selected = view.selectedIndexes()
            if selected:
                self.clipboard_paths = []
                for index in selected:
                    path = current_browser.file_model.filePath(index)
                    self.clipboard_paths.append(path)
                self.clipboard_operation = 'cut'

    def paste_files(self):
        """Paste files from clipboard"""
        if not self.clipboard_paths:
            return
        
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_path'):
            dest_path = current_browser.current_path
            
            for src_path in self.clipboard_paths:
                try:
                    # Get the intended destination path
                    dest_file = os.path.join(dest_path, os.path.basename(src_path))
                    
                    # For copy operations, always use unique filename
                    if self.clipboard_operation == 'copy':
                        # Get unique filename if destination already exists
                        dest_file = FileOperations.get_unique_filename(dest_file)
                        
                        if os.path.isdir(src_path):
                            shutil.copytree(src_path, dest_file)
                        else:
                            shutil.copy2(src_path, dest_file)
                            
                    elif self.clipboard_operation == 'cut':
                        # For move operations, check if source and destination are the same
                        if os.path.dirname(src_path) == dest_path:
                            # Moving within same folder - use unique filename
                            dest_file = FileOperations.get_unique_filename(dest_file)
                        shutil.move(src_path, dest_file)
                        
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Could not paste {src_path}: {e}")
            
            # Clear clipboard if it was a cut operation
            if self.clipboard_operation == 'cut':
                self.clipboard_paths = []
                self.clipboard_operation = None
            
            # Refresh view
            self.load_directory(dest_path)

    def delete_files(self):
        """Delete selected files"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_view'):
            view = current_browser.current_view
            selected = view.selectedIndexes()
            if selected:
                reply = QMessageBox.question(self, "Confirm Delete", 
                                           f"Are you sure you want to delete {len(selected)} item(s)?",
                                           QMessageBox.Yes | QMessageBox.No)
                if reply == QMessageBox.Yes:
                    for index in selected:
                        path = current_browser.file_model.filePath(index)
                        try:
                            if os.path.isdir(path):
                                shutil.rmtree(path)
                            else:
                                os.remove(path)
                        except Exception as e:
                            QMessageBox.warning(self, "Error", f"Could not delete {path}: {e}")
                    
                    # Refresh view
                    self.load_directory(current_browser.current_path)

    def rename_file(self):
        """Rename selected file"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_view'):
            view = current_browser.current_view
            selected = view.selectedIndexes()
            if len(selected) == 1:
                index = selected[0]
                old_path = current_browser.file_model.filePath(index)
                old_name = os.path.basename(old_path)
                
                new_name, ok = QInputDialog.getText(self, "Rename", "New name:", text=old_name)
                if ok and new_name and new_name != old_name:
                    new_path = os.path.join(os.path.dirname(old_path), new_name)
                    try:
                        os.rename(old_path, new_path)
                        # Refresh view
                        self.load_directory(current_browser.current_path)
                    except Exception as e:
                        QMessageBox.warning(self, "Error", f"Could not rename: {e}")

    def add_selected_to_bookmarks(self):
        """Add selected directory to bookmarks"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_view'):
            view = current_browser.current_view
            selected = view.selectedIndexes()
            if len(selected) == 1:
                path = current_browser.file_model.filePath(selected[0])
                if os.path.isdir(path):
                    name = os.path.basename(path)
                    if self.bookmark_manager.add_bookmark(name, path):
                        self.load_bookmarks()
                        QMessageBox.information(self, "Bookmark Added", f"Added bookmark for {path}")

    def new_folder(self):
        """Create a new folder"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_path'):
            name, ok = QInputDialog.getText(self, "New Folder", "Folder name:")
            if ok and name:
                folder_path = os.path.join(current_browser.current_path, name)
                try:
                    os.makedirs(folder_path)
                    # Refresh view
                    self.load_directory(current_browser.current_path)
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Could not create folder: {e}")

    def new_file(self):
        """Create a new file"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_path'):
            name, ok = QInputDialog.getText(self, "New File", "File name:")
            if ok and name:
                file_path = os.path.join(current_browser.current_path, name)
                try:
                    with open(file_path, 'w') as f:
                        pass
                    # Refresh view
                    self.load_directory(current_browser.current_path)
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Could not create file: {e}")

    def select_all(self):
        """Select all items in current view"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'current_view'):
            view = current_browser.current_view
            view.selectAll()

    def change_view(self, view_mode):
        """Change the view mode"""
        current_browser = self.tab_widget.currentWidget()
        if current_browser and hasattr(current_browser, 'view_stack'):
            if view_mode == 'icon':
                current_browser.view_stack.setCurrentWidget(current_browser.icon_view)
                current_browser.current_view = current_browser.icon_view
            elif view_mode == 'list':
                current_browser.view_stack.setCurrentWidget(current_browser.list_view)
                current_browser.current_view = current_browser.list_view
            else:  # detail
                current_browser.view_stack.setCurrentWidget(current_browser.detail_view)
                current_browser.current_view = current_browser.detail_view
            
            # Save setting
            self.settings_manager.set_setting('default_view_mode', view_mode)

    def show_about(self):
        """Show about dialog"""
        QMessageBox.about(self, "About Dark Nemo", 
                         "Dark Nemo File Manager\n\n"
                         "A simple, dark-themed file manager\n"
                         "with USB auto-mount support.\n\n"
                         "Features:\n"
                         "• Tabbed interface\n"
                         "• Drag and drop support\n"
                         "• Thumbnail generation\n"
                         "• USB auto-mount\n"
                         "• Hidden files toggle\n"
                         "• Bookmarks")

    def handle_drop_event(self, event, view):
        """Handle drop events for drag and drop"""
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            current_browser = self.tab_widget.currentWidget()
            if current_browser and hasattr(current_browser, 'current_path'):
                dest_path = current_browser.current_path
                self.handle_urls_drop(urls, dest_path, event.dropAction())

    def handle_urls_drop(self, urls, dest_path, drop_action):
        """Handle URLs dropped from external sources"""
        for url in urls:
            if url.isLocalFile():
                src_path = url.toLocalFile()
                try:
                    # Get the intended destination path
                    dest_file = os.path.join(dest_path, os.path.basename(src_path))
                    
                    # For copy operations, always use unique filename
                    if drop_action == Qt.CopyAction:
                        # Get unique filename if destination already exists
                        dest_file = FileOperations.get_unique_filename(dest_file)
                        
                        if os.path.isdir(src_path):
                            shutil.copytree(src_path, dest_file)
                        else:
                            shutil.copy2(src_path, dest_file)
                            
                    elif drop_action == Qt.MoveAction:
                        # For move operations, check if source and destination are the same
                        if os.path.dirname(src_path) == dest_path:
                            # Moving within same folder - use unique filename
                            dest_file = FileOperations.get_unique_filename(dest_file)
                        shutil.move(src_path, dest_file)
                        
                except Exception as e:
                    QMessageBox.warning(self, "Error", f"Could not move/copy {src_path}: {e}")
        
        # Refresh view
        current_browser = self.tab_widget.currentWidget()
        if current_browser:
            self.load_directory(current_browser.current_path)

def main():
    app = QApplication(sys.argv)
    app.setApplicationName("Dark Nemo")
    
    # Check if we were launched with a path argument (for opening as root)
    if len(sys.argv) > 1:
        initial_path = sys.argv[1]
    else:
        initial_path = QDir.homePath()
    
    window = DarkNemo()
    
    # If we were launched with a path argument, navigate to it
    if len(sys.argv) > 1 and os.path.exists(initial_path):
        window.load_directory(initial_path)
    
    window.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()