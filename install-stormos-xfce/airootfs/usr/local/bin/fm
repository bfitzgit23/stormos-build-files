#!/usr/bin/env python3
"""
Modern File Manager â€“ Nemo-Style Edition (with Tabs, Icon View, Thumbnails, Breadcrumbs & Enhanced Drive Detection)
A clean, minimal, and feature-rich file browser for Linux.
Based on the Royal Purple Dark Edition, but styled like Nemo.
"""
import sys
import os
import subprocess
import shutil
import mimetypes
import stat
import tempfile
from pathlib import Path
from typing import List, Optional
from datetime import datetime
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QHBoxLayout, QScrollArea,
    QPushButton, QLabel, QFrame, QMenu, QAction, QMessageBox, QInputDialog,
    QSizePolicy, QLineEdit, QCompleter, QFileSystemModel, QListWidget,
    QListWidgetItem, QAbstractItemView, QFileIconProvider, QTabWidget, QTabBar,
    QToolButton, QButtonGroup, QFileDialog, QDialog, QTextBrowser
)
from PyQt5.QtGui import (
    QFont, QIcon, QKeySequence, QPainter, QColor, QPalette,
    QDesktopServices, QPixmap, QDragEnterEvent, QDragMoveEvent, QDropEvent,
    QDrag
)
from PyQt5.QtCore import Qt, QMimeDatabase, QTimer, QUrl, QFileInfo, QSize, QPoint, QMimeData
from PyQt5.Qt import QShortcut
from PyQt5.QtCore import QSettings

# =============================================================================
# NEUTRAL COLOR SCHEME - Nemo-like Dark Theme (Gray/Blue Focus)
# =============================================================================
COLORS = {
    "background": "#2e2e2e",         # Neutral dark background
    "surface": "#3c3c3c",            # Sidebar/file area
    "surface_frosted": "#3c3c3c",    # No transparency
    "accent": "#5d8ab4",             # Muted blue (like Nemo selection)
    "accent_hover": "#6d9ac4",
    "text_primary": "#ffffff",
    "text_secondary": "#bbbbbb",
    "success": "#73d216",
    "warning": "#f57900",
    "danger": "#cc0000",
    "border": "#555555",
    "highlight": "rgba(93, 138, 180, 0.3)"
}

FILE_TYPE_COLORS = {
    'folder': '#89b4fa',
    'image': '#cba6f7',
    'audio': '#f5c2e7',
    'video': '#fab387',
    'archive': '#f9e2af',
    'document': '#a6e3a1',
    'code': '#74c7ec',
    'generic': '#9399b2'
}

TERMINALS = ['xterm', 'gnome-terminal', 'xfce4-terminal', 'konsole', 'kitty', 'alacritty']
FILE_MANAGERS = {'Thunar': 'thunar', 'Nemo': 'nemo', 'Dolphin': 'dolphin', 'Nautilus': 'nautilus'}

# =============================================================================
# GLOBALS
# =============================================================================
ICON_PROVIDER = QFileIconProvider()
CLIPBOARD_PATHS: List[Path] = []
CLIPBOARD_IS_CUT = False
THUMBNAIL_CACHE = {}

# =============================================================================
# UTILS
# =============================================================================
def get_file_type_category(path: Path) -> str:
    if path.is_dir(): return 'folder'
    mime, _ = mimetypes.guess_type(str(path))
    if not mime: return 'generic'
    if mime.startswith('image/'): return 'image'
    if mime.startswith('audio/'): return 'audio'
    if mime.startswith('video/'): return 'video'
    if any(t in mime for t in ['zip', 'tar', 'gzip', '7z', 'rar']): return 'archive'
    if mime.startswith('text/') or any(ext in str(path).lower() for ext in ['.py', '.js', '.ts', '.sh', '.json', '.yml', '.yaml', '.toml', '.ini', '.cfg', '.md']): return 'code'
    if any(t in mime for t in ['pdf', 'msword', 'vnd.oasis.opendocument', 'vnd.ms-excel']): return 'document'
    return 'generic'

def get_file_emoji(path: Path) -> str:
    cat = get_file_type_category(path)
    emojis = {'folder': 'ðŸ“','image': 'ðŸ–¼ï¸','audio': 'ðŸŽµ','video': 'ðŸŽ¬','archive': 'ðŸ“¦','document': 'ðŸ“„','code': 'ðŸ’»','generic': 'ðŸ“„'}
    return emojis.get(cat, 'ðŸ“„')

def format_size(num: int) -> str:
    for unit in ['B', 'K', 'M', 'G', 'T']:
        if abs(num) < 1024.0: return f"{num:.1f} {unit}"
        num /= 1024.0
    return f"{num:.1f} P"

def get_permissions_str(path: Path) -> str:
    try: return stat.filemode(path.stat().st_mode)
    except: return '------'

def get_modified_str(path: Path) -> str:
    try: return datetime.fromtimestamp(path.stat().st_mtime).strftime('%Y-%m-%d %H:%M')
    except: return '---'

# =============================================================================
# FILE ITEM
# =============================================================================
class FileItem(QListWidgetItem):
    def __init__(self, path: Path, parent_manager: 'FileManager'):
        super().__init__()
        self.path = path.resolve()
        self.parent_manager = parent_manager
        self.is_dir = self.path.is_dir()
        self.file_type = get_file_type_category(self.path)
        self.accent_color = FILE_TYPE_COLORS.get(self.file_type, FILE_TYPE_COLORS['generic'])
        self.setText(self.path.name)

        icon_size = 48 + (parent_manager.zoom_level - 14) * 2
        if parent_manager.view_mode == "icon":
            icon_size = max(64, icon_size + 10)

        if self._is_image_file(path) or self._is_video_file(path):
            pixmap = self._load_thumbnail(path, icon_size)
            icon = QIcon(pixmap) if not pixmap.isNull() else QIcon(ICON_PROVIDER.icon(QFileInfo(str(path))))
        else:
            icon = QIcon(ICON_PROVIDER.icon(QFileInfo(str(path))))
            if not icon.isNull():
                pixmap = icon.pixmap(icon_size, icon_size)
                if not pixmap.isNull():
                    icon = QIcon(pixmap)

        self.setIcon(icon)
        self.setToolTip(str(self.path))
        color = QColor(self.accent_color)
        self.setForeground(color)
        self.setFlags(self.flags() | Qt.ItemIsDragEnabled)

    def _is_image_file(self, path: Path) -> bool:
        if not path.is_file(): return False
        suffix = path.suffix.lower()
        return suffix in {'.png', '.jpg', '.jpeg', '.webp', '.bmp', '.svg', '.gif', '.tiff', '.ico'}

    def _is_video_file(self, path: Path) -> bool:
        if not path.is_file(): return False
        suffix = path.suffix.lower()
        return suffix in {'.mp4', '.mkv', '.avi', '.mov', '.flv', '.webm', '.m4v', '.wmv', '.3gp', '.ogv'}

    def _load_thumbnail(self, path: Path, size: int) -> QPixmap:
        cache_key = (str(path), size)
        if cache_key in THUMBNAIL_CACHE:
            return THUMBNAIL_CACHE[cache_key]
        pixmap = QPixmap()
        suffix = path.suffix.lower()
        try:
            if suffix == '.svg':
                from PyQt5.QtSvg import QSvgRenderer
                renderer = QSvgRenderer(str(path))
                if renderer.isValid():
                    pixmap = QPixmap(size, size)
                    pixmap.fill(Qt.transparent)
                    painter = QPainter(pixmap)
                    renderer.render(painter)
                    painter.end()
                else:
                    pixmap = QPixmap()
            elif self._is_image_file(path):
                # Use QImage for more reliable image loading
                from PyQt5.QtGui import QImage
                img = QImage(str(path))
                if not img.isNull():
                    pixmap = QPixmap.fromImage(img)
                    if not pixmap.isNull():
                        pixmap = pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            elif self._is_video_file(path):
                # Try to use ffmpegthumbnailer first (more reliable than ffmpeg)
                if shutil.which('ffmpegthumbnailer'):
                    with tempfile.NamedTemporaryFile(suffix='.jpg') as tmp:
                        result = subprocess.run([
                            'ffmpegthumbnailer', '-i', str(path), 
                            '-o', tmp.name, '-s', str(size), '-t', '10'
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.PIPE, timeout=10)
                        if result.returncode == 0 and Path(tmp.name).exists() and Path(tmp.name).stat().st_size > 0:
                            pixmap = QPixmap(tmp.name)
                            if not pixmap.isNull():
                                pixmap = pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                # Fallback to ffmpeg if ffmpegthumbnailer is not available
                elif shutil.which('ffmpeg'):
                    with tempfile.NamedTemporaryFile(suffix='.jpg') as tmp:
                        result = subprocess.run([
                            'ffmpeg', '-ss', '10', '-i', str(path),
                            '-vframes', '1', '-q:v', '2', '-y', tmp.name
                        ], stdout=subprocess.DEVNULL, stderr=subprocess.PIPE, timeout=10)
                        if result.returncode == 0 and Path(tmp.name).exists() and Path(tmp.name).stat().st_size > 0:
                            pixmap = QPixmap(tmp.name)
                            if not pixmap.isNull():
                                pixmap = pixmap.scaled(size, size, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                else:
                    print(f"No video thumbnailer available (ffmpegthumbnailer or ffmpeg)", file=sys.stderr)
        except Exception as e:
            print(f"Thumbnail error for {path}: {e}", file=sys.stderr)
            pixmap = QPixmap()
        if not pixmap.isNull():
            THUMBNAIL_CACHE[cache_key] = pixmap
        return pixmap

class FileListWidget(QListWidget):
    def __init__(self, parent_manager: 'FileManager'):
        super().__init__()
        self.parent_manager = parent_manager
        self.setAcceptDrops(True)
        self.setDragEnabled(True)
        self.setDropIndicatorShown(True)
        self.setDragDropMode(QAbstractItemView.DragDrop)
        self.setDefaultDropAction(Qt.MoveAction)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)

    def dragEnterEvent(self, event: QDragEnterEvent):
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if all(url.isLocalFile() for url in urls):
                event.acceptProposedAction()
                return
        event.ignore()

    def dragMoveEvent(self, event: QDragMoveEvent):
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if all(url.isLocalFile() for url in urls):
                event.acceptProposedAction()
                return
        event.ignore()

    def dropEvent(self, event: QDropEvent):
        if event.mimeData().hasUrls():
            self.parent_manager._handle_file_list_drop(event, self)
        else:
            event.ignore()

    def startDrag(self, supportedActions):
        items = self.selectedItems()
        if not items: return
        drag = QDrag(self)
        mime_data = QMimeData()
        urls = [QUrl.fromLocalFile(str(item.path)) for item in items if hasattr(item, 'path')]
        mime_data.setUrls(urls)
        drag.setMimeData(mime_data)

        if len(items) == 1:
            pixmap = items[0].icon().pixmap(32, 32)
            if pixmap.isNull():
                pixmap = QPixmap(32, 32)
                pixmap.fill(QColor(COLORS['accent']))
        else:
            pixmap = QPixmap(48, 48)
            pixmap.fill(QColor(COLORS['surface']))
            painter = QPainter(pixmap)
            painter.setRenderHint(QPainter.Antialiasing)
            painter.setPen(QColor(COLORS['text_primary']))
            painter.drawText(pixmap.rect(), Qt.AlignCenter, f"{len(items)}")
            painter.end()

        drag.setPixmap(pixmap)
        drag.setHotSpot(QPoint(pixmap.width() // 2, pixmap.height() // 2))
        drag.exec_(supportedActions, Qt.MoveAction)

class SidebarButton(QPushButton):
    def __init__(self, name: str, path: Path, parent_manager: 'FileManager', is_bookmark: bool = True):
        super().__init__(name)
        self.target_path = path.resolve()
        self.parent_manager = parent_manager
        self.is_bookmark = is_bookmark
        self.setStyleSheet(self.parent_manager._get_sidebar_button_style())
        self.clicked.connect(lambda _: self.parent_manager._navigate_to_tab(self.target_path))
        self.original_mouse_release = self.mouseReleaseEvent
        self.mouseReleaseEvent = self.enhanced_mouse_release
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(lambda pos: self.parent_manager._sidebar_context_menu(self.target_path, self.mapToGlobal(pos), self.is_bookmark))
        self.setAcceptDrops(True)

    def enhanced_mouse_release(self, e):
        if e.button() == Qt.MiddleButton:
            self.parent_manager._add_new_tab(self.target_path)
            e.accept()
        else:
            self.original_mouse_release(e)

    def dragEnterEvent(self, event: QDragEnterEvent):
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            if all(url.isLocalFile() for url in urls):
                self.setStyleSheet(f"""
                    QPushButton {{
                        background: {COLORS['highlight']};
                        color: {COLORS['accent']};
                        border: 2px dashed {COLORS['accent']};
                        padding: 6px 12px;
                        text-align: left;
                        font-family: 'Sans';
                        font-size: {self.parent_manager.zoom_level + 2}px;
                        border-radius: 0;
                    }}
                """)
                event.acceptProposedAction()
                return
        event.ignore()

    def dragLeaveEvent(self, event):
        self.setStyleSheet(self.parent_manager._get_sidebar_button_style())

    def dropEvent(self, event: QDropEvent):
        self.setStyleSheet(self.parent_manager._get_sidebar_button_style())
        if event.mimeData().hasUrls():
            self.parent_manager._handle_sidebar_drop(event, self, self.target_path)
        else:
            event.ignore()

# =============================================================================
# MAIN FILE MANAGER
# =============================================================================
class FileManager(QWidget):
    def __init__(self):
        super().__init__()
        self.current_path: Path = Path.home().resolve()
        self.show_hidden: bool = False
        self.search_text: str = ''
        self.zoom_level: int = 16
        self.view_mode: str = "list"
        self.show_breadcrumb: bool = False
        self.settings = QSettings("Seeker", "ModernFileManager_NemoStyle")
        self.custom_bookmarks = self.settings.value("customBookmarks", [])
        if not self.custom_bookmarks:
            self.custom_bookmarks = []
        self._init_window()
        self._init_ui()
        self._setup_shortcuts()
        self._center_window()
        self.navigate_to(self.current_path)

    def _init_window(self):
        self.setWindowTitle("Modern File Manager â€“ Nemo Style")
        self.setWindowFlags(Qt.Window)
        # Remove custom rounded window painting
        geometry = self.settings.value("geometry")
        if geometry:
            self.restoreGeometry(geometry)
        else:
            self.resize(1200, 800)
        self.setMinimumSize(1000, 600)

    def _create_sidebar(self, parent_layout):
        sidebar = QFrame()
        sidebar.setStyleSheet(f"""
            QFrame {{
                background: {COLORS['surface']};
                padding: 8px;
                border: none;
            }}
        """)
        sidebar_layout = QVBoxLayout(sidebar)
        sidebar_layout.setSpacing(6)
        sidebar_layout.setContentsMargins(6, 8, 6, 8)

        bookmarks_header = QHBoxLayout()
        bookmarks_header_label = QLabel("Bookmarks")
        bookmarks_header_label.setStyleSheet(f"""
            color: {COLORS['text_primary']};
            font-weight: bold;
            font-size: 14px;
            padding: 4px 0;
        """)
        bookmarks_header.addWidget(bookmarks_header_label)

        add_bookmark_btn = QPushButton("+")
        add_bookmark_btn.setFixedSize(24, 24)
        add_bookmark_btn.setStyleSheet(f"""
            QPushButton {{
                background: {COLORS['success']}40;
                color: {COLORS['success']};
                border: 1px solid {COLORS['success']}60;
                border-radius: 4px;
                font-size: 12px;
                font-weight: bold;
            }}
            QPushButton:hover {{
                background: {COLORS['success']}60;
            }}
        """)
        add_bookmark_btn.clicked.connect(self._add_current_to_bookmarks)
        bookmarks_header.addWidget(add_bookmark_btn)
        bookmarks_header.addStretch()
        sidebar_layout.addLayout(bookmarks_header)

        self.bookmarks_layout = QVBoxLayout()
        self.bookmarks_layout.setSpacing(4)
        self._populate_bookmarks()
        sidebar_layout.addLayout(self.bookmarks_layout)

        drives_header = QLabel("Storage")
        drives_header.setStyleSheet(f"""
            color: {COLORS['text_primary']};
            font-weight: bold;
            font-size: 14px;
            padding: 8px 0 4px 0;
        """)
        sidebar_layout.addWidget(drives_header)

        self.drives_layout = QVBoxLayout()
        self.drives_layout.setSpacing(4)
        self._populate_drives()
        sidebar_layout.addLayout(self.drives_layout)
        sidebar_layout.addStretch()

        sidebar.setFixedWidth(220)
        parent_layout.addWidget(sidebar)

    def _create_file_area(self, parent_layout):
        self.tab_widget = QTabWidget()
        self.tab_widget.setStyleSheet(f"""
            QTabWidget::pane {{
                border: 1px solid {COLORS['border']};
                background: {COLORS['background']};
                top: -1px;
            }}
            QTabBar::tab {{
                background: {COLORS['surface']};
                color: {COLORS['text_primary']};
                padding: 6px 16px;
                border: 1px solid {COLORS['border']};
                border-bottom: none;
                margin-right: 2px;
                border-top-left-radius: 4px;
                border-top-right-radius: 4px;
            }}
            QTabBar::tab:selected {{
                background: {COLORS['background']};
                border-bottom: 1px solid {COLORS['background']};
            }}
        """)
        self._add_new_tab(self.current_path)
        parent_layout.addWidget(self.tab_widget)

    def _add_new_tab(self, path: Path = None):
        if path is None:
            path = Path.home()
        tab_container = QFrame()
        tab_layout = QVBoxLayout(tab_container)
        tab_layout.setContentsMargins(4, 4, 4, 4)

        file_list = FileListWidget(self)
        file_list.setContextMenuPolicy(Qt.CustomContextMenu)
        file_list.customContextMenuRequested.connect(self._on_list_context_menu)
        file_list.itemDoubleClicked.connect(self._on_item_double_clicked)

        list_font_size = 14 if self.view_mode == 'list' else 13
        file_list.setStyleSheet(f"""
            QListWidget {{
                background: {COLORS['background']};
                border: none;
                outline: none;
                font-size: {list_font_size}px;
            }}
            QListWidget::item {{
                padding: 8px 12px;
                border-radius: 4px;
                margin: 2px;
            }}
            QListWidget::item:selected {{
                background: {COLORS['highlight']};
            }}
            QListWidget::item:hover {{
                background: {COLORS['surface']}aa;
            }}
        """)
        tab_layout.addWidget(file_list)

        tab_index = self.tab_widget.addTab(tab_container, path.name)
        self.tab_widget.setCurrentIndex(tab_index)
        setattr(tab_container, 'file_list', file_list)
        setattr(tab_container, 'current_path', path)
        self._populate_files_for_tab(tab_container, path)
        return tab_container

    def _populate_files_for_tab(self, tab_container, path: Path):
        file_list = getattr(tab_container, 'file_list')
        file_list.clear()
        try:
            items = []
            for entry in os.scandir(path):
                try:
                    entry_path = Path(entry.path).resolve()
                    if self.show_hidden or not entry_path.name.startswith('.'):
                        if not self.search_text or self.search_text.lower() in entry_path.name.lower():
                            items.append(entry_path)
                except (OSError, ValueError): continue
            items.sort(key=lambda x: (x.is_file(), x.name.lower()))
        except (PermissionError, FileNotFoundError, OSError) as e:
            msg = "Permission Denied" if isinstance(e, PermissionError) else "Directory not accessible"
            item = QListWidgetItem(msg)
            item.setFlags(item.flags() & ~Qt.ItemIsSelectable)
            item.setTextAlignment(Qt.AlignCenter)
            file_list.addItem(item)
            return

        for p in items:
            try: file_list.addItem(FileItem(p, self))
            except Exception as e: print(f"Item error: {e}", file=sys.stderr); continue

        if not items:
            empty_item = QListWidgetItem("Folder is empty")
            empty_item.setFlags(empty_item.flags() & ~Qt.ItemIsSelectable)
            empty_item.setTextAlignment(Qt.AlignCenter)
            file_list.addItem(empty_item)

        if self.view_mode == "icon":
            file_list.setResizeMode(QListWidget.Adjust)
            file_list.setGridSize(QSize(120, 120))
            file_list.setViewMode(QListWidget.IconMode)
            file_list.setWordWrap(True)
            icon_size = 64 + (self.zoom_level - 16) * 2
            file_list.setIconSize(QSize(icon_size, icon_size))
        else:
            file_list.setViewMode(QListWidget.ListMode)

    def _init_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(12, 12, 12, 12)
        main_layout.setSpacing(12)

        top_bar = QHBoxLayout()
        top_bar.setSpacing(8)

        self.address_bar = QLineEdit(str(self.current_path))
        self.address_bar.setPlaceholderText("Navigate or search...")
        self.address_bar.setStyleSheet(f"""
            QLineEdit {{
                background: {COLORS['surface']};
                color: {COLORS['text_primary']};
                border: 1px solid {COLORS['border']};
                border-radius: 4px;
                padding: 6px 10px;
                font-size: 13px;
                min-height: 24px;
            }}
            QLineEdit:focus {{
                border: 1px solid {COLORS['accent']};
            }}
        """)
        self.address_bar.returnPressed.connect(self._on_address_bar_return)
        self._setup_address_bar_completer()
        top_bar.addWidget(self.address_bar)

        self.breadcrumb_widget = QWidget()
        self.breadcrumb_layout = QHBoxLayout()
        self.breadcrumb_layout.setSpacing(4)
        self.breadcrumb_layout.setContentsMargins(0, 0, 0, 0)
        self.breadcrumb_widget.setLayout(self.breadcrumb_layout)
        self.breadcrumb_widget.setVisible(False)
        top_bar.addWidget(self.breadcrumb_widget)

        button_style = self._get_large_button_style()

        toggle_nav_btn = QPushButton("N")
        toggle_nav_btn.setFixedSize(32, 32)
        toggle_nav_btn.setStyleSheet(button_style)
        toggle_nav_btn.clicked.connect(self._toggle_navigation_bar)
        top_bar.addWidget(toggle_nav_btn)

        new_tab_btn = QPushButton("+")
        new_tab_btn.setFixedSize(32, 32)
        new_tab_btn.setStyleSheet(button_style)
        new_tab_btn.clicked.connect(lambda: self._add_new_tab())
        top_bar.addWidget(new_tab_btn)

        refresh_btn = QPushButton("âŸ³")
        refresh_btn.setFixedSize(32, 32)
        refresh_btn.setStyleSheet(button_style)
        refresh_btn.clicked.connect(self.refresh)
        top_bar.addWidget(refresh_btn)

        up_btn = QPushButton("â†‘")
        up_btn.setFixedSize(32, 32)
        up_btn.setStyleSheet(button_style)
        up_btn.clicked.connect(self.go_up)
        top_bar.addWidget(up_btn)

        hidden_btn = QPushButton("â€¢â€¢â€¢")
        hidden_btn.setFixedSize(32, 32)
        hidden_btn.setStyleSheet(button_style)
        hidden_btn.clicked.connect(self.toggle_hidden)
        top_bar.addWidget(hidden_btn)

        view_btn = QPushButton("V")
        view_btn.setFixedSize(32, 32)
        view_btn.setStyleSheet(button_style)
        view_btn.clicked.connect(self._toggle_view_mode)
        top_bar.addWidget(view_btn)

        main_layout.addLayout(top_bar)

        content_splitter = QHBoxLayout()
        content_splitter.setSpacing(12)
        self._create_sidebar(content_splitter)
        self._create_file_area(content_splitter)
        main_layout.addLayout(content_splitter)

        self.status_label = QLabel()
        self.status_label.setStyleSheet(f"""
            color: {COLORS['text_secondary']};
            font-size: 12px;
            padding: 6px 8px;
            border-top: 1px solid {COLORS['border']};
            background: {COLORS['surface']};
        """)
        main_layout.addWidget(self.status_label)

    def _setup_address_bar_completer(self):
        completer = QCompleter()
        completer_model = QFileSystemModel()
        completer_model.setRootPath("")
        completer.setModel(completer_model)
        completer.setCaseSensitivity(Qt.CaseInsensitive)
        self.address_bar.setCompleter(completer)

    def _get_large_button_style(self) -> str:
        return f"""
            QPushButton {{
                background: {COLORS['surface']};
                color: {COLORS['text_primary']};
                border: 1px solid {COLORS['border']};
                border-radius: 4px;
                font-size: 12px;
                font-weight: normal;
                width: 32px;
                height: 32px;
            }}
            QPushButton:hover {{
                background: {COLORS['highlight']};
            }}
        """

    def _get_sidebar_button_style(self) -> str:
        font_size = self.zoom_level + 2
        return f"""
            QPushButton {{
                background: transparent;
                color: {COLORS['text_primary']};
                border: none;
                padding: 6px 12px;
                text-align: left;
                font-family: 'Sans';
                font-size: {font_size}px;
                border-radius: 0;
            }}
            QPushButton:hover {{
                background: {COLORS['highlight']};
                color: white;
            }}
        """

    def _populate_bookmarks(self):
        while self.bookmarks_layout.count():
            child = self.bookmarks_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()

        for bookmark_path_str in self.custom_bookmarks:
            try:
                path = Path(bookmark_path_str)
                if path.exists():
                    btn = SidebarButton(f"ðŸ“Œ {path.name}", path, self, is_bookmark=True)
                    self.bookmarks_layout.addWidget(btn)
            except Exception as e:
                print(f"Error loading bookmark {bookmark_path_str}: {e}")

        gtk_bookmarks = self._get_gtk_bookmarks()
        for path, name in gtk_bookmarks:
            btn = SidebarButton(f"â­ {name}", path, self, is_bookmark=False)
            self.bookmarks_layout.addWidget(btn)

    def _get_gtk_bookmarks(self) -> List[tuple[Path, str]]:
        bookmarks = []
        bookmark_files = [
            Path.home() / ".config" / "gtk-3.0" / "bookmarks",
            Path.home() / ".gtk-bookmarks"
        ]
        for bookmark_file in bookmark_files:
            if bookmark_file.exists():
                try:
                    with open(bookmark_file, 'r', encoding='utf-8') as f:
                        for line in f:
                            line = line.strip()
                            if line:
                                parts = line.split(' ', 1)
                                uri = parts[0]
                                if uri.startswith('file://'):
                                    path_str = uri[7:]
                                    path = Path(path_str).expanduser()
                                    name = parts[1] if len(parts) > 1 else path.name
                                    if path.exists():
                                        bookmarks.append((path, name))
                                elif not uri.startswith(('ftp', 'sftp')):
                                    path = Path(uri).expanduser()
                                    if path.exists():
                                        name = path.name
                                        bookmarks.append((path, name))
                except (IOError, OSError) as e:
                    print(f"Could not read GTK bookmarks file {bookmark_file}: {e}", file=sys.stderr)
                break
        return bookmarks

    def _add_current_to_bookmarks(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab or not hasattr(current_tab, 'current_path'): return
        path = current_tab.current_path
        path_str = str(path)
        if path_str in self.custom_bookmarks:
            QMessageBox.information(self, "Already Bookmarked", f"'{path.name}' is already in your bookmarks.")
            return
        self.custom_bookmarks.append(path_str)
        self.settings.setValue("customBookmarks", self.custom_bookmarks)
        self._populate_bookmarks()
        QMessageBox.information(self, "Bookmark Added", f"Added '{path.name}' to bookmarks.")

    def _remove_from_bookmarks(self, path: Path):
        path_str = str(path)
        if path_str in self.custom_bookmarks:
            self.custom_bookmarks.remove(path_str)
            self.settings.setValue("customBookmarks", self.custom_bookmarks)
            self._populate_bookmarks()
            QMessageBox.information(self, "Bookmark Removed", f"Removed '{path.name}' from bookmarks.")

    def _move_bookmark_up(self, path: Path):
        path_str = str(path)
        if path_str in self.custom_bookmarks:
            index = self.custom_bookmarks.index(path_str)
            if index > 0:
                self.custom_bookmarks[index], self.custom_bookmarks[index-1] = self.custom_bookmarks[index-1], self.custom_bookmarks[index]
                self.settings.setValue("customBookmarks", self.custom_bookmarks)
                self._populate_bookmarks()

    def _move_bookmark_down(self, path: Path):
        path_str = str(path)
        if path_str in self.custom_bookmarks:
            index = self.custom_bookmarks.index(path_str)
            if index < len(self.custom_bookmarks) - 1:
                self.custom_bookmarks[index], self.custom_bookmarks[index+1] = self.custom_bookmarks[index+1], self.custom_bookmarks[index]
                self.settings.setValue("customBookmarks", self.custom_bookmarks)
                self._populate_bookmarks()

    def _populate_drives(self):
        while self.drives_layout.count():
            child = self.drives_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        seen = set()
        try:
            with open('/proc/mounts') as f:
                for line in f:
                    parts = line.split()
                    if len(parts) < 2: continue
                    mp = Path(parts[1])
                    fstype = parts[2]
                    storage_fstypes = {
                        'ext2', 'ext3', 'ext4', 'xfs', 'btrfs', 'jfs', 'reiserfs', 'reiser4',
                        'ntfs', 'vfat', 'exfat', 'fuseblk',
                        'iso9660', 'udf'
                    }
                    if (mp.is_absolute() and mp.exists() and
                        fstype in storage_fstypes and
                        not str(mp).startswith(('/proc', '/sys', '/dev', '/run', '/var/lib', '/boot', '/efi')) and
                        'tmpfs' not in fstype and 'devtmpfs' not in fstype and
                        'snap' not in str(mp)):
                        r = mp.resolve()
                        if r not in seen:
                            seen.add(r)
                            btn = SidebarButton(f"ðŸ’¾ {r.name or str(r)}", r, self, is_bookmark=False)
                            self.drives_layout.addWidget(btn)
        except Exception as e:
            print(f"Drive scan error: {e}", file=sys.stderr)

    def _setup_shortcuts(self):
        QShortcut(QKeySequence("Escape"), self).activated.connect(self._clear_search)
        QShortcut(QKeySequence("Ctrl+L"), self).activated.connect(lambda: self.address_bar.selectAll() or self.address_bar.setFocus())
        QShortcut(QKeySequence("Ctrl+T"), self).activated.connect(lambda: self._add_new_tab())
        QShortcut(QKeySequence("Ctrl+W"), self).activated.connect(self._close_current_tab)
        QShortcut(QKeySequence("Backspace"), self).activated.connect(self.go_up)
        QShortcut(QKeySequence("Ctrl+H"), self).activated.connect(self.toggle_hidden)
        QShortcut(QKeySequence("Ctrl+R"), self).activated.connect(self.refresh)
        QShortcut(QKeySequence("F5"), self).activated.connect(self.refresh)
        QShortcut(QKeySequence("Ctrl+C"), self).activated.connect(self._copy_paths)
        QShortcut(QKeySequence("Ctrl+X"), self).activated.connect(self._cut_paths)
        QShortcut(QKeySequence("Ctrl+V"), self).activated.connect(self._paste_paths)
        QShortcut(QKeySequence("Delete"), self).activated.connect(self._delete_selected)
        QShortcut(QKeySequence("F2"), self).activated.connect(self._rename_selected)
        QShortcut(QKeySequence("Ctrl+="), self).activated.connect(lambda: self._adjust_zoom(1))
        QShortcut(QKeySequence("Ctrl++"), self).activated.connect(lambda: self._adjust_zoom(1))
        QShortcut(QKeySequence("Ctrl+-"), self).activated.connect(lambda: self._adjust_zoom(-1))
        QShortcut(QKeySequence("Ctrl+Shift+V"), self).activated.connect(self._toggle_view_mode)
        QShortcut(QKeySequence("Ctrl+/"), self).activated.connect(self._show_about)
        QShortcut(QKeySequence("Ctrl+B"), self).activated.connect(self._add_current_to_bookmarks)

    def _toggle_view_mode(self):
        self.view_mode = "icon" if self.view_mode == "list" else "list"
        current_btn = None
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i)
            if isinstance(item, QHBoxLayout):
                for j in range(item.count()):
                    w = item.itemAt(j).widget()
                    if isinstance(w, QPushButton) and w.toolTip() and "View Mode" in w.toolTip():
                        current_btn = w
                        break
        if current_btn:
            current_btn.setText("L" if self.view_mode == "icon" else "V")
        self._populate_files()

    def _adjust_zoom(self, delta: int):
        self.zoom_level = max(14, min(24, self.zoom_level + delta))
        self._update_sidebar_styles()
        current_tab = self.tab_widget.currentWidget()
        if current_tab and self.view_mode == "icon":
            file_list = getattr(current_tab, 'file_list', None)
            if file_list:
                icon_size = 64 + (self.zoom_level - 16) * 2
                file_list.setIconSize(QSize(icon_size, icon_size))
        self._update_status()

    def _update_sidebar_styles(self):
        for layout in [self.bookmarks_layout, self.drives_layout]:
            for i in range(layout.count()):
                item = layout.itemAt(i)
                if item.widget() and isinstance(item.widget(), SidebarButton):
                    item.widget().setStyleSheet(self._get_sidebar_button_style())

    def _center_window(self):
        geo = QApplication.primaryScreen().availableGeometry()
        self.move(geo.center().x() - self.width() // 2, geo.center().y() - self.height() // 2)

    def closeEvent(self, event):
        self.settings.setValue("geometry", self.saveGeometry())
        event.accept()

    # Removed paintEvent to use native window style

    def _navigate_to_tab(self, path: Path):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            current_tab.current_path = path
            self._populate_files_for_tab(current_tab, path)
            self.tab_widget.setTabText(self.tab_widget.currentIndex(), path.name)
            self.address_bar.setText(str(path))
            self._update_breadcrumb()
            self._update_status()

    def navigate_to(self, path: Path):
        try: resolved = path.resolve()
        except Exception as e: self._show_error(f"Invalid path: {e}"); return
        if not resolved.exists(): self._show_error(f"Path does not exist: {resolved}"); return
        if resolved.is_file(): resolved = resolved.parent
        if not resolved.is_dir(): self._show_error("Not a directory"); return
        self._navigate_to_tab(resolved)

    def _on_address_bar_return(self):
        text = self.address_bar.text().strip()
        if text.lower().startswith('search:'):
            self.search_text = text[7:].strip()
            current_tab = self.tab_widget.currentWidget()
            if current_tab:
                self._populate_files_for_tab(current_tab, current_tab.current_path)
        else:
            path = Path(text)
            self.navigate_to(path)

    def _populate_files(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            self._populate_files_for_tab(current_tab, current_tab.current_path)

    def _update_status(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab:
            try:
                path = current_tab.current_path
                all_items = [p for p in path.iterdir() if self.show_hidden or not p.name.startswith('.')]
                file_list = getattr(current_tab, 'file_list')
                shown_items = file_list.count()
                total_size = sum(p.stat().st_size for p in all_items if p.is_file())
                usage = shutil.disk_usage(path)
                free_str = format_size(usage.free)
                self.status_label.setText(f"Zoom: {self.zoom_level} â€¢ Showing {shown_items} of {len(all_items)} items â€¢ Total: {format_size(total_size)} â€¢ Free: {free_str}")
            except Exception as e:
                self.status_label.setText(f"Zoom: {self.zoom_level} â€¢ Error: {e}")
        else:
            self.status_label.setText(f"Zoom: {self.zoom_level} â€¢ No active tab")

    def _show_error(self, msg: str):
        QMessageBox.warning(self, "Error", msg)

    def refresh(self):
        global THUMBNAIL_CACHE
        THUMBNAIL_CACHE.clear()
        self._populate_files()
        self._update_status()

    def go_up(self):
        current_tab = self.tab_widget.currentWidget()
        if current_tab and hasattr(current_tab, 'current_path'):
            parent = current_tab.current_path.parent
            if parent != current_tab.current_path:
                self._navigate_to_tab(parent)

    def toggle_hidden(self):
        self.show_hidden = not self.show_hidden
        self._populate_files()
        self._update_status()

    def _clear_search(self):
        self.search_text = ''
        self.address_bar.clear()
        self._populate_files()
        self._update_status()

    def _on_item_double_clicked(self, item: FileItem):
        path = item.path
        if path.is_dir():
            self.navigate_to(path)
        else:
            QDesktopServices.openUrl(QUrl.fromLocalFile(str(path)))

    def _on_list_context_menu(self, position):
        sender = self.sender()
        current_tab = self.tab_widget.currentWidget()
        if not current_tab: return
        file_list = getattr(current_tab, 'file_list')
        item = file_list.itemAt(position)
        if item:
            self._show_context_menu(item, file_list.mapToGlobal(position))
        else:
            menu = QMenu(self)
            menu.setStyleSheet(self._get_menu_style())
            new_file_action = QAction("ðŸ“„ New File", self)
            new_file_action.triggered.connect(self._create_new_file)
            menu.addAction(new_file_action)
            new_folder_action = QAction("ðŸ“ New Folder", self)
            new_folder_action.triggered.connect(self._create_new_folder)
            menu.addAction(new_folder_action)
            menu.addSeparator()
            add_bookmark_action = QAction("ðŸ“Œ Add to Bookmarks", self)
            add_bookmark_action.triggered.connect(self._add_current_to_bookmarks)
            menu.addAction(add_bookmark_action)
            menu.addSeparator()
            paste_action = QAction("ðŸ“‹ Paste", self)
            paste_action.setEnabled(bool(CLIPBOARD_PATHS))
            paste_action.triggered.connect(self._paste_paths)
            menu.addAction(paste_action)
            menu.addSeparator()
            about_action = QAction("â„¹ï¸ About / Shortcuts", self)
            about_action.triggered.connect(self._show_about)
            menu.addAction(about_action)
            menu.exec_(file_list.mapToGlobal(position))

    def _show_context_menu(self, item: FileItem, global_pos: 'QPoint'):
        menu = QMenu(self)
        menu.setStyleSheet(self._get_menu_style())
        path = item.path
        is_dir = path.is_dir()

        open_action = QAction("ðŸš€ Open", self)
        open_action.triggered.connect(lambda: self.navigate_to(path) if is_dir else QDesktopServices.openUrl(QUrl.fromLocalFile(str(path))))
        menu.addAction(open_action)

        if not is_dir:
            open_with_menu = self._build_open_with_menu(path)
            if open_with_menu.actions():
                menu.addMenu(open_with_menu)
        menu.addSeparator()

        if is_dir:
            path_str = str(path)
            if path_str in self.custom_bookmarks:
                remove_bookmark_action = QAction("ðŸ“Œ Remove from Bookmarks", self)
                remove_bookmark_action.triggered.connect(lambda: self._remove_from_bookmarks(path))
                menu.addAction(remove_bookmark_action)
            else:
                add_bookmark_action = QAction("ðŸ“Œ Add to Bookmarks", self)
                add_bookmark_action.triggered.connect(lambda: self._add_folder_to_bookmarks(path))
                menu.addAction(add_bookmark_action)
            menu.addSeparator()

        copy_action = QAction("ðŸ“‹ Copy", self)
        copy_action.triggered.connect(self._copy_paths)
        menu.addAction(copy_action)
        cut_action = QAction("âœ‚ï¸ Cut", self)
        cut_action.triggered.connect(self._cut_paths)
        menu.addAction(cut_action)
        paste_action = QAction("ðŸ“‹ Paste", self)
        paste_action.setEnabled(bool(CLIPBOARD_PATHS))
        paste_action.triggered.connect(self._paste_paths)
        menu.addAction(paste_action)
        menu.addSeparator()

        rename_action = QAction("âœï¸ Rename", self)
        rename_action.triggered.connect(lambda: self._rename_path(path))
        menu.addAction(rename_action)

        if not is_dir:
            is_executable = os.access(path, os.X_OK)
            if is_executable:
                exec_action = QAction("ðŸš« Remove Executable", self)
                exec_action.triggered.connect(lambda: self._make_non_executable(path))
            else:
                exec_action = QAction("âš¡ Make Executable", self)
                exec_action.triggered.connect(lambda: self._make_executable(path))
            menu.addAction(exec_action)

        delete_action = QAction("ðŸ—‘ï¸ Delete to Trash", self)
        delete_action.triggered.connect(lambda: self._delete_path(path, to_trash=True))
        menu.addAction(delete_action)
        delete_permanent_action = QAction("ðŸ”¥ Delete Permanently", self)
        delete_permanent_action.triggered.connect(lambda: self._delete_path(path, to_trash=False))
        menu.addAction(delete_permanent_action)
        menu.addSeparator()

        copy_path_action = QAction("ðŸ“‹ Copy Path", self)
        copy_path_action.triggered.connect(lambda: QApplication.clipboard().setText(str(path)))
        menu.addAction(copy_path_action)
        properties_action = QAction("ðŸ“Š Properties", self)
        properties_action.triggered.connect(lambda: self._show_properties(path))
        menu.addAction(properties_action)
        menu.addSeparator()

        if is_dir:
            open_new_window_action = QAction("ðŸŒ Open in New Window", self)
            open_new_window_action.triggered.connect(lambda: self._open_in_new_window(path))
            menu.addAction(open_new_window_action)

            # Terminal and Root options for all folders
            open_terminal_as_root_action = QAction("ðŸ”’ Open as Root in Terminal", self)
            open_terminal_as_root_action.triggered.connect(lambda: self._open_terminal_as_root_in_path(path))
            menu.addAction(open_terminal_as_root_action)

            open_as_root = QAction("ðŸ”’ Open as Root", self)
            open_as_root.triggered.connect(lambda: self._open_as_root(path))
            menu.addAction(open_as_root)

            terminal_menu = self._build_terminal_menu(path)
            if terminal_menu.actions():
                menu.addMenu(terminal_menu)
            fm_menu = self._build_file_manager_menu(path)
            if fm_menu.actions():
                menu.addMenu(fm_menu)
        else:
            # For files, add option to open parent folder as root
            open_parent_as_root = QAction("ðŸ”’ Open Parent as Root", self)
            open_parent_as_root.triggered.connect(lambda: self._open_as_root(path.parent))
            menu.addAction(open_parent_as_root)

            reveal_action = QAction("ðŸ“‚ Reveal in File Manager", self)
            reveal_action.triggered.connect(lambda: self._reveal_in_file_manager(path))
            menu.addAction(reveal_action)

        menu.exec_(global_pos)

    def _add_folder_to_bookmarks(self, path: Path):
        path_str = str(path)
        if path_str in self.custom_bookmarks:
            QMessageBox.information(self, "Already Bookmarked", f"'{path.name}' is already in your bookmarks.")
            return
        self.custom_bookmarks.append(path_str)
        self.settings.setValue("customBookmarks", self.custom_bookmarks)
        self._populate_bookmarks()
        QMessageBox.information(self, "Bookmark Added", f"Added '{path.name}' to bookmarks.")

    def _open_in_new_window(self, path: Path):
        try:
            subprocess.Popen([sys.executable, __file__, str(path)])
        except Exception as e:
            self._show_error(f"Failed to open new window:\n{e}")

    def _make_executable(self, path: Path):
        if not path.is_file(): return
        try:
            current_mode = path.stat().st_mode
            path.chmod(current_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
            self._update_status()
        except PermissionError:
            self._show_error(f"Permission denied: cannot modify {path.name}")
        except Exception as e:
            self._show_error(f"Failed to make executable:\n{e}")

    def _make_non_executable(self, path: Path):
        if not path.is_file(): return
        try:
            current_mode = path.stat().st_mode
            new_mode = current_mode & ~(stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
            path.chmod(new_mode)
            self._update_status()
        except PermissionError:
            self._show_error(f"Permission denied: cannot modify {path.name}")
        except Exception as e:
            self._show_error(f"Failed to remove executable permission:\n{e}")

    def _open_terminal_in_path(self, path: Path, terminal_cmd: str = None):
        """Opens a terminal in the specified path."""
        cmd = terminal_cmd or os.environ.get('TERMINAL', 'xterm') # Fallback to $TERMINAL or xterm
        try:
            if cmd in ('gnome-terminal', 'xfce4-terminal'):
                subprocess.Popen([cmd, '--working-directory', str(path)], start_new_session=True)
            elif cmd == 'konsole':
                subprocess.Popen([cmd, '--workdir', str(path)], start_new_session=True)
            else:
                # Default behavior for most terminals
                subprocess.Popen([cmd, '-e', f'bash -c "cd \\"{path}\\" && exec bash"'], start_new_session=True)
        except FileNotFoundError:
            self._show_error(f"Terminal '{cmd}' not found.")
        except Exception as e:
            self._show_error(f"Failed to open terminal:\n{e}")

    def _open_terminal_as_root_in_path(self, path: Path):
        """Attempts to open a terminal as root in the specified path."""
        # Find available terminals first
        available_terminals = []
        for term in TERMINALS:
            if shutil.which(term):
                available_terminals.append(term)
        
        if not available_terminals:
            self._show_error("No terminal emulator found. Please install a terminal like xterm, gnome-terminal, or konsole.")
            return
            
        # Define methods in order of preference for root terminal access
        root_terminal_methods = []
        
        # Add methods for each available terminal
        for term in available_terminals:
            if term == 'xterm':
                # Try with sudo and X11 forwarding
                root_terminal_methods.append(['sudo', 'env', 'DISPLAY=$DISPLAY', 'XAUTHORITY=$XAUTHORITY', 'xterm', '-e', f'bash -c "cd \\"{path}\\" && exec bash"'])
                # Keep pkexec as fallback
                root_terminal_methods.append(['pkexec', 'xterm', '-e', f'bash -c "cd \\"{path}\\" && exec bash"'])
            elif term == 'gnome-terminal':
                root_terminal_methods.append(['sudo', 'env', 'DISPLAY=$DISPLAY', 'XAUTHORITY=$XAUTHORITY', 'gnome-terminal', '--working-directory', str(path)])
                root_terminal_methods.append(['pkexec', 'gnome-terminal', '--working-directory', str(path)])
            elif term == 'xfce4-terminal':
                root_terminal_methods.append(['sudo', 'env', 'DISPLAY=$DISPLAY', 'XAUTHORITY=$XAUTHORITY', 'xfce4-terminal', '--working-directory', str(path)])
                root_terminal_methods.append(['pkexec', 'xfce4-terminal', '--working-directory', str(path)])
            elif term == 'konsole':
                root_terminal_methods.append(['sudo', 'env', 'DISPLAY=$DISPLAY', 'XAUTHORITY=$XAUTHORITY', 'konsole', '--workdir', str(path)])
                root_terminal_methods.append(['pkexec', 'konsole', '--workdir', str(path)])
            elif term == 'kitty':
                root_terminal_methods.append(['sudo', 'env', 'DISPLAY=$DISPLAY', 'XAUTHORITY=$XAUTHORITY', 'kitty', '--directory', str(path)])
                root_terminal_methods.append(['pkexec', 'kitty', '--directory', str(path)])
            elif term == 'alacritty':
                root_terminal_methods.append(['sudo', 'env', 'DISPLAY=$DISPLAY', 'XAUTHORITY=$XAUTHORITY', 'alacritty', '--working-directory', str(path)])
                root_terminal_methods.append(['pkexec', 'alacritty', '--working-directory', str(path)])
        
        # Add fallback methods with gksudo/kdesudo if available
        if shutil.which('gksudo'):
            for term in available_terminals[:3]:  # Limit to top 3 terminals
                if term == 'xterm':
                    root_terminal_methods.append(['gksudo', 'xterm', '-e', f'bash -c "cd \\"{path}\\" && exec bash"'])
                elif term == 'gnome-terminal':
                    root_terminal_methods.append(['gksudo', 'gnome-terminal', '--working-directory', str(path)])
                elif term == 'konsole':
                    root_terminal_methods.append(['gksudo', 'konsole', '--workdir', str(path)])
        
        if shutil.which('kdesudo'):
            for term in available_terminals[:3]:  # Limit to top 3 terminals
                if term == 'xterm':
                    root_terminal_methods.append(['kdesudo', 'xterm', '-e', f'bash -c "cd \\"{path}\\" && exec bash"'])
                elif term == 'gnome-terminal':
                    root_terminal_methods.append(['kdesudo', 'gnome-terminal', '--working-directory', str(path)])
                elif term == 'konsole':
                    root_terminal_methods.append(['kdesudo', 'konsole', '--workdir', str(path)])

        # Try each method until one works
        for method in root_terminal_methods:
            try:
                print(f"Attempting root terminal with: {' '.join(method)}") # Debug print
                
                # If using sudo, expand environment variables
                if method[0] == 'sudo' and 'env' in method:
                    # Replace environment variables with actual values
                    new_method = []
                    for item in method:
                        if item == 'DISPLAY=$DISPLAY':
                            new_method.append(f'DISPLAY={os.environ.get("DISPLAY", ":0")}')
                        elif item == 'XAUTHORITY=$XAUTHORITY':
                            new_method.append(f'XAUTHORITY={os.environ.get("XAUTHORITY", "")}')
                        else:
                            new_method.append(item)
                    method = new_method
                
                subprocess.Popen(method, start_new_session=True)
                return
            except Exception as e:
                print(f"Failed with method [{' '.join(method)}]: {e}") # Debug print
                continue

        self._show_error(
            "No suitable method found to open a root terminal.\n"
            "Please ensure 'sudo', 'pkexec', 'gksudo', or 'kdesudo' is installed,\n"
            "or configure a root-capable terminal."
        )

    def _create_new_file(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab or not hasattr(current_tab, 'current_path'): return
        name, ok = QInputDialog.getText(self, "New File", "File name:")
        if ok and name:
            new_path = current_tab.current_path / name
            try:
                subprocess.run(['touch', str(new_path)], check=True)
                self.refresh()
            except subprocess.CalledProcessError:
                try:
                    new_path.touch()
                    self.refresh()
                except Exception as e:
                    self._show_error(f"Could not create file: {e}")
            except Exception as e:
                self._show_error(f"Could not create file: {e}")

    def _build_open_with_menu(self, path: Path) -> QMenu:
        menu = QMenu("Open With", self)
        mime_db = QMimeDatabase()
        mime_type = mime_db.mimeTypeForFile(str(path)).name()
        default_app = self._get_default_app(mime_type)
        if default_app:
            action = QAction(f"ðŸŽ¯ Default ({default_app})", self)
            action.triggered.connect(lambda: self._launch_app(default_app, path))
            menu.addAction(action)
            menu.addSeparator()
        apps = self._get_apps_for_mime(mime_type)
        for name, cmd in apps[:8]:
            action = QAction(name, self)
            action.triggered.connect(lambda _, c=cmd: self._launch_app(c, path))
            menu.addAction(action)
        if not menu.actions():
            no_app = QAction("âŒ No applications found", self)
            no_app.setEnabled(False)
            menu.addAction(no_app)
        return menu

    def _build_terminal_menu(self, path: Path) -> QMenu:
        menu = QMenu("ðŸ’» Open in Terminal", self)
        for term in TERMINALS:
            if shutil.which(term):
                action = QAction(term.capitalize(), self)
                action.triggered.connect(lambda _, t=term: self._open_terminal_in(path, t))
                menu.addAction(action)
        return menu

    def _build_file_manager_menu(self, path: Path) -> QMenu:
        menu = QMenu("ðŸ“ Open in File Manager", self)
        for name, cmd in FILE_MANAGERS.items():
            if shutil.which(cmd):
                action = QAction(name, self)
                action.triggered.connect(lambda _, c=cmd: self._open_in_file_manager(path, c))
                menu.addAction(action)
        return menu

    def _get_default_app(self, mime_type: str) -> Optional[str]:
        try:
            result = subprocess.run(['xdg-mime', 'query', 'default', mime_type], capture_output=True, text=True, timeout=2)
            if result.returncode == 0 and result.stdout.strip():
                desktop_file = result.stdout.strip()
                return desktop_file.replace('.desktop', '').replace('-', ' ').title()
        except Exception: pass
        return None

    def _get_apps_for_mime(self, mime_type: str) -> List[tuple]:
        apps = []
        try:
            for apps_dir in [Path('~/.local/share/applications').expanduser(), Path('/usr/share/applications')]:
                if not apps_dir.exists(): continue
                for desktop in apps_dir.glob('*.desktop'):
                    try:
                        with open(desktop, 'r', errors='ignore') as f: content = f.read()
                        if mime_type in content or 'Exec=' in content:
                            name = desktop.stem.replace('-', ' ').title()
                            apps.append((name, desktop.name))
                    except Exception: continue
        except Exception: pass
        return apps

    def _launch_app(self, desktop_file: str, path: Path):
        try:
            subprocess.Popen(['gtk-launch', desktop_file, str(path)], start_new_session=True)
        except Exception as e:
            QMessageBox.warning(self, "Launch Failed", f"Could not launch application:\n{e}")

    def _open_terminal_in(self, path: Path, terminal: str):
        try:
            if terminal in ('gnome-terminal', 'xfce4-terminal'):
                subprocess.Popen([terminal, '--working-directory', str(path)], start_new_session=True)
            elif terminal == 'konsole':
                subprocess.Popen([terminal, '--workdir', str(path)], start_new_session=True)
            else:
                subprocess.Popen([terminal, '-e', f'bash -c "cd \\"{path}\\" && exec bash"'], start_new_session=True)
        except Exception as e:
            self._show_error(f"Failed to open {terminal}:\n{e}")

    def _open_in_file_manager(self, path: Path, fm_cmd: str):
        try:
            subprocess.Popen([fm_cmd, str(path)], start_new_session=True)
        except Exception as e:
            self._show_error(f"Failed to open {fm_cmd}:\n{e}")

    def _reveal_in_file_manager(self, file_path: Path):
        try:
            subprocess.Popen(['xdg-open', str(file_path.parent)], start_new_session=True)
        except Exception as e:
            self._show_error(f"Could not reveal file:\n{e}")

    def _open_as_root(self, path: Path):
        for method in (['pkexec', 'thunar'], ['gksudo', 'thunar'], ['sudo', '-E', 'thunar']):
            if shutil.which(method[0]):
                try:
                    subprocess.Popen(method + [str(path)], start_new_session=True)
                    return
                except Exception:
                    continue
        self._show_error("No graphical sudo method available.\nInstall PolicyKit (pkexec).")

    def _show_properties(self, path: Path):
        try:
            stat_info = path.stat()
            size = path.stat().st_size if path.is_file() else sum(f.stat().st_size for f in path.rglob('*') if f.is_file())
            msg = f"""
            <b>Properties for:</b> {path.name}<br>
            <b>Path:</b> {path}<br>
            <b>Type:</b> {'Directory' if path.is_dir() else 'File'}<br>
            <b>Size:</b> {format_size(size)}<br>
            <b>Permissions:</b> {get_permissions_str(path)}<br>
            <b>Modified:</b> {get_modified_str(path)}<br>
            <b>MIME Type:</b> {mimetypes.guess_type(str(path))[0] or 'Unknown'}
            """
            QMessageBox.information(self, "Properties", msg)
        except Exception as e:
            self._show_error(f"Could not get properties: {e}")

    def _create_new_folder(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab or not hasattr(current_tab, 'current_path'): return
        name, ok = QInputDialog.getText(self, "New Folder", "Folder name:")
        if ok and name:
            new_path = current_tab.current_path / name
            try:
                new_path.mkdir(parents=True, exist_ok=True)
                self.refresh()
            except Exception as e:
                self._show_error(f"Could not create folder: {e}")

    def _rename_path(self, path: Path):
        old_name = path.name
        new_name, ok = QInputDialog.getText(self, "Rename", "New name:", text=old_name)
        if ok and new_name and new_name != old_name:
            new_path = path.parent / new_name
            try:
                path.rename(new_path)
                self.refresh()
            except Exception as e:
                self._show_error(f"Could not rename: {e}")

    def _delete_path(self, path: Path, to_trash=True):
        if to_trash:
            reply = QMessageBox.question(self, "Confirm Delete", f"Move '{path.name}' to trash?", QMessageBox.Yes | QMessageBox.No)
        else:
            reply = QMessageBox.question(self, "Confirm Permanent Delete", f"Permanently delete '{path.name}'? This cannot be undone!", QMessageBox.Yes | QMessageBox.No)
        if reply == QMessageBox.Yes:
            try:
                if to_trash:
                    try:
                        subprocess.run(['gio', 'trash', str(path)], check=True, capture_output=True)
                    except (subprocess.CalledProcessError, FileNotFoundError):
                        from send2trash import send2trash
                        send2trash(str(path))
                else:
                    if path.is_dir():
                        shutil.rmtree(path)
                    else:
                        path.unlink()
                self.refresh()
            except Exception as e:
                self._show_error(f"Could not delete: {e}")

    def _copy_paths(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab: return
        file_list = getattr(current_tab, 'file_list')
        global CLIPBOARD_PATHS, CLIPBOARD_IS_CUT
        CLIPBOARD_PATHS = [item.path for item in file_list.selectedItems()]
        CLIPBOARD_IS_CUT = False
        self._update_status()

    def _cut_paths(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab: return
        file_list = getattr(current_tab, 'file_list')
        global CLIPBOARD_PATHS, CLIPBOARD_IS_CUT
        CLIPBOARD_PATHS = [item.path for item in file_list.selectedItems()]
        CLIPBOARD_IS_CUT = True
        self._update_status()

    def _paste_paths(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab or not hasattr(current_tab, 'current_path'): return
        global CLIPBOARD_PATHS, CLIPBOARD_IS_CUT
        if not CLIPBOARD_PATHS: return
        errors = []
        for src_path in CLIPBOARD_PATHS:
            dest_path = current_tab.current_path / src_path.name
            try:
                if CLIPBOARD_IS_CUT:
                    src_path.rename(dest_path)
                else:
                    if src_path.is_dir():
                        shutil.copytree(src_path, dest_path)
                    else:
                        shutil.copy2(src_path, dest_path)
            except Exception as e:
                errors.append(f"{src_path.name}: {e}")
        CLIPBOARD_PATHS = []
        CLIPBOARD_IS_CUT = False
        self.refresh()
        if errors:
            self._show_error("\n".join(errors))

    def _delete_selected(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab: return
        file_list = getattr(current_tab, 'file_list')
        items = file_list.selectedItems()
        if not items: return
        paths = [item.path for item in items]
        names = [p.name for p in paths]
        reply = QMessageBox.question(self, "Confirm Delete", f"Permanently delete {len(names)} item(s)?\n{', '.join(names[:3])}{'...' if len(names) > 3 else ''}", QMessageBox.Yes | QMessageBox.No)
        if reply == QMessageBox.Yes:
            errors = []
            for p in paths:
                try:
                    if p.is_dir():
                        shutil.rmtree(p)
                    else:
                        p.unlink()
                except Exception as e:
                    errors.append(f"{p.name}: {e}")
            self.refresh()
            if errors:
                self._show_error("\n".join(errors))

    def _rename_selected(self):
        current_tab = self.tab_widget.currentWidget()
        if not current_tab: return
        file_list = getattr(current_tab, 'file_list')
        items = file_list.selectedItems()
        if len(items) == 1:
            self._rename_path(items[0].path)

    def _close_current_tab(self):
        if self.tab_widget.count() > 1:
            current_index = self.tab_widget.currentIndex()
            self.tab_widget.removeTab(current_index)
        else:
            self._show_error("Cannot close the last tab")

    def _get_menu_style(self) -> str:
        return f"""
            QMenu {{
                background-color: {COLORS['surface']};
                color: {COLORS['text_primary']};
                border: 1px solid {COLORS['border']};
                padding: 6px;
                font-size: 13px;
            }}
            QMenu::item {{
                padding: 6px 24px;
            }}
            QMenu::item:selected {{
                background-color: {COLORS['highlight']};
                color: white;
            }}
            QMenu::separator {{
                height: 1px;
                background: {COLORS['border']};
                margin: 6px 0px;
            }}
        """

    def _toggle_navigation_bar(self):
        self.show_breadcrumb = not self.show_breadcrumb
        self.address_bar.setVisible(not self.show_breadcrumb)
        self.breadcrumb_widget.setVisible(self.show_breadcrumb)
        if self.show_breadcrumb:
            self._update_breadcrumb()

    def _update_breadcrumb(self):
        while self.breadcrumb_layout.count():
            child = self.breadcrumb_layout.takeAt(0)
            if child.widget():
                child.widget().deleteLater()
        current_tab = self.tab_widget.currentWidget()
        if not current_tab or not hasattr(current_tab, 'current_path'): return
        path_to_navigate = current_tab.current_path
        parts = []
        current = path_to_navigate
        while current != current.parent:
            parts.insert(0, current)
            current = current.parent
        if current.parts:
            parts.insert(0, current)
        for i, part in enumerate(parts):
            btn = QToolButton()
            btn.setText(part.name if part.name else "/")
            btn.setStyleSheet(f"""
                QToolButton {{
                    background: transparent;
                    color: {COLORS['text_primary']};
                    border: none;
                    padding: 4px 8px;
                    font-size: 13px;
                }}
                QToolButton:hover {{
                    background: {COLORS['highlight']};
                    color: white;
                }}
            """)
            btn.clicked.connect(lambda _, p=part: self._navigate_to_tab(p))
            self.breadcrumb_layout.addWidget(btn)
            if i < len(parts) - 1:
                sep = QLabel(" > ")
                sep.setStyleSheet(f"color: {COLORS['text_secondary']}; font-size: 13px;")
                self.breadcrumb_layout.addWidget(sep)

    def _sidebar_context_menu(self, path: Path, global_pos: 'QPoint', is_bookmark: bool):
        menu = QMenu(self)
        menu.setStyleSheet(self._get_menu_style())
        open_action = QAction("ðŸš€ Open", self)
        open_action.triggered.connect(lambda: self._navigate_to_tab(path))
        menu.addAction(open_action)
        open_new_tab_action = QAction("âž• Open in New Tab", self)
        open_new_tab_action.triggered.connect(lambda: self._add_new_tab(path))
        menu.addAction(open_new_tab_action)
        open_new_window_action = QAction("ðŸŒ Open in New Window", self)
        open_new_window_action.triggered.connect(lambda: self._open_in_new_window(path))
        menu.addAction(open_new_window_action)
        menu.addSeparator()

        if is_bookmark:
            move_up_action = QAction("â¬†ï¸ Move Up", self)
            move_up_action.triggered.connect(lambda: self._move_bookmark_up(path))
            menu.addAction(move_up_action)
            move_down_action = QAction("â¬‡ï¸ Move Down", self)
            move_down_action.triggered.connect(lambda: self._move_bookmark_down(path))
            menu.addAction(move_down_action)
            remove_bookmark_action = QAction("ðŸ“Œ Remove from Bookmarks", self)
            remove_bookmark_action.triggered.connect(lambda: self._remove_from_bookmarks(path))
            menu.addAction(remove_bookmark_action)
        else:
            add_bookmark_action = QAction("ðŸ“Œ Add to Bookmarks", self)
            add_bookmark_action.triggered.connect(lambda: self._add_folder_to_bookmarks(path))
            menu.addAction(add_bookmark_action)

        menu.addSeparator()
        
        # Terminal and Root options for all folders in sidebar
        open_terminal_as_root_action = QAction("ðŸ”’ Open as Root in Terminal", self)
        open_terminal_as_root_action.triggered.connect(lambda: self._open_terminal_as_root_in_path(path))
        menu.addAction(open_terminal_as_root_action)

        open_as_root = QAction("ðŸ”’ Open as Root", self)
        open_as_root.triggered.connect(lambda: self._open_as_root(path))
        menu.addAction(open_as_root)
        
        terminal_menu = self._build_terminal_menu(path)
        if terminal_menu.actions():
            menu.addMenu(terminal_menu)
            
        reveal_action = QAction("ðŸ“‚ Reveal in File Manager", self)
        reveal_action.triggered.connect(lambda: self._reveal_in_file_manager(path))
        menu.addAction(reveal_action)
        properties_action = QAction("ðŸ“Š Properties", self)
        properties_action.triggered.connect(lambda: self._show_properties(path))
        menu.addAction(properties_action)
        menu.exec_(global_pos)

    def _handle_file_list_drop(self, event: QDropEvent, file_list: FileListWidget):
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            tab_container = None
            for i in range(self.tab_widget.count()):
                potential_tab = self.tab_widget.widget(i)
                if hasattr(potential_tab, 'file_list') and potential_tab.file_list == file_list:
                    tab_container = potential_tab
                    break
            if not tab_container or not hasattr(tab_container, 'current_path'):
                event.ignore()
                return
            dest_path = tab_container.current_path
            errors = []
            for url in urls:
                if url.isLocalFile():
                    source_path = Path(url.toLocalFile())
                    try:
                        modifiers = event.keyboardModifiers()
                        if modifiers & Qt.ControlModifier:
                            if source_path.is_dir():
                                shutil.copytree(source_path, dest_path / source_path.name)
                            else:
                                shutil.copy2(source_path, dest_path)
                        else:
                            source_path.rename(dest_path / source_path.name)
                    except Exception as e:
                        errors.append(f"Failed to drop {source_path.name}: {e}")
            if errors:
                self._show_error("\n".join(errors))
            self._populate_files_for_tab(tab_container, dest_path)
            self._update_status()
            event.acceptProposedAction()
        else:
            event.ignore()

    def _handle_sidebar_drop(self, event: QDropEvent, button: SidebarButton, target_path: Path):
        if event.mimeData().hasUrls():
            urls = event.mimeData().urls()
            errors = []
            for url in urls:
                if url.isLocalFile():
                    source_path = Path(url.toLocalFile())
                    try:
                        modifiers = event.keyboardModifiers()
                        if modifiers & Qt.ControlModifier:
                            if source_path.is_dir():
                                shutil.copytree(source_path, target_path / source_path.name)
                            else:
                                shutil.copy2(source_path, target_path)
                        else:
                            source_path.rename(target_path / source_path.name)
                    except Exception as e:
                        errors.append(f"Failed to drop {source_path.name} into {target_path.name}: {e}")
            if errors:
                self._show_error("\n".join(errors))
            self.refresh()
            event.acceptProposedAction()
        else:
            event.ignore()

    def _show_about(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("About / Shortcuts")
        dialog.setModal(True)
        dialog.resize(600, 500)
        layout = QVBoxLayout(dialog)
        browser = QTextBrowser()
        browser.setOpenExternalLinks(True)
        browser.setStyleSheet(f"""
            QTextBrowser {{
                background: {COLORS['surface']};
                color: {COLORS['text_primary']};
                border: 1px solid {COLORS['border']};
                border-radius: 6px;
                padding: 12px;
                font-family: 'Sans';
                font-size: 13px;
            }}
        """)
        shortcuts_html = """
        <h2>Modern File Manager â€“ Nemo Style</h2>
        <p>A clean, minimal, and feature-rich file browser for Linux.</p>
        <h3>Keyboard Shortcuts</h3>
        <table border="0" cellspacing="4" cellpadding="4">
        <tr><td><b>Ctrl+L</b></td><td>Focus address bar</td></tr>
        <tr><td><b>Ctrl+T</b></td><td>New tab</td></tr>
        <tr><td><b>Ctrl+W</b></td><td>Close tab</td></tr>
        <tr><td><b>Ctrl+H</b></td><td>Toggle hidden files</td></tr>
        <tr><td><b>F5 / Ctrl+R</b></td><td>Refresh</td></tr>
        <tr><td><b>Backspace</b></td><td>Go up</td></tr>
        <tr><td><b>Ctrl+C</b></td><td>Copy</td></tr>
        <tr><td><b>Ctrl+X</b></td><td>Cut</td></tr>
        <tr><td><b>Ctrl+V</b></td><td>Paste</td></tr>
        <tr><td><b>Delete</b></td><td>Delete permanently</td></tr>
        <tr><td><b>F2</b></td><td>Rename</td></tr>
        <tr><td><b>Ctrl+Shift+V</b></td><td>Toggle view mode</td></tr>
        <tr><td><b>Ctrl+= / Ctrl++</b></td><td>Zoom in</td></tr>
        <tr><td><b>Ctrl+-</b></td><td>Zoom out</td></tr>
        <tr><td><b>Ctrl+B</b></td><td>Add current folder to bookmarks</td></tr>
        <tr><td><b>Ctrl+/</b></td><td>Show this window</td></tr>
        <tr><td><b>Escape</b></td><td>Clear search</td></tr>
        </table>
        <h3>Bookmark Features</h3>
        <ul>
        <li>Click the <b>+</b> button in sidebar to add current folder</li>
        <li>Right-click any folder to add/remove from bookmarks</li>
        <li>Right-click bookmarks to move them up/down or remove</li>
        </ul>
        <p style="margin-top: 20px; color: #bbbbbb;">
        Built with PyQt5. Inspired by Nemo.
        </p>
        """
        browser.setHtml(shortcuts_html)
        layout.addWidget(browser)
        close_btn = QPushButton("Close")
        close_btn.setStyleSheet(self._get_large_button_style())
        close_btn.clicked.connect(dialog.accept)
        layout.addWidget(close_btn)
        dialog.exec_()

# =============================================================================
# MAIN
# =============================================================================
def main():
    app = QApplication(sys.argv)
    app.setQuitOnLastWindowClosed(True)
    app.setStyle("Fusion")

    font = QFont()
    app.setFont(font)

    palette = QPalette()
    palette.setColor(QPalette.Window, QColor(COLORS["background"]))
    palette.setColor(QPalette.WindowText, QColor(COLORS["text_primary"]))
    palette.setColor(QPalette.Base, QColor(COLORS["surface"]))
    palette.setColor(QPalette.AlternateBase, QColor(COLORS["background"]))
    palette.setColor(QPalette.ToolTipBase, QColor(COLORS["surface"]))
    palette.setColor(QPalette.ToolTipText, QColor(COLORS["text_primary"]))
    palette.setColor(QPalette.Text, QColor(COLORS["text_primary"]))
    palette.setColor(QPalette.Button, QColor(COLORS["surface"]))
    palette.setColor(QPalette.ButtonText, QColor(COLORS["text_primary"]))
    palette.setColor(QPalette.BrightText, QColor(COLORS["danger"]))
    palette.setColor(QPalette.Highlight, QColor(COLORS["accent"]))
    palette.setColor(QPalette.HighlightedText, QColor("white"))
    app.setPalette(palette)

    initial_path = Path.home().resolve()
    if len(sys.argv) > 1:
        try:
            arg_path = Path(sys.argv[1]).resolve()
            if arg_path.is_dir():
                initial_path = arg_path
        except Exception as e:
            print(f"Error processing argument: {e}. Using home directory.", file=sys.stderr)

    fm = FileManager()
    fm.navigate_to(initial_path)
    fm.show()
    fm.raise_()
    fm.activateWindow()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()