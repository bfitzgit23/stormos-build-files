#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
StormOS / Arch Easy Installer — PyQt5 (UEFI + BIOS) — No-Freeze Edition
FULL SINGLE-FILE CODE (Midnight Theme + Accent Colors)

NEW:
✅ Desktop Environment dropdown:
   - XFCE (LightDM)
   - GNOME (GDM)
   - KDE Plasma (SDDM)
   - Cinnamon (LightDM)
   - MATE (LightDM)
   - LXQt (SDDM)

Still includes:
✅ Multi-drive disk picker + refresh
✅ Install mode:
- ERASE DISK (auto partitioning) — destructive
- USE EXISTING PARTITIONS — pick root (+ EFI if UEFI), optional formatting
✅ Smart confirmation words:
- ERASE mode -> type ERASE
- Existing partitions + any formatting -> type FORMAT
- Existing partitions no formatting -> type INSTALL
✅ 14" friendly (scroll pages)
✅ Wi-Fi status display
✅ Multilib enablement (live + target)
✅ Packages list from local /etc/stormos/packages.txt or GitHub fallback (optional)
✅ Install extra .pkg.tar.zst packages from GitHub (optional; internet required)
✅ Host wallpaper copied into installed system at:
   /usr/share/backgrounds/xfce/xfce-x.<ext>
   (kept for compatibility even if you choose a different DE)
✅ LightDM greeter background + theme/icon when LightDM is the chosen DM
✅ XFCE wallpaper + icon theme patch into /etc/skel (only meaningful for XFCE)
✅ yay best-effort
✅ Remove calamares.desktop from Desktop (best-effort)
✅ Remove temporary build user 'aurbuilder' (best-effort)

Run:
  sudo python3 stormos_easy_installer.py
"""
import os
import re
import sys
import shlex
import time
import shutil
import socket
import subprocess
import urllib.request
import urllib.error
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Tuple, Callable

from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer, QUrl
from PyQt5.QtGui import QFont, QDesktopServices
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLabel, QLineEdit, QPushButton, QComboBox, QStackedWidget, QMessageBox,
    QPlainTextEdit, QProgressBar, QCheckBox, QGroupBox, QTextEdit, QScrollArea
)

# ============================================================
# Midnight theme palette + app-wide stylesheet
# ============================================================
MIDNIGHT_QSS = r"""
QWidget {
    background: #0b1020;
    color: #e7e9ff;
    font-family: "Sans";
    font-size: 11pt;
}
QMainWindow { background: #0b1020; }
QToolTip {
    background: #111a2e;
    color: #e7e9ff;
    border: 1px solid #2a3760;
    padding: 6px;
    border-radius: 8px;
}
QScrollArea, QStackedWidget { background: #0b1020; border: none; }
QGroupBox {
    background: #0f1730;
    border: 1px solid #2a3760;
    border-radius: 14px;
    margin-top: 12px;
    padding: 12px;
}
QGroupBox::title {
    subcontrol-origin: margin;
    left: 12px;
    padding: 0 8px;
    color: #b8c2ff;
    font-weight: 700;
}
QLineEdit, QComboBox, QTextEdit, QPlainTextEdit {
    background: #101a34;
    border: 1px solid #2a3760;
    border-radius: 12px;
    padding: 8px 10px;
    selection-background-color: #2b77ff;
    selection-color: #ffffff;
}
QLineEdit:focus, QComboBox:focus, QTextEdit:focus, QPlainTextEdit:focus { border: 1px solid #6aa9ff; }
QComboBox::drop-down { border: none; width: 28px; }
QComboBox::down-arrow {
    image: none;
    border-left: 6px solid transparent;
    border-right: 6px solid transparent;
    border-top: 8px solid #b8c2ff;
    margin-right: 10px;
}
QCheckBox { spacing: 10px; }
QCheckBox::indicator {
    width: 18px; height: 18px;
    border-radius: 5px;
    border: 1px solid #2a3760;
    background: #101a34;
}
QCheckBox::indicator:checked {
    background: #2b77ff;
    border: 1px solid #6aa9ff;
}
QPushButton {
    background: #17224a;
    border: 1px solid #2a3760;
    border-radius: 12px;
    padding: 10px 14px;
    font-weight: 700;
}
QPushButton:hover { background: #1b2a5e; border: 1px solid #3b4c83; }
QPushButton:pressed { background: #132044; }
QPushButton:disabled { background: #111829; border: 1px solid #1a2340; color: #7f87b8; }
QProgressBar {
    background: #101a34;
    border: 1px solid #2a3760;
    border-radius: 12px;
    text-align: center;
    padding: 2px;
}
QProgressBar::chunk { background: #2b77ff; border-radius: 10px; }
QScrollBar:vertical { background: transparent; width: 12px; margin: 2px; }
QScrollBar::handle:vertical { background: #2a3760; border-radius: 6px; min-height: 22px; }
QScrollBar::handle:vertical:hover { background: #3b4c83; }
QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }
QScrollBar:horizontal { background: transparent; height: 12px; margin: 2px; }
QScrollBar::handle:horizontal { background: #2a3760; border-radius: 6px; min-width: 22px; }
QScrollBar::handle:horizontal:hover { background: #3b4c83; }
QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal { width: 0px; }
"""

# ============================================================
# GitHub sources (packages list + optional zst installs)
# ============================================================
GITHUB_PACKAGES_BLOB_URL = (
    "https://github.com/bfitzgit23/stormos-build-files/blob/main/install-stormos-xfce/packages.x86_64"
)
GITHUB_ZST_BLOB_URLS = [
    "https://github.com/bfitzgit23/stormos/blob/main/x86_64/adw-gtk-theme-git-5.7.r4.gf3ba1d7-1-any.pkg.tar.zst",
]

# ============================================================
# Paths / Files
# ============================================================
LOG_FILE = Path("/tmp/stormos_easy_installer.log")
LIVE_SKEL = Path("/etc/skel")
LIVE_PKG_LIST = Path("/etc/stormos/packages.txt")

# Keep your requested wallpaper destination (even if non-XFCE DE selected)
WALLPAPER_DEST_DIR = "/usr/share/backgrounds/xfce"

# ============================================================
# Desktop Environments / Display Managers
# ============================================================
DE_XFCE = "XFCE (LightDM)"
DE_GNOME = "GNOME (GDM)"
DE_PLASMA = "KDE Plasma (SDDM)"
DE_CINNAMON = "Cinnamon (LightDM)"
DE_MATE = "MATE (LightDM)"
DE_LXQT = "LXQt (SDDM)"

ALL_DESKTOPS = [DE_XFCE, DE_GNOME, DE_PLASMA, DE_CINNAMON, DE_MATE, DE_LXQT]

DM_LIGHTDM = "lightdm"
DM_GDM = "gdm"
DM_SDDM = "sddm"

# ============================================================
# Logging helpers
# ============================================================
def log_to_file(line: str) -> None:
    try:
        LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        with LOG_FILE.open("a", encoding="utf-8", errors="ignore") as f:
            f.write(line.rstrip("\n") + "\n")
    except Exception:
        pass

def reset_log_file() -> None:
    try:
        LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        LOG_FILE.write_text("", encoding="utf-8", errors="ignore")
    except Exception:
        pass

# ============================================================
# System helpers
# ============================================================
def is_root() -> bool:
    try:
        return os.geteuid() == 0
    except Exception:
        return False

def is_uefi() -> bool:
    return Path("/sys/firmware/efi/efivars").exists()

def which(cmd: str) -> Optional[str]:
    return shutil.which(cmd)

def cmd_ok(cmd: str) -> bool:
    return which(cmd) is not None

def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)

def read_text(p: Path) -> str:
    try:
        return p.read_text(errors="ignore")
    except Exception:
        return ""

def write_file(path: Path, content: str) -> None:
    ensure_dir(path.parent)
    path.write_text(content, encoding="utf-8", errors="ignore")

def sanitize_hostname(h: str) -> str:
    h = (h or "").strip().lower()
    h = re.sub(r"[^a-z0-9-]", "-", h)
    h = re.sub(r"-{2,}", "-", h).strip("-")
    return h[:63] if h else "arch"

def sanitize_username(u: str) -> str:
    u = (u or "").strip().lower()
    u = re.sub(r"[^a-z0-9_]", "", u)
    if not u or u[0].isdigit():
        u = "user"
    return u[:32]

def have_internet_fast() -> bool:
    try:
        s = socket.create_connection(("1.1.1.1", 53), timeout=1.0)
        s.close()
        return True
    except Exception:
        return False

def safe_umount_recursive(mountpoint: str) -> None:
    try:
        mounts = read_text(Path("/proc/mounts")).splitlines()
        mps = []
        for line in mounts:
            parts = line.split()
            if len(parts) >= 2:
                mps.append(parts[1])
        for m in sorted(mps, key=len, reverse=True):
            if m == mountpoint or m.startswith(mountpoint.rstrip("/") + "/"):
                subprocess.run(["umount", "-R", mountpoint],
                               stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                break
        subprocess.run(["umount", mountpoint],
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except Exception:
        pass

def partition_path(disk: str, n: int) -> str:
    if re.search(r"(nvme\d+n\d+|mmcblk\d+)$", disk):
        return f"{disk}p{n}"
    return f"{disk}{n}"

def detect_microcode_pkg() -> Optional[str]:
    cpuinfo = read_text(Path("/proc/cpuinfo")).lower()
    if "genuineintel" in cpuinfo:
        return "intel-ucode"
    if "authenticamd" in cpuinfo:
        return "amd-ucode"
    return None

# ============================================================
# Disk helpers
# ============================================================
def list_disks() -> List[Tuple[str, str, str]]:
    if not cmd_ok("lsblk"):
        return []
    cp = subprocess.run(
        ["lsblk", "-dn", "-o", "NAME,TYPE,SIZE,MODEL"],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
    )
    out = cp.stdout or ""
    disks = []
    for line in out.splitlines():
        line = line.strip()
        if not line:
            continue
        parts = line.split(None, 3)
        if len(parts) < 3:
            continue
        name, typ, size = parts[0], parts[1], parts[2]
        model = parts[3].strip() if len(parts) >= 4 else ""
        if typ != "disk":
            continue
        if name.startswith(("loop", "ram", "sr")):
            continue
        disks.append((f"/dev/{name}", size, model))
    return disks

def list_partitions_for_disk(disk: str) -> List[Tuple[str, str, str, str, str, str]]:
    if not cmd_ok("lsblk"):
        return []
    cp = subprocess.run(
        ["lsblk", "-prn", "-o", "NAME,TYPE,PKNAME,SIZE,FSTYPE,MOUNTPOINT,PARTLABEL,PARTTYPE"],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
    )
    out = (cp.stdout or "").strip()
    res: List[Tuple[str, str, str, str, str, str]] = []
    disk_base = Path(disk).name
    for line in out.splitlines():
        parts = line.split(None, 7)
        if len(parts) < 4:
            continue
        name = parts[0]
        typ = parts[1]
        pkname = parts[2] if len(parts) >= 3 else ""
        size = parts[3] if len(parts) >= 4 else ""
        fstype = parts[4] if len(parts) >= 5 else ""
        mnt = parts[5] if len(parts) >= 6 else ""
        plabel = parts[6] if len(parts) >= 7 else ""
        ptype = parts[7] if len(parts) >= 8 else ""
        fstype = "" if fstype == "-" else fstype
        mnt = "" if mnt == "-" else mnt
        plabel = "" if plabel == "-" else plabel
        ptype = "" if ptype == "-" else ptype
        if typ != "part":
            continue
        if pkname != disk_base:
            continue
        res.append((name, size, fstype, mnt, plabel, ptype))
    return res

# ============================================================
# Run helpers (stream output)
# ============================================================
def run_stream(cmd: List[str], on_line, timeout: Optional[int] = None, input_text: Optional[str] = None) -> int:
    p = subprocess.Popen(
        cmd,
        stdin=subprocess.PIPE if input_text is not None else None,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True
    )
    start = time.time()
    try:
        if input_text is not None and p.stdin is not None:
            try:
                p.stdin.write(input_text)
                p.stdin.close()
            except Exception:
                pass
        assert p.stdout is not None
        for line in p.stdout:
            on_line(line.rstrip("\n"))
            if timeout is not None and (time.time() - start) > timeout:
                on_line(f"!! Timeout ({timeout}s) reached, terminating: {' '.join(cmd)}")
                p.terminate()
                try:
                    p.wait(timeout=5)
                except Exception:
                    p.kill()
                return 124
        return p.wait()
    finally:
        try:
            if p.stdout:
                p.stdout.close()
        except Exception:
            pass

def arch_chroot(target_root: Path, cmd: str, log) -> None:
    full = ["arch-chroot", str(target_root), "bash", "-lc", cmd]
    log(f"$ arch-chroot {target_root} bash -lc {cmd}")
    rc = run_stream(full, log, timeout=None)
    if rc != 0:
        raise RuntimeError(f"arch-chroot failed (rc={rc}): {cmd}")

def arch_chroot_soft(target_root: Path, cmd: str, log) -> int:
    full = ["arch-chroot", str(target_root), "bash", "-lc", cmd]
    log(f"$ arch-chroot {target_root} bash -lc {cmd}")
    return run_stream(full, log, timeout=None)

def arch_chroot_input(target_root: Path, cmd: str, input_text: str, log) -> None:
    full = ["arch-chroot", str(target_root), "bash", "-lc", cmd]
    log(f"$ arch-chroot {target_root} bash -lc {cmd}  (stdin provided)")
    rc = run_stream(full, log, timeout=None, input_text=input_text)
    if rc != 0:
        raise RuntimeError(f"arch-chroot failed (rc={rc}): {cmd}")

def blkid_partuuid(dev: str) -> str:
    cp = subprocess.run(["blkid", "-s", "PARTUUID", "-o", "value", dev],
                        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    return (cp.stdout or "").strip()

def blkid_fstype(dev: str) -> str:
    cp = subprocess.run(["blkid", "-s", "TYPE", "-o", "value", dev],
                        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    return (cp.stdout or "").strip()

# ============================================================
# Wi-Fi status
# ============================================================
def wifi_status_line() -> str:
    if not cmd_ok("nmcli"):
        return "Wi-Fi: nmcli not available"
    try:
        cp = subprocess.run(["nmcli", "-t", "-f", "DEVICE,TYPE,STATE,CONNECTION", "device"],
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        out = (cp.stdout or "").strip()
        wifi_dev = None
        conn = None
        state = None
        for line in out.splitlines():
            parts = line.split(":")
            if len(parts) >= 4:
                dev, typ, st, con = parts[0], parts[1], parts[2], parts[3]
                if typ == "wifi":
                    wifi_dev = dev
                    state = st
                    conn = con
                    break
        if wifi_dev and state == "connected" and conn:
            return f"Wi-Fi: Connected to {conn} on {wifi_dev}"
        if wifi_dev:
            return f"Wi-Fi: {state or 'unknown'} on {wifi_dev}"
        return "Wi-Fi: Not detected"
    except Exception:
        return "Wi-Fi: Unknown"

# ============================================================
# GitHub download helpers
# ============================================================
def github_blob_to_raw(url: str) -> str:
    u = (url or "").strip()
    m = re.match(r"^https?://github\.com/([^/]+)/([^/]+)/blob/([^/]+)/(.*)$", u)
    if m:
        owner, repo, branch, path = m.group(1), m.group(2), m.group(3), m.group(4)
        return f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{path}"
    m2 = re.match(r"^https?://github\.com/([^/]+)/([^/]+)/raw/([^/]+)/(.*)$", u)
    if m2:
        owner, repo, branch, path = m2.group(1), m2.group(2), m2.group(3), m2.group(4)
        return f"https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{path}"
    return u

def _download_via_tool(url: str, dest: Optional[Path], want_text: bool) -> Optional[str]:
    ua = "StormOS-Installer/1.0"
    if cmd_ok("curl"):
        if want_text:
            cp = subprocess.run(["curl", "-fsSL", "-A", ua, url],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            if cp.returncode == 0:
                return cp.stdout or ""
            raise RuntimeError((cp.stdout or "curl failed").strip())
        else:
            assert dest is not None
            ensure_dir(dest.parent)
            cp = subprocess.run(["curl", "-fL", "-A", ua, "-o", str(dest), url],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            if cp.returncode == 0 and dest.exists() and dest.stat().st_size > 0:
                return None
            raise RuntimeError((cp.stdout or "curl download failed").strip())
    if cmd_ok("wget"):
        if want_text:
            cp = subprocess.run(["wget", "-qO-", "--user-agent", ua, url],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            if cp.returncode == 0:
                return cp.stdout or ""
            raise RuntimeError((cp.stdout or "wget failed").strip())
        else:
            assert dest is not None
            ensure_dir(dest.parent)
            cp = subprocess.run(["wget", "-qO", str(dest), "--user-agent", ua, url],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            if cp.returncode == 0 and dest.exists() and dest.stat().st_size > 0:
                return None
            raise RuntimeError((cp.stdout or "wget download failed").strip())
    return None

def download_text(url: str, log: Callable[[str], None], timeout: int = 45) -> str:
    raw = github_blob_to_raw(url)
    log(f"Downloading text: {raw}")
    try:
        t = _download_via_tool(raw, None, want_text=True)
        if t is not None:
            return t
    except Exception as e:
        log(f"!! curl/wget text fetch failed (will try python): {e}")
    req = urllib.request.Request(raw, headers={"User-Agent": "StormOS-Installer/1.0"})
    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            data = resp.read()
            return data.decode("utf-8", errors="ignore")
    except urllib.error.URLError as e:
        raise RuntimeError(f"Failed to download text from {raw}: {e}") from e

def download_file(url: str, dest: Path, log: Callable[[str], None], timeout: int = 180) -> None:
    raw = github_blob_to_raw(url)
    log(f"Downloading file: {raw} -> {dest}")
    try:
        _download_via_tool(raw, dest, want_text=False)
        if dest.exists() and dest.stat().st_size > 0:
            return
    except Exception as e:
        log(f"!! curl/wget file download failed (will try python): {e}")
    ensure_dir(dest.parent)
    req = urllib.request.Request(raw, headers={"User-Agent": "StormOS-Installer/1.0"})
    try:
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            with dest.open("wb") as f:
                shutil.copyfileobj(resp, f)
        if not dest.exists() or dest.stat().st_size == 0:
            raise RuntimeError("Downloaded file is empty.")
    except Exception as e:
        raise RuntimeError(f"Failed to download file from {raw}: {e}") from e

# ============================================================
# pacman.conf repo helpers (multilib)
# ============================================================
def enable_repo_in_pacman_conf(conf_path: Path, repo_name: str, log) -> bool:
    txt = read_text(conf_path)
    if not txt.strip():
        raise RuntimeError(f"pacman.conf missing/empty: {conf_path}")
    changed = False
    header_re = re.compile(rf"(?m)^\s*#?\s*\[{re.escape(repo_name)}\]\s*$")
    m = header_re.search(txt)
    if not m:
        txt = txt.rstrip() + f"\n[{repo_name}]\nInclude = /etc/pacman.d/mirrorlist\n"
        changed = True
    else:
        txt2 = re.sub(rf"(?m)^\s*#\s*\[{re.escape(repo_name)}\]\s*$",
                      f"[{repo_name}]",
                      txt)
        if txt2 != txt:
            txt = txt2
            changed = True
    block_re = re.compile(rf"(?ms)^\s*\[{re.escape(repo_name)}\]\s*$.*?(?=^\s*\[|\Z)")
    bm = block_re.search(txt)
    if bm:
        block = bm.group(0)
        block2 = re.sub(r"(?m)^\s*#\s*(Include\s*=\s*/etc/pacman\.d/mirrorlist)\s*$",
                        r"\1",
                        block)
        if block2 != block:
            txt = txt[:bm.start()] + block2 + txt[bm.end():]
            changed = True
        bm2 = block_re.search(txt)
        if bm2:
            block_now = bm2.group(0)
            if not re.search(r"(?m)^\s*Include\s*=\s*/etc/pacman.d/mirrorlist\s*$", block_now):
                block_now2 = block_now.rstrip() + "\nInclude = /etc/pacman.d/mirrorlist\n"
                txt = txt[:bm2.start()] + block_now2 + txt[bm2.end():]
                changed = True
    if changed:
        write_file(conf_path, txt if txt.endswith("\n") else (txt + "\n"))
        log(f"Enabled repo [{repo_name}] in {conf_path}")
    else:
        log(f"Repo [{repo_name}] already enabled in {conf_path}")
    return changed

def ensure_multilib_enabled_live(log) -> None:
    live_conf = Path("/etc/pacman.conf")
    enable_repo_in_pacman_conf(live_conf, "multilib", log)
    if cmd_ok("pacman"):
        run_stream(["pacman", "-Syy", "--noconfirm"], log, timeout=None)

def ensure_multilib_enabled_target(target_root: Path, log) -> None:
    tgt_conf = target_root / "etc" / "pacman.conf"
    if tgt_conf.exists():
        enable_repo_in_pacman_conf(tgt_conf, "multilib", log)

# ============================================================
# Copy helpers
# ============================================================
def copy_tree_merge(src: Path, dst: Path, log) -> None:
    if not src.exists():
        log(f"-- Missing: {src}")
        return
    ensure_dir(dst)
    if cmd_ok("rsync"):
        rc = subprocess.run(["rsync", "-a", f"{str(src)}/", f"{str(dst)}/"],
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True).returncode
        if rc != 0:
            log(f"!! rsync returned non-zero for {src} -> {dst} (continuing)")
    else:
        for root, dirs, files in os.walk(str(src), followlinks=False):
            rp = Path(root)
            rel = rp.relative_to(src)
            out_root = dst / rel
            ensure_dir(out_root)
            for d in dirs:
                ensure_dir(out_root / d)
            for f in files:
                s = rp / f
                o = out_root / f
                try:
                    if o.exists() or o.is_symlink():
                        try:
                            o.unlink()
                        except Exception:
                            pass
                    if s.is_symlink():
                        try:
                            o.symlink_to(os.readlink(str(s)))
                        except Exception:
                            pass
                    else:
                        shutil.copy2(str(s), str(o))
                except Exception as e:
                    log(f"!! copy warn: {s} -> {o}: {e}")

def migrate_usr_local_bin(target_root: Path, log) -> None:
    src = Path("/usr/local/bin")
    dst = target_root / "usr" / "local" / "bin"
    if not src.exists():
        log("Migration: LIVE /usr/local/bin not present — skipping.")
        return
    log(f"Migration: copying {src} -> {dst}")
    copy_tree_merge(src, dst, log)
    try:
        count = 0
        for p in dst.iterdir():
            if p.is_file() and not p.is_symlink():
                st = p.stat()
                mode = st.st_mode
                new_mode = mode | 0o111
                if new_mode != mode:
                    os.chmod(str(p), new_mode)
                    count += 1
        log(f"Migration: ensured executability on {count} files in {dst}")
    except Exception as e:
        log(f"!! Migration: chmod pass failed: {e}")

def migrate_usr_share_icons(target_root: Path, log) -> None:
    src = Path("/usr/share/icons")
    dst = target_root / "usr" / "share" / "icons"
    if not src.exists():
        log("Icons migration: LIVE /usr/share/icons not present — skipping.")
        return
    log(f"Icons migration: merging {src} -> {dst}")
    copy_tree_merge(src, dst, log)

def apply_skel_preset(target_root: Path, log) -> None:
    if not LIVE_SKEL.exists():
        log("Preset: /etc/skel not found on Live ISO — skipping.")
        return
    log(f"Preset: merging Live ISO {LIVE_SKEL} -> target {target_root/'etc/skel'}")
    copy_tree_merge(LIVE_SKEL, target_root / "etc" / "skel", log)

def copy_stormos_wallpapers_into_backgrounds(target_root: Path, log) -> None:
    live = Path("/usr/share/backgrounds/StormOS")
    dst = target_root / "usr" / "share" / "backgrounds" / "StormOS"
    if not live.exists():
        log("Wallpapers: live /usr/share/backgrounds/StormOS not found — skipping.")
        return
    log(f"Wallpapers: copying {live} -> {dst}")
    copy_tree_merge(live, dst, log)

# ============================================================
# Wallpaper: host -> installed at /usr/share/backgrounds/xfce/xfce-x.<ext>
# ============================================================
def get_live_wallpaper_path_best_effort(log) -> Optional[Path]:
    if cmd_ok("xfconf-query"):
        candidates = [
            "/backdrop/screen0/monitor0/workspace0/last-image",
            "/backdrop/screen0/monitor0/workspace0/image-path",
            "/backdrop/screen0/monitor0/last-image",
            "/backdrop/screen0/monitor0/image-path",
        ]
        for prop in candidates:
            try:
                cp = subprocess.run(
                    ["xfconf-query", "-c", "xfce4-desktop", "-p", prop],
                    stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True
                )
                val = (cp.stdout or "").strip()
                if val and Path(val).exists():
                    log(f"Wallpaper detect: xfconf {prop} -> {val}")
                    return Path(val)
            except Exception:
                pass

    fallbacks = [
        Path("/usr/share/backgrounds/xfce/xfce-x.svg"),
        Path("/usr/share/backgrounds/xfce/xfce-x.png"),
        Path("/usr/share/backgrounds/xfce/xfce-x.jpg"),
        Path("/usr/share/backgrounds/xfce-x.svg"),
        Path("/usr/share/backgrounds/xfce-x.png"),
        Path("/usr/share/backgrounds/xfce-x.jpg"),
    ]
    for p in fallbacks:
        if p.exists() and p.is_file() and p.stat().st_size > 0:
            log(f"Wallpaper detect: fallback -> {p}")
            return p

    log("Wallpaper detect: could not find a live wallpaper.")
    return None

def ensure_wallpaper_from_host(target_root: Path, log) -> str:
    src = get_live_wallpaper_path_best_effort(log) or Path("/usr/share/backgrounds/xfce/xfce-x.svg")
    ext = src.suffix.lower()
    if ext not in [".png", ".jpg", ".jpeg", ".svg", ".webp"]:
        ext = ".png"

    dest_dir = target_root / "usr" / "share" / "backgrounds" / "xfce"
    ensure_dir(dest_dir)
    dest = dest_dir / f"xfce-x{ext}"

    if src.exists() and src.is_file() and src.stat().st_size > 0:
        shutil.copy2(str(src), str(dest))
        log(f"Wallpaper: copied host wallpaper {src} -> {dest}")
    else:
        raise RuntimeError(f"Wallpaper source missing/invalid: {src}")

    # Compat symlink /usr/share/backgrounds/xfce-x.<ext>
    compat = target_root / "usr" / "share" / "backgrounds" / f"xfce-x{ext}"
    try:
        if compat.exists() or compat.is_symlink():
            compat.unlink()
        compat.symlink_to(Path("xfce") / f"xfce-x{ext}")
        log(f"Wallpaper: created symlink {compat} -> xfce/xfce-x{ext}")
    except Exception as e:
        log(f"!! Wallpaper: compat symlink failed (non-fatal): {e}")

    return f"/usr/share/backgrounds/xfce/xfce-x{ext}"

# ============================================================
# XFCE wallpaper patch (only meaningful for XFCE)
# ============================================================
def ensure_minimal_xfce_desktop_xml(xml_path: Path, log) -> None:
    if xml_path.exists():
        return
    log("XFCE wallpaper: creating minimal xfce4-desktop.xml in skel")
    ensure_dir(xml_path.parent)
    minimal_xml = '''<?xml version="1.0" encoding="UTF-8"?>
<channel name="xfce4-desktop" version="1.0">
  <property name="backdrop" type="empty">
    <property name="screen0" type="empty">
      <property name="monitor0" type="empty">
        <property name="workspace0" type="empty">
          <property name="last-image" type="string" value=""/>
          <property name="image-path" type="string" value=""/>
          <property name="image-show" type="bool" value="true"/>
        </property>
        <property name="image-path" type="string" value=""/>
        <property name="last-image" type="string" value=""/>
      </property>
    </property>
  </property>
</channel>
'''
    write_file(xml_path, minimal_xml)

def patch_xfce_wallpaper_in_skel(target_root: Path, wallpaper_path: str, log) -> None:
    xml = target_root / "etc" / "skel" / ".config" / "xfce4" / "xfconf" / "xfce-perchannel-xml" / "xfce4-desktop.xml"
    ensure_minimal_xfce_desktop_xml(xml, log)
    txt = read_text(xml)
    if not txt:
        log("XFCE wallpaper: unable to read xfce4-desktop.xml; skipping.")
        return

    new = re.sub(
        r'(<property\s+name="(last-image|image-path)"\s+type="string"\s+value=")[^"]*(")',
        rf'\1{wallpaper_path}\3',
        txt
    )
    if new == txt:
        if '<property name="workspace0"' in new:
            insert = f'          <property name="last-image" type="string" value="{wallpaper_path}"/>\n'
            insert += f'          <property name="image-path" type="string" value="{wallpaper_path}"/>\n'
            new = re.sub(r'(\s*<property name="workspace0"[^>]*>\s*\n)', r'\1' + insert, new)
    if new != txt:
        write_file(xml, new)
        log(f"XFCE wallpaper: patched {xml} -> {wallpaper_path}")
    else:
        log("XFCE wallpaper: no changes made.")

def install_firstboot_wallpaper_fix(target_root: Path, wallpaper_path: str, log) -> None:
    service_dir = target_root / "etc" / "skel" / ".config" / "systemd" / "user"
    ensure_dir(service_dir)
    service_file = service_dir / "stormos-wallpaper-fix.service"
    script_file = target_root / "etc" / "skel" / ".local" / "bin" / "stormos-apply-wallpaper.sh"
    ensure_dir(script_file.parent)

    script_content = f'''#!/bin/bash
if command -v xfconf-query >/dev/null 2>&1; then
  xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor0/workspace0/last-image -s "{wallpaper_path}" 2>/dev/null || true
  xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor0/workspace0/image-path -s "{wallpaper_path}" 2>/dev/null || true
  xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor0/last-image -s "{wallpaper_path}" 2>/dev/null || true
  xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor0/image-path -s "{wallpaper_path}" 2>/dev/null || true
fi
systemctl --user disable stormos-wallpaper-fix.service 2>/dev/null || true
rm -f ~/.config/systemd/user/stormos-wallpaper-fix.service
'''
    write_file(script_file, script_content)
    script_file.chmod(0o755)

    service_content = '''[Unit]
Description=StormOS First-Boot Wallpaper Fix
After=graphical-session.target

[Service]
Type=oneshot
ExecStart=%h/.local/bin/stormos-apply-wallpaper.sh

[Install]
WantedBy=default.target
'''
    write_file(service_file, service_content)
    log("XFCE wallpaper: installed first-boot fix (systemd user service)")

# ============================================================
# LightDM greeter config (only when LightDM chosen)
# ============================================================
def configure_lightdm_greeter(target_root: Path, background_path: Optional[str], log,
                              theme_name: Optional[str], icon_theme: Optional[str]) -> None:
    conf = target_root / "etc" / "lightdm" / "lightdm-gtk-greeter.conf"
    ensure_dir(conf.parent)
    lines = ["[greeter]"]
    if background_path:
        lines.append(f"background={background_path}")
    if theme_name:
        lines.append(f"theme-name={theme_name}")
    if icon_theme:
        lines.append(f"icon-theme-name={icon_theme}")
    lines += [
        "font-name=Sans 10",
        "xft-antialias=true",
        "xft-hintstyle=hintfull",
        "xft-rgba=rgb",
    ]
    write_file(conf, "\n".join(lines) + "\n")
    log(f"LightDM: wrote {conf}")

def list_installed_dirs(target_root: Path, rel: str) -> List[str]:
    d = target_root / rel.strip("/")
    if not d.exists():
        return []
    out = []
    for x in d.iterdir():
        if x.is_dir():
            out.append(x.name)
    return sorted(out)

def choose_best_theme_name(target_root: Path, preferred: str = "adw-gtk-dark") -> str:
    themes = set(list_installed_dirs(target_root, "usr/share/themes"))
    pref_order = [preferred, "adw-gtk-dark", "adw-gtk", "Adwaita-dark", "Adwaita"]
    for p in pref_order:
        if p in themes:
            return p
    return next(iter(themes), preferred)

def choose_best_icon_theme(target_root: Path) -> str:
    icons = set(list_installed_dirs(target_root, "usr/share/icons"))
    pref_order = ["Tela-circle-dark", "Tela-circle-black", "Tela-circle-grey", "Tela-circle", "Tela", "Adwaita", "hicolor"]
    for p in pref_order:
        if p in icons:
            return p
    return next(iter(icons), "Adwaita")

def write_default_gtk_settings_to_skel(target_root: Path, theme_name: str, icon_theme: str, log,
                                      cursor_theme: str = "Adwaita") -> None:
    ini = target_root / "etc" / "skel" / ".config" / "gtk-3.0" / "settings.ini"
    ensure_dir(ini.parent)
    content = (
        "[Settings]\n"
        f'gtk-theme-name="{theme_name}"\n'
        f'gtk-icon-theme-name="{icon_theme}"\n'
        f'gtk-cursor-theme-name="{cursor_theme}"\n'
        'gtk-font-name="Sans 10"\n'
    )
    write_file(ini, content)
    log(f"GTK default: wrote {ini} (theme={theme_name}, icons={icon_theme})")

def patch_xfce_icon_theme_in_skel(target_root: Path, icon_theme: str, log) -> None:
    xml = target_root / "etc" / "skel" / ".config" / "xfce4" / "xfconf" / "xfce-perchannel-xml" / "xsettings.xml"
    if not xml.exists():
        log("XFCE icons: xsettings.xml not found; skipping.")
        return
    txt = read_text(xml)
    if not txt.strip():
        log("XFCE icons: unable to read xsettings.xml; skipping.")
        return
    new = re.sub(
        r'(<property\s+name="IconThemeName"\s+type="string"\s+value=")([^"]*)(")',
        rf'\1{icon_theme}\3',
        txt
    )
    if new != txt:
        write_file(xml, new)
        log(f"XFCE icons: patched {xml} -> IconThemeName={icon_theme}")
    else:
        log("XFCE icons: no change needed.")

# ============================================================
# Boot mode / filesystem / install mode
# ============================================================
BOOT_AUTO = "Auto (recommended)"
BOOT_UEFI = "UEFI"
BOOT_BIOS = "BIOS / Legacy"

FS_EXT4 = "ext4 (recommended)"
FS_BTRFS = "btrfs (snapshots-ready)"
FS_XFS = "xfs (fast, stable)"

MODE_ERASE = "ERASE DISK (automatic partitioning) — DESTRUCTIVE"
MODE_EXISTING = "USE EXISTING PARTITIONS (manual selection) — NO DISK WIPE"

def effective_boot_mode(selection: str) -> str:
    if selection == BOOT_UEFI:
        return "UEFI"
    if selection == BOOT_BIOS:
        return "BIOS"
    return "UEFI" if is_uefi() else "BIOS"

def effective_fs(selection: str) -> str:
    if selection.startswith("btrfs"):
        return "btrfs"
    if selection.startswith("xfs"):
        return "xfs"
    return "ext4"

# ============================================================
# Packages / DE selection
# ============================================================
PACKAGE_BLACKLIST = {
    "archiso", "mkarchiso", "calamares", "calamares-config", "calamares-config-xfce",
    "squashfs-tools", "zram-generator", "reflector", "clonezilla", "memtest86+",
}

def parse_packages_text(txt: str) -> List[str]:
    pkgs: List[str] = []
    for line in (txt or "").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "#" in line:
            line = line.split("#", 1)[0].strip()
        for part in line.split():
            if part:
                pkgs.append(part)
    return pkgs

def read_packages_txt(path: Path) -> List[str]:
    if not path.exists():
        return []
    return parse_packages_text(read_text(path))

def normalize_package_set(pkgs: List[str]) -> List[str]:
    out = []
    seen = set()
    for p in pkgs:
        p = (p or "").strip()
        if not p:
            continue
        if p in PACKAGE_BLACKLIST:
            continue
        if p not in seen:
            seen.add(p)
            out.append(p)
    return out

def desktop_to_dm(desktop_choice: str) -> str:
    if desktop_choice == DE_GNOME:
        return DM_GDM
    if desktop_choice in (DE_PLASMA, DE_LXQT):
        return DM_SDDM
    return DM_LIGHTDM

def de_package_set(desktop_choice: str) -> Tuple[List[str], List[str]]:
    """
    Returns (desktop_packages, dm_packages).
    Kept minimal-ish but functional.
    """
    if desktop_choice == DE_XFCE:
        desktop = [
            "xfce4", "xfce4-goodies", "thunar", "tumbler", "gvfs",
            "xfce4-terminal", "xfce4-power-manager", "xfconf",
            "pavucontrol",
        ]
        dm = ["lightdm", "lightdm-gtk-greeter"]
        return desktop, dm

    if desktop_choice == DE_GNOME:
        # gnome group is large; using 'gnome' is simplest for a full desktop
        desktop = ["gnome"]
        dm = ["gdm"]
        return desktop, dm

    if desktop_choice == DE_PLASMA:
        desktop = ["plasma", "konsole", "dolphin"]
        dm = ["sddm"]
        return desktop, dm

    if desktop_choice == DE_CINNAMON:
        desktop = ["cinnamon", "nemo", "gnome-terminal"]
        dm = ["lightdm", "lightdm-gtk-greeter"]
        return desktop, dm

    if desktop_choice == DE_MATE:
        desktop = ["mate", "mate-extra", "mate-terminal", "caja"]
        dm = ["lightdm", "lightdm-gtk-greeter"]
        return desktop, dm

    if desktop_choice == DE_LXQT:
        desktop = ["lxqt", "pcmanfm-qt", "qterminal"]
        dm = ["sddm"]
        return desktop, dm

    # fallback XFCE
    desktop = ["xfce4", "xfce4-goodies"]
    dm = ["lightdm", "lightdm-gtk-greeter"]
    return desktop, dm

def base_packages_for_install(boot_mode: str, want_yay: bool, fs: str) -> List[str]:
    micro = detect_microcode_pkg()
    base = [
        "base", "linux", "linux-firmware",
        "networkmanager", "sudo", "vim",
        "xorg-server", "xorg-xinit",
        "pipewire", "pipewire-pulse", "wireplumber",
    ]
    # Filesystem tools
    if fs == "btrfs":
        base += ["btrfs-progs"]
    elif fs == "xfs":
        base += ["xfsprogs"]
    # Boot tools
    if boot_mode == "UEFI":
        base += ["efibootmgr"]
    else:
        base += ["grub"]
    if micro:
        base.append(micro)
    # AUR prereqs
    if want_yay:
        base += ["base-devel", "git", "sudo"]
    # Icons (optional but nice)
    base += [
        "hicolor-icon-theme",
        "adwaita-icon-theme",
        "tela-circle-icon-theme-standard",
        "tela-circle-icon-theme-black",
        "tela-circle-icon-theme-grey",
    ]
    return normalize_package_set(base)

def choose_package_list(
    boot_mode: str,
    desktop_choice: str,
    want_yay: bool,
    fs: str,
    use_local_packages_txt: bool,
    use_github_packages_list: bool,
    log: Callable[[str], None]
) -> Tuple[List[str], str]:
    base = base_packages_for_install(boot_mode, want_yay, fs)
    desktop_pkgs, dm_pkgs = de_package_set(desktop_choice)
    combined_base = normalize_package_set(base + desktop_pkgs + dm_pkgs)

    # Prefer user-provided list (local or github) but ALWAYS add required base+DE+DM.
    if use_local_packages_txt and LIVE_PKG_LIST.exists():
        custom = normalize_package_set(read_packages_txt(LIVE_PKG_LIST))
        return normalize_package_set(custom + combined_base), f"Local list: {LIVE_PKG_LIST} (+required base/DE/DM)"
    if use_github_packages_list:
        try:
            txt = download_text(GITHUB_PACKAGES_BLOB_URL, log, timeout=45)
            custom = normalize_package_set(parse_packages_text(txt))
            return normalize_package_set(custom + combined_base), f"GitHub list: {GITHUB_PACKAGES_BLOB_URL} (+required base/DE/DM)"
        except Exception as e:
            log(f"!! GitHub packages list failed, falling back to required set: {e}")
    return combined_base, "Required base + selected DE + selected display manager"

def pacman_sync_live(log) -> None:
    if not cmd_ok("pacman"):
        log("!! pacman not found on Live ISO; cannot sync DB.")
        return
    log("Updating pacman databases on Live ISO (pacman -Syy)…")
    rc = run_stream(["pacman", "-Syy", "--noconfirm"], log, timeout=None)
    if rc != 0:
        log("!! pacman -Syy failed on Live ISO (continuing)")

def filter_available_repo_packages(pkgs: List[str], log, chunk: int = 60) -> Tuple[List[str], List[str]]:
    if not cmd_ok("pacman"):
        log("!! pacman not found on Live ISO; cannot pre-check packages.")
        return pkgs, []
    available: List[str] = []
    missing: List[str] = []
    to_check = [p for p in pkgs if p]
    for i in range(0, len(to_check), chunk):
        batch = to_check[i:i + chunk]
        cp = subprocess.run(["pacman", "-Si"] + batch,
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        out = cp.stdout or ""
        if cp.returncode == 0:
            available.extend(batch)
            continue
        missing_in_batch = set(re.findall(r"error:\s+package\s+'([^']+)'\s+was\s+not\s+found", out))
        for p in batch:
            if p in missing_in_batch:
                missing.append(p)
            else:
                cp2 = subprocess.run(["pacman", "-Si", p],
                                     stdout=subprocess.DEVNULL,
                                     stderr=subprocess.DEVNULL,
                                     text=True)
                if cp2.returncode == 0:
                    available.append(p)
                else:
                    missing.append(p)

    def dedupe(seq: List[str]) -> List[str]:
        s = set()
        out2 = []
        for x in seq:
            if x not in s:
                s.add(x)
                out2.append(x)
        return out2

    return dedupe(available), dedupe(missing)

# ============================================================
# Display manager enable + LightDM extras
# ============================================================
def enable_display_manager(target_root: Path, dm: str, log) -> None:
    if dm == DM_LIGHTDM:
        arch_chroot(target_root, "systemctl enable lightdm", log)
        return
    if dm == DM_GDM:
        arch_chroot(target_root, "systemctl enable gdm", log)
        return
    if dm == DM_SDDM:
        arch_chroot(target_root, "systemctl enable sddm", log)
        return
    # fallback
    arch_chroot(target_root, "systemctl enable lightdm", log)

def enable_lightdm_autologin(target_root: Path, username: str, log) -> None:
    conf = target_root / "etc" / "lightdm" / "lightdm.conf"
    ensure_dir(conf.parent)
    txt = read_text(conf) if conf.exists() else ""
    if not txt.strip():
        txt = "[LightDM]\n[Seat:*]\n"
    if "[Seat:*]" not in txt:
        txt += "\n[Seat:*]\n"
    txt = re.sub(r"(?m)^\s*autologin-user\s*=.*\n?", "", txt)
    txt = re.sub(r"(?m)^\s*autologin-user-timeout\s*=.*\n?", "", txt)
    parts = txt.split("[Seat:*]", 1)
    head = parts[0]
    seat = "[Seat:*]" + (parts[1] if len(parts) > 1 else "\n")
    if not seat.endswith("\n"):
        seat += "\n"
    seat += f"autologin-user={username}\n"
    seat += "autologin-user-timeout=0\n"
    write_file(conf, head + seat)
    log(f"LightDM: enabled autologin for user '{username}' in {conf}")

# ============================================================
# AUR: yay (best-effort)
# ============================================================
def enforce_makepkg_no_debug(target_root: Path, log) -> str:
    p = target_root / "etc" / "makepkg.conf"
    orig = read_text(p) if p.exists() else ""
    if not orig.strip():
        log("AUR: /etc/makepkg.conf missing/empty; skipping debug enforcement.")
        return orig
    new = orig
    m = re.search(r'(?m)^\s*OPTIONS=\(([^)]*)\)\s*$', new)
    if m:
        inside = m.group(1).strip()
        tokens = inside.split()
        if "!debug" not in tokens:
            tokens.append("!debug")
        tokens = [t for t in tokens if t != "debug"]
        repl = "OPTIONS=(" + " ".join(tokens) + ")"
        new = re.sub(r'(?m)^\s*OPTIONS=\(([^)]*)\)\s*$', repl, new)
    else:
        new = new.rstrip() + "\nOPTIONS=(!debug)\n"
    if new != orig:
        write_file(p, new)
        log("AUR: enforced !debug in /etc/makepkg.conf.")
    return orig

def restore_makepkg_conf(target_root: Path, original: str, log) -> None:
    p = target_root / "etc" / "makepkg.conf"
    if original:
        write_file(p, original)
        log("AUR: restored original /etc/makepkg.conf.")

def install_yay_best_effort(target_root: Path, log) -> None:
    log("AUR: attempting to install yay (best-effort)…")
    arch_chroot_soft(target_root, "install -d -m 1777 /tmp", log)
    rc = arch_chroot_soft(target_root, "pacman -S --noconfirm --needed base-devel git sudo", log)
    if rc != 0:
        log("!! AUR: failed to install base-devel/git/sudo. Skipping yay.")
        return
    arch_chroot_soft(target_root, "id -u aurbuilder >/dev/null 2>&1 || useradd -m -s /bin/bash aurbuilder", log)
    orig = enforce_makepkg_no_debug(target_root, log)
    try:
        arch_chroot_soft(target_root, "rm -rf /tmp/aur-yay", log)
        rc = arch_chroot_soft(
            target_root,
            "sudo -u aurbuilder bash -lc 'git clone --depth 1 https://aur.archlinux.org/yay.git /tmp/aur-yay'",
            log
        )
        if rc != 0:
            log("!! AUR: git clone yay failed. Skipping yay.")
            return
        build_cmd = (
            "sudo -u aurbuilder bash -lc '"
            "set -e; cd /tmp/aur-yay; "
            "makepkg -s --noconfirm --needed --skippgpcheck; "
            "'"
        )
        rc = arch_chroot_soft(target_root, build_cmd, log)
        if rc != 0:
            log("!! AUR: makepkg build failed. Skipping yay.")
            return
        install_cmd = "bash -lc 'set -e; ls -1 /tmp/aur-yay/yay-*.pkg.tar.* | head -n1 | xargs -r pacman -U --noconfirm'"
        rc = arch_chroot_soft(target_root, install_cmd, log)
        if rc != 0:
            log("!! AUR: pacman -U yay failed. Skipping yay.")
            return
        log("AUR: yay installed successfully.")
    finally:
        restore_makepkg_conf(target_root, orig, log)
        arch_chroot_soft(target_root, "rm -rf /tmp/aur-yay /tmp/yay-bin /tmp/yay 2>/dev/null || true", log)
        arch_chroot_soft(target_root, "rm -f /etc/skel/Desktop/calamares.desktop 2>/dev/null || true", log)
        arch_chroot_soft(target_root, "rm -f /root/Desktop/calamares.desktop 2>/dev/null || true", log)
        arch_chroot_soft(
            target_root,
            r"find /home -maxdepth 3 -type f -name '*.desktop' -path '*/Desktop/*' -delete 2>/dev/null || true",
            log
        )
        arch_chroot_soft(target_root, "userdel -r aurbuilder 2>/dev/null || true", log)
        arch_chroot_soft(target_root, "groupdel aurbuilder 2>/dev/null || true", log)
        log("AUR cleanup: removed yay build dirs, calamares.desktop, and 'aurbuilder'.")

# ============================================================
# Timezone / keymap helpers
# ============================================================
def guess_live_timezone() -> str:
    try:
        lt = Path("/etc/localtime")
        if lt.is_symlink():
            target = os.readlink(str(lt))
            if "/usr/share/zoneinfo/" in target:
                return target.split("/usr/share/zoneinfo/", 1)[1]
    except Exception:
        pass
    return "America/New_York"

def list_timezones_lite(max_items: int = 2000) -> List[str]:
    base = Path("/usr/share/zoneinfo")
    if not base.exists():
        return ["UTC", "America/New_York"]
    out = []
    for root, dirs, files in os.walk(str(base)):
        rp = Path(root)
        rel = rp.relative_to(base)
        if rel.parts and rel.parts[0] in {"posix", "right"}:
            continue
        for f in files:
            p = rp / f
            if f in {"zone.tab", "zone1970.tab", "leapseconds", "tzdata.zi"}:
                continue
            if p.is_symlink():
                continue
            relp = p.relative_to(base)
            if len(relp.parts) >= 2:
                out.append("/".join(relp.parts))
    out = sorted(set(out))
    if len(out) > max_items:
        preferred = [z for z in out if z.startswith(("America/", "Europe/", "Asia/", "Australia/", "Africa/"))]
        out2 = ["UTC"] + preferred[:max_items - 1]
        return sorted(set(out2))
    return ["UTC"] + out

def guess_live_keymap() -> str:
    if cmd_ok("localectl"):
        try:
            cp = subprocess.run(["localectl", "status"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            t = cp.stdout or ""
            m = re.search(r"VC Keymap:\s*([A-Za-z0-9_-]+)", t)
            if m:
                return m.group(1).strip()
        except Exception:
            pass
    return "us"

def common_keymaps() -> List[str]:
    return [
        "us", "uk", "de", "fr", "es", "it", "pt", "br-abnt2", "ca", "dvorak", "colemak",
        "ru", "ua", "pl", "nl", "se", "no", "fi", "dk", "cz", "sk", "hu", "tr",
        "jp106", "kr", "cn", "in", "latam"
    ]

# ============================================================
# Threads
# ============================================================
@dataclass
class PreflightResult:
    root_ok: bool
    uefi_detected: bool
    internet_ok: bool
    disks: List[Tuple[str, str, str]]
    missing_base_tools: List[str]
    missing_uefi_tools: List[str]
    wifi_line: str

class PreflightThread(QThread):
    log = pyqtSignal(str)
    done = pyqtSignal(object)

    def run(self) -> None:
        def L(s: str):
            self.log.emit(s)
        L("Checking environment…")
        time.sleep(0.05)
        root_ok = is_root()
        uefi_detected = is_uefi()
        internet_ok = have_internet_fast()
        L("Checking required tools…")
        base_required = [
            "lsblk", "wipefs", "sfdisk", "mkfs.ext4", "mount", "umount",
            "pacstrap", "genfstab", "arch-chroot", "blkid", "partprobe", "udevadm", "sync", "pacman"
        ]
        missing_base = [c for c in base_required if not cmd_ok(c)]
        uefi_required = ["sgdisk", "mkfs.fat", "bootctl"]
        missing_uefi = [c for c in uefi_required if not cmd_ok(c)]
        L("Detecting disks…")
        disks = list_disks()
        self.done.emit(PreflightResult(
            root_ok=root_ok,
            uefi_detected=uefi_detected,
            internet_ok=internet_ok,
            disks=disks,
            missing_base_tools=missing_base,
            missing_uefi_tools=missing_uefi,
            wifi_line=wifi_status_line(),
        ))

@dataclass
class InstallPlan:
    install_mode: str
    disk: str
    boot_mode_choice: str
    fs_choice: str
    desktop_choice: str

    root_part: str = ""
    esp_part: str = ""
    format_root: bool = True
    format_esp: bool = False

    hostname: str = "stormos"
    username: str = "user"
    password: str = ""
    timezone: str = "UTC"
    locale: str = "en_US"
    keymap: str = "us"
    set_root_password: bool = False
    root_password: str = ""
    mountpoint: str = "/mnt"

    do_skel: bool = True
    do_copy_stormos_wallpapers: bool = True
    do_lightdm_greeter_tweaks: bool = True
    do_patch_xfce_wall: bool = True
    do_migrate_usr_local_bin: bool = True
    do_migrate_usr_share_icons: bool = True

    use_local_packages_txt: bool = True
    use_github_packages_list: bool = True
    install_github_zst_packages: bool = True

    enable_autologin: bool = False
    install_yay: bool = True
    default_theme_preferred: str = "adw-gtk-dark"

class InstallThread(QThread):
    log = pyqtSignal(str)
    progress = pyqtSignal(int)
    ok = pyqtSignal()
    fail = pyqtSignal(str)

    def __init__(self, plan: InstallPlan, parent=None):
        super().__init__(parent)
        self.plan = plan

    def run(self) -> None:
        try:
            self._run_impl()
            self.ok.emit()
        except Exception as e:
            import traceback
            self.fail.emit(f"{type(e).__name__}: {e}\n{traceback.format_exc()}")

    def _run_impl(self) -> None:
        reset_log_file()
        p = self.plan
        boot_mode = effective_boot_mode(p.boot_mode_choice)
        fs_selected = effective_fs(p.fs_choice)
        dm = desktop_to_dm(p.desktop_choice)

        def L(s: str):
            self.log.emit(s)
            log_to_file(s)

        def P(n: int):
            self.progress.emit(max(0, min(100, n)))

        if not is_root():
            raise RuntimeError("Must run as root.")
        if p.boot_mode_choice == BOOT_UEFI and not is_uefi():
            raise RuntimeError("UEFI selected but the machine is booted in BIOS mode.")
        base_required = [
            "wipefs", "sfdisk", "mount", "umount",
            "pacstrap", "genfstab", "arch-chroot", "blkid", "partprobe", "udevadm", "pacman"
        ]
        missing = [c for c in base_required if not cmd_ok(c)]
        if missing:
            raise RuntimeError("Missing required commands on Live ISO:\n" + "\n".join(missing))
        if boot_mode == "UEFI":
            for c in ["sgdisk", "mkfs.fat", "bootctl"]:
                if not cmd_ok(c):
                    raise RuntimeError(f"UEFI mode missing required command on Live ISO: {c}")

        L("== StormOS / Arch Easy Installer ==")
        L(f"Install mode: {p.install_mode}")
        L(f"Boot mode: {boot_mode} (selection: {p.boot_mode_choice})")
        L(f"Desktop: {p.desktop_choice}  (DM: {dm})")
        L(f"Disk: {p.disk}")
        if p.install_mode == MODE_EXISTING:
            L(f"Root partition: {p.root_part}")
            if boot_mode == "UEFI":
                L(f"EFI partition: {p.esp_part}")
            L(f"Format root: {'YES' if p.format_root else 'NO'}")
            if boot_mode == "UEFI":
                L(f"Format EFI: {'YES' if p.format_esp else 'NO'}")
        L(f"Saved log: {LOG_FILE}")
        L("")
        P(2)

        L("== Step 0/14: Enabling multilib on Live ISO ==")
        ensure_multilib_enabled_live(L)
        P(4)

        L("== Step 1/14: Preparing mountpoint ==")
        safe_umount_recursive(p.mountpoint)
        ensure_dir(Path(p.mountpoint))
        P(6)

        # Determine root FS if not formatting in existing mode
        if p.install_mode == MODE_EXISTING and not p.format_root:
            detected = blkid_fstype(p.root_part)
            if not detected:
                raise RuntimeError("Could not detect existing root filesystem (blkid TYPE empty).")
            fs_root = detected
        else:
            fs_root = fs_selected

        # mkfs requirements
        if p.install_mode == MODE_ERASE or (p.install_mode == MODE_EXISTING and p.format_root):
            if fs_root == "btrfs" and not cmd_ok("mkfs.btrfs"):
                raise RuntimeError("Selected btrfs but mkfs.btrfs is missing on the Live ISO.")
            if fs_root == "xfs" and not cmd_ok("mkfs.xfs"):
                raise RuntimeError("Selected xfs but mkfs.xfs is missing on the Live ISO.")

        target_root = Path(p.mountpoint)

        # ----------------------------
        # Partition / format / mount
        # ----------------------------
        if p.install_mode == MODE_ERASE:
            L("== Step 2/14: Partitioning disk (ERASE MODE) ==")
            subprocess.run(["wipefs", "-a", p.disk], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)

            if boot_mode == "UEFI":
                L("$ sgdisk --zap-all DISK")
                rc = run_stream(["sgdisk", "--zap-all", p.disk], L, timeout=60)
                if rc != 0:
                    raise RuntimeError(f"sgdisk --zap-all failed (rc={rc})")
                L("Creating GPT partitions: EFI (1GiB) + ROOT (rest)")
                rc = run_stream(["sgdisk", "-n", "1:0:+1G", "-t", "1:EF00", "-c", "1:EFI", p.disk], L, timeout=60)
                if rc != 0:
                    raise RuntimeError(f"sgdisk create EFI failed (rc={rc})")
                rc = run_stream(["sgdisk", "-n", "2:0:0", "-t", "2:8300", "-c", "2:ROOT", p.disk], L, timeout=60)
                if rc != 0:
                    raise RuntimeError(f"sgdisk create ROOT failed (rc={rc})")
            else:
                L("Creating MBR partition table: 1x Linux partition (bootable)")
                sfdisk_script = "label: dos\nunit: sectors\n"
                sfdisk_script += f"{p.disk}1 : start=2048, type=83, bootable\n"
                rc = run_stream(["sfdisk", p.disk], L, timeout=60, input_text=sfdisk_script)
                if rc != 0:
                    raise RuntimeError(f"sfdisk failed (rc={rc})")

            subprocess.run(["partprobe", p.disk], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            subprocess.run(["udevadm", "settle"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            time.sleep(1.0)

            if boot_mode == "UEFI":
                esp = partition_path(p.disk, 1)
                rootp = partition_path(p.disk, 2)
            else:
                esp = ""
                rootp = partition_path(p.disk, 1)

            if not Path(rootp).exists():
                subprocess.run(["udevadm", "settle"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                time.sleep(1.0)
                if not Path(rootp).exists():
                    raise RuntimeError(f"Partition device not found: {rootp}")
            if boot_mode == "UEFI" and (not esp or not Path(esp).exists()):
                subprocess.run(["udevadm", "settle"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                time.sleep(1.0)
                if boot_mode == "UEFI" and (not esp or not Path(esp).exists()):
                    raise RuntimeError(f"EFI partition device not found: {esp}")
            P(14)

            L("== Step 3/14: Formatting filesystems ==")
            if boot_mode == "UEFI":
                rc = run_stream(["mkfs.fat", "-F32", "-n", "EFI", esp], L, timeout=120)
                if rc != 0:
                    raise RuntimeError(f"mkfs.fat failed (rc={rc})")

            if fs_root == "ext4":
                rc = run_stream(["mkfs.ext4", "-F", "-L", "ROOT", rootp], L, timeout=300)
            elif fs_root == "btrfs":
                rc = run_stream(["mkfs.btrfs", "-f", "-L", "ROOT", rootp], L, timeout=300)
            else:
                rc = run_stream(["mkfs.xfs", "-f", "-L", "ROOT", rootp], L, timeout=300)
            if rc != 0:
                raise RuntimeError(f"mkfs for {fs_root} failed (rc={rc})")
            P(24)

            L("== Step 4/14: Mounting target ==")
            if fs_root == "btrfs":
                rc = run_stream(["mount", rootp, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs temp) failed")
                run_stream(["btrfs", "subvolume", "create", f"{p.mountpoint}/@"], L, timeout=60)
                run_stream(["btrfs", "subvolume", "create", f"{p.mountpoint}/@home"], L, timeout=60)
                run_stream(["umount", p.mountpoint], L, timeout=60)
                ensure_dir(Path(p.mountpoint))
                rc = run_stream(["mount", "-o", "subvol=@,compress=zstd:1", rootp, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs @) failed")
                ensure_dir(Path(p.mountpoint) / "home")
                rc = run_stream(["mount", "-o", "subvol=@home,compress=zstd:1", rootp, f"{p.mountpoint}/home"], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs @home) failed")
            else:
                rc = run_stream(["mount", rootp, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount root failed")

            ensure_dir(Path(p.mountpoint) / "boot")
            if boot_mode == "UEFI":
                rc = run_stream(["mount", esp, f"{p.mountpoint}/boot"], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount EFI failed")
            P(32)

        else:
            L("== Step 2/14: Using existing partitions (NO disk wipe) ==")
            if not p.root_part or not Path(p.root_part).exists():
                raise RuntimeError("Root partition not selected or does not exist.")
            if boot_mode == "UEFI":
                if not p.esp_part or not Path(p.esp_part).exists():
                    raise RuntimeError("UEFI install requires selecting an EFI partition (FAT32).")
            P(10)

            L("== Step 3/14: Optional formatting (existing partitions) ==")
            if p.format_root:
                L(f"Formatting ROOT {p.root_part} as {fs_root}…")
                if fs_root == "ext4":
                    rc = run_stream(["mkfs.ext4", "-F", "-L", "ROOT", p.root_part], L, timeout=300)
                elif fs_root == "btrfs":
                    rc = run_stream(["mkfs.btrfs", "-f", "-L", "ROOT", p.root_part], L, timeout=300)
                else:
                    rc = run_stream(["mkfs.xfs", "-f", "-L", "ROOT", p.root_part], L, timeout=300)
                if rc != 0:
                    raise RuntimeError(f"mkfs for {fs_root} failed (rc={rc})")
            else:
                L("Keeping existing ROOT filesystem (no format).")

            if boot_mode == "UEFI":
                if p.format_esp:
                    L(f"Formatting EFI {p.esp_part} as FAT32…")
                    rc = run_stream(["mkfs.fat", "-F32", "-n", "EFI", p.esp_part], L, timeout=120)
                    if rc != 0:
                        raise RuntimeError(f"mkfs.fat failed (rc={rc})")
                else:
                    L("Keeping existing EFI filesystem (no format).")
            P(24)

            L("== Step 4/14: Mounting existing partitions ==")
            if fs_root == "btrfs" and p.format_root:
                rc = run_stream(["mount", p.root_part, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs temp) failed")
                run_stream(["btrfs", "subvolume", "create", f"{p.mountpoint}/@"], L, timeout=60)
                run_stream(["btrfs", "subvolume", "create", f"{p.mountpoint}/@home"], L, timeout=60)
                run_stream(["umount", p.mountpoint], L, timeout=60)
                ensure_dir(Path(p.mountpoint))
                rc = run_stream(["mount", "-o", "subvol=@,compress=zstd:1", p.root_part, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs @) failed")
                ensure_dir(Path(p.mountpoint) / "home")
                rc = run_stream(["mount", "-o", "subvol=@home,compress=zstd:1", p.root_part, f"{p.mountpoint}/home"], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount (btrfs @home) failed")
            else:
                rc = run_stream(["mount", p.root_part, p.mountpoint], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount root failed")

            ensure_dir(Path(p.mountpoint) / "boot")
            if boot_mode == "UEFI":
                rc = run_stream(["mount", p.esp_part, f"{p.mountpoint}/boot"], L, timeout=60)
                if rc != 0:
                    raise RuntimeError("mount EFI failed")
            P(32)

        # ----------------------------
        # pacstrap
        # ----------------------------
        L("== Step 5/14: Installing packages (pacstrap) ==")
        pkgs, src_desc = choose_package_list(
            boot_mode=boot_mode,
            desktop_choice=p.desktop_choice,
            want_yay=p.install_yay,
            fs=fs_root,
            use_local_packages_txt=p.use_local_packages_txt,
            use_github_packages_list=p.use_github_packages_list,
            log=L
        )
        L(f"Package source: {src_desc}")
        pacman_sync_live(L)

        pkgs_ok, pkgs_missing = filter_available_repo_packages(pkgs, L)
        if pkgs_missing:
            L("")
            L("!! Packages NOT available in current repos and will be skipped (prevents pacstrap failure):")
            for m in pkgs_missing[:250]:
                L(f"   - {m}")
            if len(pkgs_missing) > 250:
                L(f"   ... and {len(pkgs_missing) - 250} more")
            L("")
        pkgs = pkgs_ok
        if not pkgs:
            raise RuntimeError("After filtering, package list is empty. Check repos/internet.")
        L("Packages to pacstrap:")
        L("  " + " ".join(pkgs))
        rc = run_stream(["pacstrap", "-K", p.mountpoint, "--needed"] + pkgs, L, timeout=None)
        if rc != 0:
            raise RuntimeError(f"pacstrap failed (rc={rc}). Check internet/mirrors.")
        P(58)

        # ----------------------------
        # multilib in target
        # ----------------------------
        L("== Step 5.5/14: Enabling multilib in installed system ==")
        ensure_multilib_enabled_target(target_root, L)
        arch_chroot(target_root, "pacman -Syy --noconfirm", L)
        P(62)

        # ----------------------------
        # Optional zst installs
        # ----------------------------
        L("== Step 6/14: Installing extra .pkg.tar.zst packages (optional) ==")
        if p.install_github_zst_packages and GITHUB_ZST_BLOB_URLS:
            stash = target_root / "root" / "stormos-zst"
            ensure_dir(stash)
            downloaded = []
            for u in GITHUB_ZST_BLOB_URLS:
                name = Path(u.split("?", 1)[0]).name
                dest = stash / name
                download_file(u, dest, L, timeout=240)
                downloaded.append("/root/stormos-zst/" + name)
            arch_chroot(target_root, "pacman -Sy --noconfirm", L)
            arch_chroot(target_root, "pacman -U --noconfirm " + " ".join(shlex.quote(x) for x in downloaded), L)
            L("Extra .zst packages installed.")
        else:
            L("Skipping extra .zst packages.")
        P(70)

        # ----------------------------
        # fstab
        # ----------------------------
        L("== Step 7/14: Generating fstab ==")
        cp = subprocess.run(["genfstab", "-U", p.mountpoint],
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        if cp.returncode != 0:
            raise RuntimeError("genfstab failed:\n" + (cp.stdout or ""))
        fstab_path = target_root / "etc" / "fstab"
        ensure_dir(fstab_path.parent)
        fstab_path.write_text((cp.stdout or ""), encoding="utf-8", errors="ignore")
        P(74)

        # ----------------------------
        # Personalization
        # ----------------------------
        L("== Step 8/14: Personalization (defaults) ==")
        if p.do_skel:
            apply_skel_preset(target_root, L)
        else:
            ensure_dir(target_root / "etc" / "skel")

        if p.do_migrate_usr_local_bin:
            migrate_usr_local_bin(target_root, L)
        if p.do_migrate_usr_share_icons:
            migrate_usr_share_icons(target_root, L)

        # Wallpaper copy ALWAYS (keeps your requested destination)
        installed_wallpaper_path = ensure_wallpaper_from_host(target_root, L)

        if p.do_copy_stormos_wallpapers:
            copy_stormos_wallpapers_into_backgrounds(target_root, L)

        theme_name = choose_best_theme_name(target_root, preferred=p.default_theme_preferred)
        icon_theme = choose_best_icon_theme(target_root)

        write_default_gtk_settings_to_skel(target_root, theme_name=theme_name, icon_theme=icon_theme, log=L)

        # XFCE-only tweaks (safe to run even if non-XFCE; will mostly no-op)
        if p.desktop_choice == DE_XFCE and p.do_patch_xfce_wall:
            patch_xfce_wallpaper_in_skel(target_root, installed_wallpaper_path, L)
            install_firstboot_wallpaper_fix(target_root, installed_wallpaper_path, L)
            patch_xfce_icon_theme_in_skel(target_root, icon_theme, L)
        else:
            L("XFCE wallpaper/icon patch: skipped (non-XFCE desktop selected).")

        # LightDM greeter tweaks only if DM is LightDM
        if dm == DM_LIGHTDM and p.do_lightdm_greeter_tweaks:
            configure_lightdm_greeter(target_root, installed_wallpaper_path, L, theme_name=theme_name, icon_theme=icon_theme)
        else:
            L("LightDM greeter tweaks: skipped (not using LightDM).")
        P(80)

        # ----------------------------
        # System configuration
        # ----------------------------
        L("== Step 9/14: System configuration ==")
        hostname = sanitize_hostname(p.hostname)
        write_file(target_root / "etc" / "hostname", hostname + "\n")
        hosts = (
            "127.0.0.1\tlocalhost\n"
            "::1\t\tlocalhost\n"
            f"127.0.1.1\t{hostname}.localdomain\t{hostname}\n"
        )
        write_file(target_root / "etc" / "hosts", hosts)

        locale_gen = target_root / "etc" / "locale.gen"
        lg = read_text(locale_gen)
        if lg:
            loc = p.locale.strip()
            lg2 = re.sub(rf"^#\s*({re.escape(loc)}\.UTF-8)\s*$", r"\1", lg, flags=re.M)
            lg2 = re.sub(rf"^#\s*({re.escape(loc)}\s+UTF-8)\s*$", r"\1", lg2, flags=re.M)
            write_file(locale_gen, lg2)
        write_file(target_root / "etc" / "locale.conf", f"LANG={p.locale}.UTF-8\n")
        write_file(target_root / "etc" / "vconsole.conf", f"KEYMAP={p.keymap}\n")

        arch_chroot(target_root, f"ln -sf /usr/share/zoneinfo/{shlex.quote(p.timezone)} /etc/localtime", L)
        arch_chroot(target_root, "hwclock --systohc", L)
        arch_chroot(target_root, "locale-gen", L)

        arch_chroot(target_root, "systemctl enable NetworkManager", L)
        enable_display_manager(target_root, dm, L)

        arch_chroot(target_root, r"sed -i 's/^# %wheel ALL=(ALL:ALL) ALL/%wheel ALL=(ALL:ALL) ALL/' /etc/sudoers", L)
        P(86)

        # ----------------------------
        # User creation
        # ----------------------------
        L("== Step 10/14: Creating user ==")
        user = sanitize_username(p.username)
        arch_chroot(target_root, f"useradd -m -G wheel -s /bin/bash {shlex.quote(user)}", L)
        arch_chroot_input(target_root, "chpasswd", f"{user}:{p.password}\n", L)
        if p.set_root_password and p.root_password.strip():
            arch_chroot_input(target_root, "chpasswd", f"root:{p.root_password}\n", L)
        else:
            arch_chroot(target_root, "passwd -l root || true", L)

        if p.enable_autologin and dm == DM_LIGHTDM:
            enable_lightdm_autologin(target_root, user, L)
        elif p.enable_autologin:
            L("Autologin requested, but only LightDM autologin is configured by this installer (skipping).")
        P(90)

        # ----------------------------
        # yay (optional)
        # ----------------------------
        L("== Step 10.5/14: AUR helper (yay) (best-effort) ==")
        if p.install_yay:
            try:
                install_yay_best_effort(target_root, L)
            except Exception as e:
                L(f"!! AUR: yay install failed (continuing): {e}")
        else:
            L("Skipping yay (disabled).")
        P(92)

        # ----------------------------
        # Bootloader
        # ----------------------------
        L("== Step 11/14: Installing bootloader ==")
        micro = detect_microcode_pkg()
        if boot_mode == "UEFI":
            root_dev_for_partuuid = partition_path(p.disk, 2) if p.install_mode == MODE_ERASE else p.root_part
            arch_chroot(target_root, "bootctl --path=/boot install", L)
            loader_conf = (
                "default arch\n"
                "timeout 3\n"
                "console-mode max\n"
                "editor no\n"
            )
            write_file(target_root / "boot" / "loader" / "loader.conf", loader_conf)

            root_partuuid = blkid_partuuid(root_dev_for_partuuid)
            if not root_partuuid:
                raise RuntimeError("Failed to read PARTUUID for root partition.")

            initrd_lines = ""
            if micro == "intel-ucode":
                initrd_lines += "initrd  /intel-ucode.img\n"
            elif micro == "amd-ucode":
                initrd_lines += "initrd  /amd-ucode.img\n"
            initrd_lines += "initrd  /initramfs-linux.img\n"

            entry = (
                "title   Arch Linux (StormOS)\n"
                "linux   /vmlinuz-linux\n"
                f"{initrd_lines}"
                f"options root=PARTUUID={root_partuuid} rw quiet loglevel=3\n"
            )
            write_file(target_root / "boot" / "loader" / "entries" / "arch.conf", entry)
        else:
            arch_chroot(target_root, f"grub-install --target=i386-pc --recheck {shlex.quote(p.disk)}", L)
            arch_chroot(target_root, "grub-mkconfig -o /boot/grub/grub.cfg", L)
        P(98)

        # ----------------------------
        # Finalize
        # ----------------------------
        L("== Step 12/14: Finalizing ==")
        subprocess.run(["sync"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        P(100)
        L("")
        L("✅ INSTALL COMPLETE. You can reboot now.")

# ============================================================
# GUI helpers
# ============================================================
def make_scroll_page(content_widget: QWidget) -> QWidget:
    outer = QWidget()
    v = QVBoxLayout(outer)
    v.setContentsMargins(8, 8, 8, 8)
    scroll = QScrollArea()
    scroll.setWidgetResizable(True)
    scroll.setFrameShape(QScrollArea.NoFrame)
    inner = QWidget()
    inner_l = QVBoxLayout(inner)
    inner_l.setContentsMargins(6, 6, 6, 6)
    inner_l.addWidget(content_widget)
    inner_l.addStretch(1)
    scroll.setWidget(inner)
    v.addWidget(scroll, 1)
    return outer

# ============================================================
# GUI
# ============================================================
class Wizard(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("StormOS / Arch Easy Installer — Midnight Edition (UEFI + BIOS)")
        self.resize(980, 740)

        self.stack = QStackedWidget()
        self.setCentralWidget(self.stack)

        self.preflight: Optional[PreflightResult] = None
        self.preflight_thread: Optional[PreflightThread] = None
        self.install_thread: Optional[InstallThread] = None

        self.page_welcome = self._build_welcome()
        self.page_checks = self._build_checks()
        self.page_config = self._build_config()
        self.page_personalize = self._build_personalize()
        self.page_confirm = self._build_confirm()
        self.page_install = self._build_install()
        self.page_done = self._build_done()

        for pg in [self.page_welcome, self.page_checks, self.page_config, self.page_personalize,
                   self.page_confirm, self.page_install, self.page_done]:
            self.stack.addWidget(pg)

        QTimer.singleShot(0, self._go_welcome)

    def _title(self, text: str) -> QLabel:
        lab = QLabel(text)
        lab.setFont(QFont("Sans", 16, QFont.Bold))
        lab.setWordWrap(True)
        lab.setStyleSheet("QLabel { color: #dbe3ff; }")
        return lab

    def _danger_banner(self, text: str) -> QLabel:
        lab = QLabel(text)
        lab.setWordWrap(True)
        lab.setStyleSheet(
            "QLabel { background: #2a0c17; color: #ffd7e1; border: 2px solid #ff3b6b; "
            "border-radius: 14px; padding: 12px; font-weight: 900; }"
        )
        return lab

    def _accent_banner(self, text: str) -> QLabel:
        lab = QLabel(text)
        lab.setWordWrap(True)
        lab.setStyleSheet(
            "QLabel { background: #0f2144; color: #d7e8ff; border: 1px solid #2b77ff; "
            "border-radius: 14px; padding: 12px; font-weight: 800; }"
        )
        return lab

    # ----------------------------
    # Welcome
    # ----------------------------
    def _build_welcome(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("StormOS / Arch Easy Installer"))

        warn = QTextEdit()
        warn.setReadOnly(True)
        warn.setPlainText(
            "⚠️ WARNING — POTENTIALLY DESTRUCTIVE INSTALLER\n"
            "You can choose:\n"
            "• ERASE DISK (auto partition + format) — DESTROYS DATA\n"
            "• USE EXISTING PARTITIONS — no wipe unless you enable format\n\n"
            "NEW: Choose your Desktop Environment (XFCE/GNOME/Plasma/Cinnamon/MATE/LXQt).\n\n"
            "Saved installer log:\n"
            f"  {LOG_FILE}\n"
        )
        warn.setMinimumHeight(230)
        lay.addWidget(warn, 1)

        self.lbl_env = self._accent_banner("")
        lay.addWidget(self.lbl_env)

        row = QHBoxLayout()
        row.addStretch(1)
        btn_next = QPushButton("Next →")
        btn_next.setMinimumHeight(40)
        btn_next.setStyleSheet(
            "QPushButton { background: #2b77ff; border: 1px solid #6aa9ff; color: white; "
            "font-weight: 900; border-radius: 12px; padding: 10px 14px; }"
            "QPushButton:hover { background: #3a86ff; }"
            "QPushButton:pressed { background: #1e5fe0; }"
        )
        btn_next.clicked.connect(self._go_checks)
        row.addWidget(btn_next)
        lay.addLayout(row)
        return make_scroll_page(content)

    # ----------------------------
    # Preflight
    # ----------------------------
    def _build_checks(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Preflight Checks (no freezing)"))
        self.chk_log = QPlainTextEdit()
        self.chk_log.setReadOnly(True)
        self.chk_log.setMinimumHeight(280)
        lay.addWidget(self.chk_log, 1)

        row = QHBoxLayout()
        self.btn_checks_back = QPushButton("← Back")
        self.btn_checks_back.setMinimumHeight(40)
        self.btn_checks_back.clicked.connect(lambda: self.stack.setCurrentWidget(self.page_welcome))
        self.btn_checks_next = QPushButton("Continue →")
        self.btn_checks_next.setMinimumHeight(40)
        self.btn_checks_next.setEnabled(False)
        self.btn_checks_next.setStyleSheet(
            "QPushButton { background: #2b77ff; border: 1px solid #6aa9ff; color: white; font-weight: 900; }"
            "QPushButton:hover { background: #3a86ff; }"
            "QPushButton:disabled { background: #111829; border: 1px solid #1a2340; color: #7f87b8; }"
        )
        self.btn_checks_next.clicked.connect(self._go_config)
        row.addWidget(self.btn_checks_back)
        row.addStretch(1)
        row.addWidget(self.btn_checks_next)
        lay.addLayout(row)
        return make_scroll_page(content)

    def _append_checks(self, s: str):
        self.chk_log.appendPlainText(s)
        sb = self.chk_log.verticalScrollBar()
        sb.setValue(sb.maximum())

    def _go_checks(self):
        self.chk_log.clear()
        self.btn_checks_next.setEnabled(False)
        self.stack.setCurrentWidget(self.page_checks)
        self.preflight_thread = PreflightThread()
        self.preflight_thread.log.connect(self._append_checks)
        self.preflight_thread.done.connect(self._on_preflight_done)
        self.preflight_thread.start()

    def _on_preflight_done(self, res: PreflightResult):
        self.preflight = res
        self._append_checks("")
        self._append_checks("=== Results ===")
        self._append_checks(f"Root: {'OK' if res.root_ok else 'NO'}")
        self._append_checks(f"UEFI detected: {'YES' if res.uefi_detected else 'NO'}")
        self._append_checks(f"Internet: {'OK' if res.internet_ok else 'NOT detected'}")
        self._append_checks(res.wifi_line)

        if res.missing_base_tools:
            self._append_checks("")
            self._append_checks("Missing REQUIRED tools on the Live ISO:")
            for c in res.missing_base_tools:
                self._append_checks(f"  - {c}")
            self._append_checks("")
            self._append_checks("Fix the ISO contents, then try again.")
            self.btn_checks_next.setEnabled(False)
            return

        if not res.root_ok:
            self._append_checks("\nRun this installer with sudo/pkexec.")
            self.btn_checks_next.setEnabled(False)
            return

        if not res.disks:
            self._append_checks("\nNo disks found.")
            self.btn_checks_next.setEnabled(False)
            return

        self._append_checks("")
        self._append_checks(f"Disks found: {len(res.disks)}")
        for dev, size, model in res.disks:
            self._append_checks(f"  - {dev} {size} {model}".strip())
        self.btn_checks_next.setEnabled(True)

    # ----------------------------
    # Config page (install mode + disk + partitions + DE dropdown)
    # ----------------------------
    def _build_config(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Install Configuration"))

        box = QGroupBox("Basics")
        form = QFormLayout(box)

        self.cmb_desktop = QComboBox()
        self.cmb_desktop.addItems(ALL_DESKTOPS)
        self.cmb_desktop.setCurrentText(DE_XFCE)

        self.cmb_install_mode = QComboBox()
        self.cmb_install_mode.addItems([MODE_ERASE, MODE_EXISTING])

        self.cmb_boot = QComboBox()
        self.cmb_boot.addItems([BOOT_AUTO, BOOT_UEFI, BOOT_BIOS])

        self.cmb_fs = QComboBox()
        self.cmb_fs.addItems([FS_EXT4, FS_BTRFS, FS_XFS])

        disk_row = QHBoxLayout()
        self.cmb_disk = QComboBox()
        self.btn_refresh_disks = QPushButton("Refresh")
        self.btn_refresh_disks.setMinimumHeight(36)
        self.btn_refresh_disks.clicked.connect(self._refresh_disks)
        disk_row.addWidget(self.cmb_disk, 1)
        disk_row.addWidget(self.btn_refresh_disks)

        self.cmb_root_part = QComboBox()
        self.cmb_esp_part = QComboBox()

        self.chk_format_root = QCheckBox("Format ROOT partition")
        self.chk_format_root.setChecked(True)

        self.chk_format_esp = QCheckBox("Format EFI partition (FAT32)")
        self.chk_format_esp.setChecked(False)

        self.ed_hostname = QLineEdit("stormos")
        self.ed_user = QLineEdit("seeker")

        self.ed_pass = QLineEdit("")
        self.ed_pass.setEchoMode(QLineEdit.Password)

        self.chk_root = QCheckBox("Set root password (optional)")
        self.ed_rootpass = QLineEdit("")
        self.ed_rootpass.setEchoMode(QLineEdit.Password)
        self.ed_rootpass.setEnabled(False)
        self.chk_root.stateChanged.connect(lambda st: self.ed_rootpass.setEnabled(st == Qt.Checked))

        self.cmb_tz = QComboBox()
        self.cmb_tz.setEditable(True)
        self.cmb_tz.addItems(list_timezones_lite())
        self.cmb_tz.setCurrentText(guess_live_timezone())
        btn_tz_detect = QPushButton("Detect")
        btn_tz_detect.setMinimumHeight(36)
        btn_tz_detect.clicked.connect(lambda: self.cmb_tz.setCurrentText(guess_live_timezone()))
        tz_row = QHBoxLayout()
        tz_row.addWidget(self.cmb_tz, 1)
        tz_row.addWidget(btn_tz_detect)

        self.cmb_locale = QComboBox()
        self.cmb_locale.setEditable(True)
        self.cmb_locale.addItems(["en_US", "en_GB", "es_ES", "fr_FR", "de_DE", "it_IT", "pt_BR", "ru_RU", "pl_PL", "nl_NL"])
        self.cmb_locale.setCurrentText("en_US")

        self.cmb_keymap = QComboBox()
        self.cmb_keymap.setEditable(True)
        self.cmb_keymap.addItems(common_keymaps())
        self.cmb_keymap.setCurrentText(guess_live_keymap())
        btn_km_detect = QPushButton("Detect")
        btn_km_detect.setMinimumHeight(36)
        btn_km_detect.clicked.connect(lambda: self.cmb_keymap.setCurrentText(guess_live_keymap()))
        km_row = QHBoxLayout()
        km_row.addWidget(self.cmb_keymap, 1)
        km_row.addWidget(btn_km_detect)

        form.addRow("Desktop Environment:", self.cmb_desktop)
        form.addRow("Install mode:", self.cmb_install_mode)
        form.addRow("Boot mode:", self.cmb_boot)
        form.addRow("Filesystem (used when formatting ROOT):", self.cmb_fs)
        form.addRow("Target disk:", disk_row)
        form.addRow("ROOT partition (existing):", self.cmb_root_part)
        form.addRow("EFI partition (existing, UEFI only):", self.cmb_esp_part)
        form.addRow("", self.chk_format_root)
        form.addRow("", self.chk_format_esp)
        form.addRow("Hostname:", self.ed_hostname)
        form.addRow("Username:", self.ed_user)
        form.addRow("User password:", self.ed_pass)
        rr = QHBoxLayout()
        rr.addWidget(self.chk_root)
        rr.addWidget(self.ed_rootpass, 1)
        form.addRow("Root:", rr)
        form.addRow("Timezone:", tz_row)
        form.addRow("Locale (no .UTF-8):", self.cmb_locale)
        form.addRow("Keymap:", km_row)

        lay.addWidget(box)

        self.lbl_config_hint = QLabel("")
        self.lbl_config_hint.setWordWrap(True)
        self.lbl_config_hint.setStyleSheet("QLabel { color: #b8c2ff; }")
        lay.addWidget(self.lbl_config_hint)

        self.cmb_install_mode.currentIndexChanged.connect(self._update_mode_visibility)
        self.cmb_disk.currentIndexChanged.connect(self._refresh_partitions_for_selected_disk)
        self.cmb_boot.currentIndexChanged.connect(self._update_mode_visibility)
        self.chk_format_root.stateChanged.connect(self._update_fs_enabled)

        row = QHBoxLayout()
        btn_back = QPushButton("← Back")
        btn_back.setMinimumHeight(40)
        btn_back.clicked.connect(lambda: self.stack.setCurrentWidget(self.page_checks))
        btn_next = QPushButton("Next →")
        btn_next.setMinimumHeight(40)
        btn_next.setStyleSheet(
            "QPushButton { background: #2b77ff; border: 1px solid #6aa9ff; color: white; font-weight: 900; }"
            "QPushButton:hover { background: #3a86ff; }"
        )
        btn_next.clicked.connect(self._go_personalize)

        row.addWidget(btn_back)
        row.addStretch(1)
        row.addWidget(btn_next)
        lay.addLayout(row)

        return make_scroll_page(content)

    def _refresh_disks(self):
        disks = list_disks()
        cur = self.cmb_disk.currentData()
        self.cmb_disk.blockSignals(True)
        self.cmb_disk.clear()
        for dev, size, model in disks:
            self.cmb_disk.addItem(f"{dev} — {size} — {model}".strip(" —"), dev)
        if cur:
            idx = self.cmb_disk.findData(cur)
            if idx >= 0:
                self.cmb_disk.setCurrentIndex(idx)
        self.cmb_disk.blockSignals(False)
        self._refresh_partitions_for_selected_disk()
        self._update_mode_visibility()

    def _update_fs_enabled(self):
        is_existing = (self.cmb_install_mode.currentText() == MODE_EXISTING)
        self.cmb_fs.setEnabled(True if not is_existing else self.chk_format_root.isChecked())

    def _update_mode_visibility(self):
        is_existing = (self.cmb_install_mode.currentText() == MODE_EXISTING)
        eff_mode = effective_boot_mode(self.cmb_boot.currentText())

        self.cmb_root_part.setVisible(is_existing)
        self.chk_format_root.setVisible(is_existing)

        self.cmb_esp_part.setVisible(is_existing and eff_mode == "UEFI")
        self.chk_format_esp.setVisible(is_existing and eff_mode == "UEFI")

        if not (is_existing and eff_mode == "UEFI"):
            self.cmb_esp_part.setCurrentIndex(-1)

        self._update_fs_enabled()

        if is_existing:
            self.lbl_config_hint.setText(
                "Existing partitions mode:\n"
                "• Select ROOT (required)\n"
                "• If UEFI: select EFI partition (required) mounted to /boot\n"
                "• Formatting is optional (recommended for a clean install)."
            )
        else:
            self.lbl_config_hint.setText(
                "Erase disk mode:\n"
                "• The installer will wipe the entire disk and create partitions automatically."
            )

    def _refresh_partitions_for_selected_disk(self):
        disk = self.cmb_disk.currentData()
        if not disk:
            return
        parts = list_partitions_for_disk(disk)

        def label_for(p):
            dev, size, fstype, mnt, plabel, ptype = p
            pieces = [dev, size]
            if fstype:
                pieces.append(fstype)
            if plabel:
                pieces.append(f"label={plabel}")
            if mnt:
                pieces.append(f"mnt={mnt}")
            if ptype:
                pieces.append(f"type={ptype}")
            return " — ".join(pieces)

        self.cmb_root_part.blockSignals(True)
        self.cmb_root_part.clear()
        for p in parts:
            dev = p[0]
            self.cmb_root_part.addItem(label_for(p), dev)
        self.cmb_root_part.blockSignals(False)

        self.cmb_esp_part.blockSignals(True)
        self.cmb_esp_part.clear()
        for p in parts:
            dev, size, fstype, mnt, plabel, ptype = p
            is_efi = (fstype.lower() == "vfat") or ("ef00" in (ptype or "").lower()) or ("efi" in (plabel or "").lower())
            if is_efi:
                self.cmb_esp_part.addItem(label_for(p), dev)
        self.cmb_esp_part.blockSignals(False)

        if self.cmb_root_part.count() > 0:
            self.cmb_root_part.setCurrentIndex(0)
        if self.cmb_esp_part.count() > 0:
            self.cmb_esp_part.setCurrentIndex(0)

        self._update_mode_visibility()

    def _go_config(self):
        if not self.preflight:
            return
        self._refresh_disks()
        self._update_mode_visibility()
        self.stack.setCurrentWidget(self.page_config)

    # ----------------------------
    # Personalize page
    # ----------------------------
    def _build_personalize(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Personalization + Packages"))

        box = QGroupBox("Carry these to the installed system")
        v = QVBoxLayout(box)
        self.chk_skel = QCheckBox("Copy my preset settings (/etc/skel)")
        self.chk_skel.setChecked(True)
        self.chk_copy_storm_walls = QCheckBox("Copy StormOS wallpapers pack (/usr/share/backgrounds/StormOS) if present")
        self.chk_copy_storm_walls.setChecked(True)
        self.chk_patch_wall = QCheckBox("Copy LIVE/HOST wallpaper into installed system at /usr/share/backgrounds/xfce/xfce-x.<ext>")
        self.chk_patch_wall.setChecked(True)
        self.chk_lightdm = QCheckBox("If using LightDM: set greeter background + theme/icons (best-effort)")
        self.chk_lightdm.setChecked(True)
        self.chk_migrate_localbin = QCheckBox("Migrate LIVE /usr/local/bin -> installed system /usr/local/bin")
        self.chk_migrate_localbin.setChecked(True)
        self.chk_migrate_icons = QCheckBox("Migrate LIVE /usr/share/icons -> installed system /usr/share/icons")
        self.chk_migrate_icons.setChecked(True)

        v.addWidget(self.chk_skel)
        v.addWidget(self.chk_copy_storm_walls)
        v.addWidget(self.chk_patch_wall)
        v.addWidget(self.chk_lightdm)
        v.addWidget(self.chk_migrate_localbin)
        v.addWidget(self.chk_migrate_icons)
        lay.addWidget(box)

        pkgbox = QGroupBox("Programs / Packages")
        pv = QVBoxLayout(pkgbox)
        self.chk_pkgs_local = QCheckBox("Use local /etc/stormos/packages.txt (if present)")
        self.chk_pkgs_local.setChecked(True)
        self.chk_pkgs_github = QCheckBox("Use GitHub packages list if local list missing (recommended)")
        self.chk_pkgs_github.setChecked(True)
        self.chk_zst = QCheckBox("Install adw-gtk-theme-git .pkg.tar.zst from GitHub (internet required)")
        self.chk_zst.setChecked(True)
        self.chk_yay = QCheckBox("Install yay (AUR helper) (best-effort)")
        self.chk_yay.setChecked(True)
        self.chk_autologin = QCheckBox("LightDM FAILSAFE: Enable autologin (LightDM only)")
        self.chk_autologin.setChecked(False)

        pv.addWidget(self.chk_pkgs_local)
        pv.addWidget(self.chk_pkgs_github)
        pv.addWidget(self.chk_zst)
        pv.addSpacing(8)
        pv.addWidget(self.chk_yay)
        pv.addSpacing(8)
        pv.addWidget(self.chk_autologin)
        lay.addWidget(pkgbox)

        self.lbl_personalize_status = QLabel("")
        self.lbl_personalize_status.setWordWrap(True)
        self.lbl_personalize_status.setStyleSheet("QLabel { color: #b8c2ff; }")
        lay.addWidget(self.lbl_personalize_status)

        row = QHBoxLayout()
        btn_back = QPushButton("← Back")
        btn_back.setMinimumHeight(40)
        btn_back.clicked.connect(lambda: self.stack.setCurrentWidget(self.page_config))
        btn_next = QPushButton("Next →")
        btn_next.setMinimumHeight(40)
        btn_next.setStyleSheet(
            "QPushButton { background: #2b77ff; border: 1px solid #6aa9ff; color: white; font-weight: 900; }"
            "QPushButton:hover { background: #3a86ff; }"
        )
        btn_next.clicked.connect(self._go_confirm)
        row.addWidget(btn_back)
        row.addStretch(1)
        row.addWidget(btn_next)
        lay.addLayout(row)

        return make_scroll_page(content)

    def _go_personalize(self):
        status = []
        status.append(f"/etc/skel: {'FOUND' if LIVE_SKEL.exists() else 'NOT FOUND'}")
        status.append(f"StormOS wallpapers: {'FOUND' if Path('/usr/share/backgrounds/StormOS').exists() else 'NOT FOUND'}")
        status.append(f"packages.txt: {'FOUND' if LIVE_PKG_LIST.exists() else 'NOT FOUND'}")
        status.append(f"/usr/share/icons: {'FOUND' if Path('/usr/share/icons').exists() else 'NOT FOUND'}")
        status.append(wifi_status_line())
        status.append(f"Desktop selected: {self.cmb_desktop.currentText()} (DM: {desktop_to_dm(self.cmb_desktop.currentText())})")
        self.lbl_personalize_status.setText(" | ".join(status))

        if not LIVE_SKEL.exists():
            self.chk_skel.setChecked(False)
            self.chk_skel.setEnabled(False)
        else:
            self.chk_skel.setEnabled(True)

        if not Path("/usr/share/icons").exists():
            self.chk_migrate_icons.setChecked(False)
            self.chk_migrate_icons.setEnabled(False)
        else:
            self.chk_migrate_icons.setEnabled(True)

        self.stack.setCurrentWidget(self.page_personalize)

    # ----------------------------
    # Confirm page
    # ----------------------------
    def _build_confirm(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Confirm (LAST CHANCE)"))
        self.banner = self._danger_banner("DANGER: Confirm your action.")
        lay.addWidget(self.banner)

        self.summary = QPlainTextEdit()
        self.summary.setReadOnly(True)
        self.summary.setMinimumHeight(220)
        lay.addWidget(self.summary, 1)

        self.chk_confirm_1 = QCheckBox("I understand the selected action may DESTROY data.")
        self.chk_confirm_2 = QCheckBox("I backed up everything important.")
        self.chk_confirm_3 = QCheckBox("I am selecting the correct disk/partitions and accept the consequences.")
        for c in (self.chk_confirm_1, self.chk_confirm_2, self.chk_confirm_3):
            c.setStyleSheet("QCheckBox { font-weight: 900; }")
            lay.addWidget(c)

        lay.addSpacing(8)

        self.lbl_type = QLabel("Type the required word to unlock INSTALL:")
        self.lbl_type.setStyleSheet("QLabel { color: #ffd7e1; font-weight: 800; }")
        lay.addWidget(self.lbl_type)

        self.ed_type = QLineEdit("")
        self.ed_type.setPlaceholderText("ERASE / FORMAT / INSTALL")
        self.ed_type.setStyleSheet(
            "QLineEdit { font-size: 20px; padding: 12px; background: #101a34; "
            "border: 2px solid #ff3b6b; border-radius: 14px; color: #ffffff; }"
            "QLineEdit:focus { border: 2px solid #ff6b9a; }"
        )
        lay.addWidget(self.ed_type)

        row = QHBoxLayout()
        btn_back = QPushButton("← Back")
        btn_back.setMinimumHeight(44)
        btn_back.clicked.connect(lambda: self.stack.setCurrentWidget(self.page_personalize))

        self.btn_install = QPushButton("INSTALL")
        self.btn_install.setMinimumHeight(48)
        self.btn_install.setEnabled(False)
        self.btn_install.setStyleSheet(
            "QPushButton { background: #c1121f; color: white; font-weight: 900; font-size: 16px; "
            "border: 1px solid #ff3b6b; border-radius: 14px; padding: 12px 16px; }"
            "QPushButton:hover { background: #d01a28; }"
            "QPushButton:pressed { background: #a80f19; }"
            "QPushButton:disabled { background: #3a1017; border: 1px solid #4a1a22; color: #b58b93; }"
        )
        self.btn_install.clicked.connect(self._start_install)
        row.addWidget(btn_back)
        row.addStretch(1)
        row.addWidget(self.btn_install)
        lay.addLayout(row)

        def _force_upper(s: str):
            u = s.upper()
            if u != s:
                pos = self.ed_type.cursorPosition()
                self.ed_type.blockSignals(True)
                self.ed_type.setText(u)
                self.ed_type.setCursorPosition(pos)
                self.ed_type.blockSignals(False)
            self._validate_confirm()

        self.ed_type.textChanged.connect(_force_upper)
        self.chk_confirm_1.stateChanged.connect(self._validate_confirm)
        self.chk_confirm_2.stateChanged.connect(self._validate_confirm)
        self.chk_confirm_3.stateChanged.connect(self._validate_confirm)
        return make_scroll_page(content)

    def _required_confirm_word(self) -> str:
        install_mode = self.cmb_install_mode.currentText()
        eff_boot = effective_boot_mode(self.cmb_boot.currentText())
        if install_mode == MODE_ERASE:
            return "ERASE"
        fmt_root = self.chk_format_root.isChecked()
        fmt_efi = self.chk_format_esp.isChecked() if eff_boot == "UEFI" else False
        if fmt_root or fmt_efi:
            return "FORMAT"
        return "INSTALL"

    def _validate_confirm(self):
        ok_checks = self.chk_confirm_1.isChecked() and self.chk_confirm_2.isChecked() and self.chk_confirm_3.isChecked()
        required = self._required_confirm_word()
        ok_word = self.ed_type.text().strip().upper() == required
        self.btn_install.setEnabled(ok_checks and ok_word)

    def _build_plan(self) -> InstallPlan:
        disk = self.cmb_disk.currentData()
        if not disk:
            raise RuntimeError("No disk selected.")
        install_mode = self.cmb_install_mode.currentText()
        boot_choice = self.cmb_boot.currentText()
        fs_choice = self.cmb_fs.currentText()
        desktop_choice = self.cmb_desktop.currentText()

        eff_boot = effective_boot_mode(boot_choice)
        root_part = ""
        esp_part = ""
        format_root = True
        format_esp = False
        if install_mode == MODE_EXISTING:
            root_part = self.cmb_root_part.currentData() or ""
            if not root_part:
                raise RuntimeError("Existing partitions mode: select a ROOT partition.")
            if eff_boot == "UEFI":
                esp_part = self.cmb_esp_part.currentData() or ""
                if not esp_part:
                    raise RuntimeError("Existing partitions mode (UEFI): select an EFI partition.")
            format_root = self.chk_format_root.isChecked()
            format_esp = self.chk_format_esp.isChecked() if eff_boot == "UEFI" else False

        hostname = sanitize_hostname(self.ed_hostname.text())
        user = sanitize_username(self.ed_user.text())
        pw = self.ed_pass.text()
        if len(pw) < 4:
            raise RuntimeError("Password too short (minimum 4 characters).")

        tz = (self.cmb_tz.currentText() or "").strip() or "UTC"
        loc = (self.cmb_locale.currentText() or "").strip() or "en_US"
        keymap = (self.cmb_keymap.currentText() or "").strip() or "us"
        set_root = self.chk_root.isChecked()
        rootpw = self.ed_rootpass.text() if set_root else ""

        dm = desktop_to_dm(desktop_choice)
        enable_autologin = self.chk_autologin.isChecked()
        if enable_autologin and dm != DM_LIGHTDM:
            # don't block; just inform later (installer will skip)
            pass

        return InstallPlan(
            install_mode=install_mode,
            disk=disk,
            boot_mode_choice=boot_choice,
            fs_choice=fs_choice,
            desktop_choice=desktop_choice,
            root_part=root_part,
            esp_part=esp_part,
            format_root=format_root,
            format_esp=format_esp,
            hostname=hostname,
            username=user,
            password=pw,
            timezone=tz,
            locale=loc,
            keymap=keymap,
            set_root_password=set_root,
            root_password=rootpw,
            do_skel=self.chk_skel.isChecked(),
            do_copy_stormos_wallpapers=self.chk_copy_storm_walls.isChecked(),
            do_lightdm_greeter_tweaks=self.chk_lightdm.isChecked(),
            do_patch_xfce_wall=self.chk_patch_wall.isChecked(),
            do_migrate_usr_local_bin=self.chk_migrate_localbin.isChecked(),
            do_migrate_usr_share_icons=self.chk_migrate_icons.isChecked(),
            use_local_packages_txt=self.chk_pkgs_local.isChecked(),
            use_github_packages_list=self.chk_pkgs_github.isChecked(),
            install_github_zst_packages=self.chk_zst.isChecked(),
            enable_autologin=enable_autologin,
            install_yay=self.chk_yay.isChecked(),
            default_theme_preferred="adw-gtk-dark",
        )

    def _go_confirm(self):
        try:
            p = self._build_plan()
        except Exception as e:
            QMessageBox.critical(self, "Invalid settings", str(e))
            return

        boot_mode = effective_boot_mode(p.boot_mode_choice)
        required_word = self._required_confirm_word()
        self.lbl_type.setText(f"Type the required word to unlock INSTALL:  {required_word}")

        if p.install_mode == MODE_ERASE:
            self.banner.setText(
                "DANGER: This WILL ERASE the selected disk.\n"
                "There is NO undo.\n"
                "To enable INSTALL:\n"
                "• Check all confirmations\n"
                f"• Type {required_word}"
            )
            self.btn_install.setText("INSTALL (ERASE DISK)")
        else:
            if required_word == "FORMAT":
                self.banner.setText(
                    "WARNING: Existing partitions selected, but formatting is ENABLED.\n"
                    "Formatting DESTROYS data on the selected partition(s).\n"
                    "To enable INSTALL:\n"
                    "• Check all confirmations\n"
                    f"• Type {required_word}"
                )
                self.btn_install.setText("INSTALL (FORMAT PARTITIONS)")
            else:
                self.banner.setText(
                    "Existing partitions selected with NO formatting.\n"
                    "Installer will mount and install without wiping.\n"
                    "To enable INSTALL:\n"
                    "• Check all confirmations\n"
                    f"• Type {required_word}"
                )
                self.btn_install.setText("INSTALL (NO FORMAT)")

        dm = desktop_to_dm(p.desktop_choice)
        summary = []
        summary.append("INSTALL SUMMARY\n")
        summary.append(f"Desktop: {p.desktop_choice} (DM: {dm})")
        summary.append(f"Install mode: {p.install_mode}")
        summary.append(f"Boot mode: {boot_mode} (selection: {p.boot_mode_choice})")
        summary.append(f"Disk: {p.disk}")
        summary.append(f"Filesystem choice: {effective_fs(p.fs_choice)} (used only if formatting ROOT)")
        if p.install_mode == MODE_EXISTING:
            summary.append("")
            summary.append(f"ROOT: {p.root_part}")
            summary.append(f"Format ROOT: {'YES' if p.format_root else 'NO'}")
            if boot_mode == "UEFI":
                summary.append(f"EFI: {p.esp_part}")
                summary.append(f"Format EFI: {'YES' if p.format_esp else 'NO'}")
        summary.append("")
        summary.append(f"Hostname: {p.hostname}")
        summary.append(f"User: {p.username}")
        summary.append(f"Timezone: {p.timezone}")
        summary.append(f"Locale: {p.locale}.UTF-8")
        summary.append(f"Keymap: {p.keymap}")
        summary.append("")
        summary.append(f"Required confirmation word: {required_word}")
        summary.append(f"Wi-Fi status: {wifi_status_line()}")
        summary.append(f"Saved installer log: {LOG_FILE}")

        self.summary.setPlainText("\n".join(summary))
        self.chk_confirm_1.setChecked(False)
        self.chk_confirm_2.setChecked(False)
        self.chk_confirm_3.setChecked(False)
        self.ed_type.setText("")
        self.btn_install.setEnabled(False)

        self.stack.setCurrentWidget(self.page_confirm)

    # ----------------------------
    # Install page
    # ----------------------------
    def _build_install(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Installing…"))
        self.prog = QProgressBar()
        self.prog.setRange(0, 100)
        lay.addWidget(self.prog)
        self.log = QPlainTextEdit()
        self.log.setReadOnly(True)
        self.log.setMinimumHeight(300)
        lay.addWidget(self.log, 1)
        self.btn_close = QPushButton("Close")
        self.btn_close.setMinimumHeight(40)
        self.btn_close.setEnabled(False)
        self.btn_close.clicked.connect(self.close)
        lay.addWidget(self.btn_close)
        return make_scroll_page(content)

    def _append_log(self, s: str):
        self.log.appendPlainText(s)
        sb = self.log.verticalScrollBar()
        sb.setValue(sb.maximum())

    def _start_install(self):
        install_mode = self.cmb_install_mode.currentText()
        required = self._required_confirm_word()
        if install_mode == MODE_ERASE:
            msg = "This will ERASE the selected disk and install the OS.\nDo you want to continue?"
        elif required == "FORMAT":
            msg = "This will FORMAT selected partition(s) and install the OS.\nDo you want to continue?"
        else:
            msg = "This will install onto the selected partitions WITHOUT formatting.\nDo you want to continue?"

        r = QMessageBox.warning(self, "LAST CHANCE", msg, QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if r != QMessageBox.Yes:
            return

        try:
            plan = self._build_plan()
        except Exception as e:
            QMessageBox.critical(self, "Invalid settings", str(e))
            return

        self.stack.setCurrentWidget(self.page_install)
        self.prog.setValue(0)
        self.log.clear()
        self.btn_close.setEnabled(False)

        self.install_thread = InstallThread(plan)
        self.install_thread.log.connect(self._append_log)
        self.install_thread.progress.connect(self.prog.setValue)
        self.install_thread.ok.connect(self._install_ok)
        self.install_thread.fail.connect(self._install_fail)
        self.install_thread.start()

    # ----------------------------
    # Done page
    # ----------------------------
    def _build_done(self) -> QWidget:
        content = QWidget()
        lay = QVBoxLayout(content)
        lay.addWidget(self._title("Done"))
        self.done_msg = QLabel("")
        self.done_msg.setWordWrap(True)
        self.done_msg.setStyleSheet("QLabel { color: #dbe3ff; }")
        lay.addWidget(self.done_msg)

        row = QHBoxLayout()
        btn_exit = QPushButton("Exit")
        btn_exit.setMinimumHeight(40)
        btn_exit.clicked.connect(self.close)

        btn_view_log = QPushButton("View Saved Log")
        btn_view_log.setMinimumHeight(40)
        btn_view_log.setStyleSheet(
            "QPushButton { background: #2b77ff; border: 1px solid #6aa9ff; color: white; font-weight: 900; }"
            "QPushButton:hover { background: #3a86ff; }"
        )
        btn_view_log.clicked.connect(self._view_saved_log)

        btn_reboot = QPushButton("Reboot Now")
        btn_reboot.setMinimumHeight(40)
        btn_reboot.setStyleSheet(
            "QPushButton { background: #19a974; border: 1px solid #34d399; color: #062016; font-weight: 900; }"
            "QPushButton:hover { background: #22c55e; }"
            "QPushButton:pressed { background: #16a34a; }"
        )
        btn_reboot.clicked.connect(self._reboot)

        row.addWidget(btn_exit)
        row.addWidget(btn_view_log)
        row.addStretch(1)
        row.addWidget(btn_reboot)
        lay.addLayout(row)
        return make_scroll_page(content)

    def _install_ok(self):
        self.btn_close.setEnabled(True)
        self.done_msg.setText(
            "Install finished successfully.\n"
            "Next:\n"
            "1) Reboot\n"
            "2) Remove the ISO\n"
            "3) Boot the installed system\n\n"
            f"Saved log:\n{LOG_FILE}\n"
        )
        self.stack.setCurrentWidget(self.page_done)

    def _install_fail(self, err: str):
        self.btn_close.setEnabled(True)
        self._append_log("\n!! INSTALL FAILED\n" + err)
        self.done_msg.setText(
            "Install failed.\n"
            "Scroll the log for the error, or click “View Saved Log”.\n\n"
            f"Saved log:\n{LOG_FILE}\n"
        )
        self.stack.setCurrentWidget(self.page_done)

    def _view_saved_log(self):
        path = str(LOG_FILE)
        if not Path(path).exists():
            QMessageBox.information(self, "Log not found", f"No saved log found at:\n{path}")
            return
        ok = QDesktopServices.openUrl(QUrl.fromLocalFile(path))
        if not ok:
            try:
                subprocess.run(["xdg-open", path], check=False)
            except Exception:
                QMessageBox.information(self, "Open failed", f"Couldn't open the log automatically.\nOpen it manually:\n{path}")

    def _reboot(self):
        try:
            subprocess.run(["sync"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            if cmd_ok("systemctl"):
                subprocess.run(["systemctl", "reboot"], check=False)
            else:
                subprocess.run(["reboot"], check=False)
        except Exception:
            pass

    def _go_welcome(self):
        env = []
        env.append(f"Root: {'YES' if is_root() else 'NO'}")
        env.append(f"UEFI detected: {'YES' if is_uefi() else 'NO'}")
        env.append(f"Internet: {'YES' if have_internet_fast() else 'NO/UNKNOWN'}")
        env.append(wifi_status_line())
        env.append(f"/etc/skel: {'FOUND' if LIVE_SKEL.exists() else 'NOT FOUND'}")
        env.append(f"StormOS wallpapers: {'FOUND' if Path('/usr/share/backgrounds/StormOS').exists() else 'NOT FOUND'}")
        env.append(f"packages.txt: {'FOUND' if LIVE_PKG_LIST.exists() else 'NOT FOUND'}")
        env.append(f"Saved log: {LOG_FILE}")
        self.lbl_env.setText(" | ".join(env))
        self.stack.setCurrentWidget(self.page_welcome)

# ============================================================
# main
# ============================================================
def main():
    app = QApplication(sys.argv)
    app.setStyleSheet(MIDNIGHT_QSS)
    w = Wizard()
    w.show()
    sys.exit(app.exec_())

if __name__ == "__main__":
    main()
