#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
AGES Easy Installer — Modern Redesign with Smart Location Detection
FULL SINGLE-FILE CODE (Modern Design + Location Detection + All Features)

FEATURES:
✅ Modern, clean UI optimized for 14" monitors
✅ Smart location detection for NYC, LA, and global cities
✅ Card-based design with better visual hierarchy
✅ Enhanced navigation with progress indicator
✅ All original functionality preserved
✅ Automatic timezone, keymap, and locale suggestions
✅ Multi-source location detection (IP, system, DNS)
✅ Async location detection with visual feedback
✅ Navigation lock during installation (NEW)
"""

import os
import re
import sys
import shlex
import time
import shutil
import socket
import subprocess
import urllib.request
import urllib.error
import json
from dataclasses import dataclass
from pathlib import Path
from typing import List, Optional, Tuple, Callable, Dict

from PyQt5.QtCore import Qt, QThread, pyqtSignal, QTimer, QSize
from PyQt5.QtGui import QFont, QPalette, QColor
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QFormLayout,
    QLabel, QLineEdit, QPushButton, QComboBox, QStackedWidget, QMessageBox,
    QPlainTextEdit, QProgressBar, QCheckBox, QGroupBox, QScrollArea,
    QSizePolicy, QFrame
)

# ============================================================
# Modern theme palette + app-wide stylesheet
# ============================================================
MODERN_QSS = r"""
* {
    font-family: "Segoe UI", "Noto Sans", "DejaVu Sans", "Inter";
    font-size: 11pt;
}

QMainWindow {
    background: #0a0e1a;
}

#SideNav {
    background: #0f1525;
    border-right: 1px solid #1a233a;
}

QLabel {
    color: #e0e6ff;
    background: transparent;
}

QLabel[class="Title"] {
    font-size: 20pt;
    font-weight: 700;
    color: #ffffff;
    margin-bottom: 5px;
}

QLabel[class="Subtitle"] {
    font-size: 12pt;
    color: #a0a8cc;
    margin-bottom: 15px;
}

QLabel[class="SectionTitle"] {
    font-size: 14pt;
    font-weight: 600;
    color: #7aa2f7;
    margin-top: 10px;
    margin-bottom: 10px;
}

QLabel[class="LocationBadge"] {
    font-size: 10pt;
    font-weight: 500;
    color: #7aa2f7;
    background: rgba(122, 162, 247, 0.1);
    border: 1px solid rgba(122, 162, 247, 0.3);
    border-radius: 8px;
    padding: 6px 12px;
}

QGroupBox {
    background: #111827;
    border: 1px solid #1e293b;
    border-radius: 12px;
    margin-top: 15px;
    padding-top: 15px;
}

QGroupBox::title {
    subcontrol-origin: margin;
    left: 12px;
    padding: 0 8px 0 8px;
    color: #a0a8cc;
    font-weight: 600;
}

QLineEdit, QComboBox, QPlainTextEdit, QTextEdit {
    background: #0d1422;
    color: #e0e6ff;
    border: 1px solid #2d3748;
    border-radius: 8px;
    padding: 10px;
    selection-background-color: #1e40af;
}

QLineEdit:focus, QComboBox:focus, QPlainTextEdit:focus {
    border: 1px solid #3b82f6;
    background: #0f172a;
}

QComboBox::drop-down {
    border-left: 1px solid #2d3748;
    width: 30px;
}

QComboBox QAbstractItemView {
    background: #111827;
    color: #e0e6ff;
    selection-background-color: #1e40af;
    border: 1px solid #2d3748;
    border-radius: 8px;
    padding: 5px;
}

QPushButton {
    background: #1e293b;
    color: #e0e6ff;
    border: 1px solid #334155;
    border-radius: 10px;
    padding: 12px 20px;
    font-weight: 500;
    min-height: 44px;
}

QPushButton:hover {
    background: #334155;
    border-color: #475569;
}

QPushButton:pressed {
    background: #1e293b;
}

QPushButton:disabled {
    background: #0f172a;
    color: #475569;
    border-color: #1e293b;
}

QPushButton[class="Primary"] {
    background: #3b82f6;
    color: #ffffff;
    border: 1px solid #2563eb;
    font-weight: 600;
}

QPushButton[class="Primary"]:hover {
    background: #2563eb;
}

QPushButton[class="Primary"]:pressed {
    background: #1d4ed8;
}

QPushButton[class="NavStep"] {
    text-align: left;
    padding: 15px;
    border-radius: 10px;
    background: transparent;
    border: 1px solid transparent;
    min-height: 60px;
}

QPushButton[class="NavStep"][active="true"] {
    background: rgba(59, 130, 246, 0.1);
    border: 1px solid #3b82f6;
}

QPushButton[class="NavStep"][done="true"] {
    border: 1px solid rgba(34, 197, 94, 0.3);
}

QPushButton[class="NavStep"][locked="true"] {
    color: #64748b;
}

QPushButton[class="NavStep"][disabled="true"] {
    color: #475569;
    pointer-events: none;
}

QProgressBar {
    border: 1px solid #2d3748;
    border-radius: 8px;
    text-align: center;
    background: #0d1422;
    color: #e0e6ff;
    height: 24px;
}

QProgressBar::chunk {
    background-color: #3b82f6;
    border-radius: 8px;
}

QCheckBox, QRadioButton {
    color: #e0e6ff;
    spacing: 10px;
}

QCheckBox::indicator, QRadioButton::indicator {
    width: 20px;
    height: 20px;
}

QCheckBox::indicator {
    border: 2px solid #475569;
    border-radius: 6px;
    background: #0d1422;
}

QCheckBox::indicator:checked {
    background: #3b82f6;
    border-color: #3b82f6;
}

QRadioButton::indicator {
    border: 2px solid #475569;
    border-radius: 10px;
    background: #0d1422;
}

QRadioButton::indicator:checked {
    background: #3b82f6;
    border-color: #3b82f6;
}

QScrollArea {
    border: none;
    background: transparent;
}

QScrollBar:vertical {
    background: #0d1422;
    width: 10px;
    border-radius: 5px;
}

QScrollBar::handle:vertical {
    background: #475569;
    min-height: 30px;
    border-radius: 5px;
}

QScrollBar::handle:vertical:hover {
    background: #64748b;
}

QPlainTextEdit[readonly="true"] {
    background: #0d1422;
    border: 1px solid #2d3748;
    border-radius: 8px;
}

QLabel[class="Warning"] {
    color: #f59e0b;
    font-weight: 500;
}

QLabel[class="Error"] {
    color: #ef4444;
    font-weight: 500;
}

QLabel[class="Success"] {
    color: #10b981;
    font-weight: 500;
}

QWidget[class="LocationWidget"] {
    background: rgba(59, 130, 246, 0.05);
    border: 1px solid rgba(59, 130, 246, 0.2);
    border-radius: 10px;
    padding: 15px;
}
"""

# ============================================================
# Location Detection Module
# ============================================================

class LocationDetector:
    """Enhanced location detection with better accuracy for major cities"""
    
    # Major city mappings with better accuracy
    CITY_TO_TIMEZONE = {
        # USA
        "new york": "America/New_York",
        "new york city": "America/New_York",
        "nyc": "America/New_York",
        "los angeles": "America/Los_Angeles",
        "la": "America/Los_Angeles",
        "chicago": "America/Chicago",
        "houston": "America/Chicago",
        "phoenix": "America/Phoenix",
        "philadelphia": "America/New_York",
        "san antonio": "America/Chicago",
        "san diego": "America/Los_Angeles",
        "dallas": "America/Chicago",
        "san jose": "America/Los_Angeles",
        "austin": "America/Chicago",
        "jacksonville": "America/New_York",
        "fort worth": "America/Chicago",
        "columbus": "America/New_York",
        "charlotte": "America/New_York",
        "san francisco": "America/Los_Angeles",
        "seattle": "America/Los_Angeles",
        "denver": "America/Denver",
        "washington": "America/New_York",
        "boston": "America/New_York",
        "detroit": "America/Detroit",
        "nashville": "America/Chicago",
        "memphis": "America/Chicago",
        "portland": "America/Los_Angeles",
        "las vegas": "America/Los_Angeles",
        "atlanta": "America/New_York",
        "miami": "America/New_York",
        "orlando": "America/New_York",
        "tampa": "America/New_York",
        
        # Canada
        "toronto": "America/Toronto",
        "vancouver": "America/Vancouver",
        "montreal": "America/Toronto",
        "calgary": "America/Edmonton",
        "ottawa": "America/Toronto",
        "edmonton": "America/Edmonton",
        "winnipeg": "America/Winnipeg",
        "quebec": "America/Toronto",
        
        # Europe
        "london": "Europe/London",
        "paris": "Europe/Paris",
        "berlin": "Europe/Berlin",
        "madrid": "Europe/Madrid",
        "rome": "Europe/Rome",
        "amsterdam": "Europe/Amsterdam",
        "brussels": "Europe/Brussels",
        "vienna": "Europe/Vienna",
        "prague": "Europe/Prague",
        "warsaw": "Europe/Warsaw",
        "budapest": "Europe/Budapest",
        "dublin": "Europe/Dublin",
        "lisbon": "Europe/Lisbon",
        "athens": "Europe/Athens",
        "stockholm": "Europe/Stockholm",
        "oslo": "Europe/Oslo",
        "helsinki": "Europe/Helsinki",
        "copenhagen": "Europe/Copenhagen",
        "zurich": "Europe/Zurich",
        
        # Asia
        "tokyo": "Asia/Tokyo",
        "seoul": "Asia/Seoul",
        "beijing": "Asia/Shanghai",
        "shanghai": "Asia/Shanghai",
        "hong kong": "Asia/Hong_Kong",
        "singapore": "Asia/Singapore",
        "taipei": "Asia/Taipei",
        "bangkok": "Asia/Bangkok",
        "jakarta": "Asia/Jakarta",
        "manila": "Asia/Manila",
        "kuala lumpur": "Asia/Kuala_Lumpur",
        "delhi": "Asia/Kolkata",
        "mumbai": "Asia/Kolkata",
        "bangalore": "Asia/Kolkata",
        "karachi": "Asia/Karachi",
        "dhaka": "Asia/Dhaka",
        
        # Australia/NZ
        "sydney": "Australia/Sydney",
        "melbourne": "Australia/Melbourne",
        "brisbane": "Australia/Brisbane",
        "perth": "Australia/Perth",
        "adelaide": "Australia/Adelaide",
        "auckland": "Pacific/Auckland",
        "wellington": "Pacific/Auckland",
        
        # Latin America
        "mexico city": "America/Mexico_City",
        "sao paulo": "America/Sao_Paulo",
        "rio de janeiro": "America/Sao_Paulo",
        "buenos aires": "America/Argentina/Buenos_Aires",
        "lima": "America/Lima",
        "bogota": "America/Bogota",
        "santiago": "America/Santiago",
        "caracas": "America/Caracas",
    }
    
    # Region-based timezone fallbacks
    REGION_TO_TIMEZONE = {
        "us": "America/New_York",
        "united states": "America/New_York",
        "usa": "America/New_York",
        "canada": "America/Toronto",
        "uk": "Europe/London",
        "united kingdom": "Europe/London",
        "germany": "Europe/Berlin",
        "france": "Europe/Paris",
        "spain": "Europe/Madrid",
        "italy": "Europe/Rome",
        "japan": "Asia/Tokyo",
        "china": "Asia/Shanghai",
        "australia": "Australia/Sydney",
        "brazil": "America/Sao_Paulo",
        "mexico": "America/Mexico_City",
    }
    
    @staticmethod
    def detect_location() -> Dict[str, str]:
        """
        Detect location using multiple methods in order of reliability
        Returns dict with: city, region, country, timezone, method
        """
        methods_tried = []
        result = {
            "city": "",
            "region": "",
            "country": "",
            "timezone": "",
            "method": "unknown",
            "confidence": "low"
        }
        
        # Method 1: Try IP-based geolocation with multiple providers
        geo_data = LocationDetector._get_ip_geolocation()
        if geo_data:
            methods_tried.append("ip_geolocation")
            result.update(geo_data)
            result["method"] = "ip_geolocation"
            result["confidence"] = "high"
            
            # If we got a city, try to match it to our known cities
            if result["city"]:
                city_lower = result["city"].lower()
                if city_lower in LocationDetector.CITY_TO_TIMEZONE:
                    result["timezone"] = LocationDetector.CITY_TO_TIMEZONE[city_lower]
                    result["confidence"] = "very_high"
            
            # If we still don't have a timezone, try region/country
            if not result["timezone"] and result["region"]:
                region_lower = result["region"].lower()
                if region_lower in LocationDetector.REGION_TO_TIMEZONE:
                    result["timezone"] = LocationDetector.REGION_TO_TIMEZONE[region_lower]
                    result["confidence"] = "medium"
            
            return result
        
        # Method 2: Try system timezone
        system_tz = LocationDetector._get_system_timezone()
        if system_tz:
            methods_tried.append("system_timezone")
            result["timezone"] = system_tz
            result["method"] = "system_timezone"
            result["confidence"] = "medium"
            
            # Try to infer city from timezone
            city = LocationDetector._infer_city_from_timezone(system_tz)
            if city:
                result["city"] = city
            
            return result
        
        # Method 3: Try reverse DNS lookup (less reliable)
        hostname = socket.getfqdn()
        if hostname and hostname != "localhost":
            methods_tried.append("dns_lookup")
            # Extract possible location hints from hostname
            if any(city in hostname.lower() for city in LocationDetector.CITY_TO_TIMEZONE.keys()):
                for city in LocationDetector.CITY_TO_TIMEZONE.keys():
                    if city in hostname.lower():
                        result["city"] = city.title()
                        result["timezone"] = LocationDetector.CITY_TO_TIMEZONE[city]
                        result["method"] = "dns_inference"
                        result["confidence"] = "low"
                        break
        
        # Final fallback
        if not result["timezone"]:
            result["timezone"] = "America/New_York"  # Default to NYC
            result["method"] = "default_fallback"
            result["confidence"] = "very_low"
        
        return result
    
    @staticmethod
    def _get_ip_geolocation() -> Optional[Dict[str, str]]:
        """Get geolocation from IP using multiple public APIs"""
        providers = [
            {
                "url": "https://ipapi.co/json/",
                "mapping": {
                    "city": "city",
                    "region": "region",
                    "country": "country_name",
                    "timezone": "timezone"
                }
            },
            {
                "url": "https://ipinfo.io/json",
                "mapping": {
                    "city": "city",
                    "region": "region",
                    "country": "country",
                    "timezone": "timezone"
                }
            },
            {
                "url": "http://ip-api.com/json/",
                "mapping": {
                    "city": "city",
                    "region": "regionName",
                    "country": "country",
                    "timezone": "timezone"
                }
            }
        ]
        
        for provider in providers:
            try:
                req = urllib.request.Request(
                    provider["url"],
                    headers={"User-Agent": "AGES-Installer/1.0"}
                )
                with urllib.request.urlopen(req, timeout=5) as response:
                    data = json.loads(response.read().decode())
                    
                    result = {}
                    for key, source_key in provider["mapping"].items():
                        if source_key in data:
                            result[key] = str(data[source_key]).strip()
                    
                    # Validate we got useful data
                    if "timezone" in result and result["timezone"]:
                        return result
            except Exception:
                continue
        
        return None
    
    @staticmethod
    def _get_system_timezone() -> Optional[str]:
        """Get system timezone from multiple sources"""
        try:
            # Try /etc/timezone
            tz_path = Path("/etc/timezone")
            if tz_path.exists():
                tz = tz_path.read_text().strip()
                if tz:
                    return tz
            
            # Try /etc/localtime symlink
            localtime = Path("/etc/localtime")
            if localtime.is_symlink():
                target = os.readlink(str(localtime))
                if "/usr/share/zoneinfo/" in target:
                    return target.split("/usr/share/zoneinfo/", 1)[1]
            
            # Try timedatectl
            if shutil.which("timedatectl"):
                output = subprocess.check_output(
                    ["timedatectl", "show", "--property=Timezone", "--value"],
                    text=True
                ).strip()
                if output:
                    return output
        except Exception:
            pass
        
        return None
    
    @staticmethod
    def _infer_city_from_timezone(timezone: str) -> Optional[str]:
        """Try to infer a major city from a timezone"""
        # Reverse lookup in our city mapping
        for city, tz in LocationDetector.CITY_TO_TIMEZONE.items():
            if tz == timezone:
                return city.title()
        
        # Common patterns
        if "New_York" in timezone:
            return "New York"
        elif "Los_Angeles" in timezone:
            return "Los Angeles"
        elif "Chicago" in timezone:
            return "Chicago"
        elif "London" in timezone:
            return "London"
        elif "Paris" in timezone:
            return "Paris"
        elif "Tokyo" in timezone:
            return "Tokyo"
        elif "Sydney" in timezone:
            return "Sydney"
        
        return None


# ============================================================
# Location Detection Thread (for async detection)
# ============================================================
class LocationDetectionThread(QThread):
    """Thread for async location detection"""
    
    sig_location_detected = pyqtSignal(dict)
    sig_detection_failed = pyqtSignal(str)
    
    def run(self):
        """Run location detection"""
        try:
            location = LocationDetector.detect_location()
            self.sig_location_detected.emit(location)
        except Exception as e:
            self.sig_detection_failed.emit(str(e))


# ============================================================
# Installer log file (always written)
# ============================================================
LOG_FILE = Path("/tmp/ages_easy_installer.log")


def log_to_file(line: str) -> None:
    try:
        LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        with LOG_FILE.open("a", encoding="utf-8", errors="ignore") as f:
            f.write(line.rstrip("\n") + "\n")
    except Exception:
        pass


def reset_log_file() -> None:
    try:
        LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
        LOG_FILE.write_text("", encoding="utf-8", errors="ignore")
    except Exception:
        pass


# ============================================================
# Helper Functions (from original code)
# ============================================================
def is_root() -> bool:
    try:
        return os.geteuid() == 0
    except Exception:
        return False


def is_uefi() -> bool:
    return Path("/sys/firmware/efi/efivars").exists()


def which(cmd: str) -> Optional[str]:
    return shutil.which(cmd)


def cmd_ok(cmd: str) -> bool:
    return which(cmd) is not None


def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)


def read_text(p: Path) -> str:
    try:
        return p.read_text(errors="ignore")
    except Exception:
        return ""


def write_file(path: Path, content: str) -> None:
    ensure_dir(path.parent)
    path.write_text(content, encoding="utf-8", errors="ignore")


def sanitize_hostname(h: str) -> str:
    h = (h or "").strip().lower()
    h = re.sub(r"[^a-z0-9-]", "-", h)
    h = re.sub(r"-{2,}", "-", h).strip("-")
    return h[:63] if h else "arch"


def sanitize_username(u: str) -> str:
    u = (u or "").strip().lower()
    u = re.sub(r"[^a-z0-9_]", "", u)
    if not u or u[0].isdigit():
        u = "user"
    return u[:32]


def live_user_best_effort() -> str:
    u = os.environ.get("SUDO_USER") or os.environ.get("USER") or "liveuser"
    return sanitize_username(u) or "liveuser"


def have_internet_fast() -> bool:
    try:
        s = socket.create_connection(("1.1.1.1", 53), timeout=1.0)
        s.close()
        return True
    except Exception:
        return False


def safe_umount_recursive(mountpoint: str) -> None:
    try:
        mounts = read_text(Path("/proc/mounts")).splitlines()
        mps = []
        for line in mounts:
            parts = line.split()
            if len(parts) >= 2:
                mps.append(parts[1])
        for m in sorted(mps, key=len, reverse=True):
            if m == mountpoint or m.startswith(mountpoint.rstrip("/") + "/"):
                subprocess.run(["umount", "-R", mountpoint],
                               stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                break
        subprocess.run(["umount", mountpoint],
                       stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    except Exception:
        pass


def partition_path(disk: str, n: int) -> str:
    if re.search(r"(nvme\d+n\d+|mmcblk\d+)$", disk):
        return f"{disk}p{n}"
    return f"{disk}{n}"


def detect_microcode_pkg() -> Optional[str]:
    cpuinfo = read_text(Path("/proc/cpuinfo")).lower()
    if "genuineintel" in cpuinfo:
        return "intel-ucode"
    if "authenticamd" in cpuinfo:
        return "amd-ucode"
    return None


def parse_size_to_bytes(sz: str) -> int:
    s = (sz or "").strip().upper()
    m = re.match(r"^([0-9.]+)\s*([KMGTP]?)(I?B?)$", s)
    if not m:
        return 0
    val = float(m.group(1))
    unit = m.group(2)
    mult = 1
    if unit == "K":
        mult = 1024
    elif unit == "M":
        mult = 1024**2
    elif unit == "G":
        mult = 1024**3
    elif unit == "T":
        mult = 1024**4
    elif unit == "P":
        mult = 1025**5
    return int(val * mult)


def _disk_transport(disk: str) -> str:
    try:
        if cmd_ok("lsblk"):
            cp = subprocess.run(["lsblk", "-dnro", "TRAN", disk],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            return (cp.stdout or "").strip().lower()
    except Exception:
        pass
    return ""


def _disk_is_boot_media_archiso(disk: str) -> bool:
    bootmnt = "/run/archiso/bootmnt"
    if not cmd_ok("findmnt"):
        return False
    cp = subprocess.run(["findmnt", "-no", "SOURCE", bootmnt],
                        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    src = (cp.stdout or "").strip()
    if not src:
        return False
    try:
        cp2 = subprocess.run(["lsblk", "-no", "PKNAME", src],
                             stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        pk = (cp2.stdout or "").strip()
        if pk and f"/dev/{pk}" == disk:
            return True
    except Exception:
        pass
    return False


def list_disks() -> List[Tuple[str, str, str]]:
    if not cmd_ok("lsblk"):
        return []
    cp = subprocess.run(
        ["lsblk", "-dn", "-o", "NAME,TYPE,SIZE,RM,MODEL,TRAN"],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
    )
    out = cp.stdout or ""
    disks = []
    for line in out.splitlines():
        line = line.strip()
        if not line:
            continue
        parts = line.split(None, 5)
        if len(parts) < 4:
            continue
        name, typ, size, rm = parts[0], parts[1], parts[2], parts[3]
        model = parts[4].strip() if len(parts) >= 5 else ""
        if typ != "disk":
            continue
        if name.startswith(("loop", "ram", "sr")):
            continue
        disks.append((f"/dev/{name}", size, model))
    return disks


def disk_is_removable(disk: str) -> bool:
    try:
        base = Path(disk).name
        rm = read_text(Path(f"/sys/block/{base}/removable")).strip()
        return rm == "1"
    except Exception:
        return False


def choose_best_disk(disks: List[Tuple[str, str, str]]) -> Optional[str]:
    if not disks:
        return None
    scored = []
    for dev, size, model in disks:
        if _disk_is_boot_media_archiso(dev):
            continue
        b = parse_size_to_bytes(size)
        rm = 1 if disk_is_removable(dev) else 0
        tran = _disk_transport(dev)
        usbish = 1 if tran == "usb" else 0
        score = 0
        score += 1000 if rm == 0 else 0
        score += 500 if usbish == 0 else 0
        score += int(min(b / (1024**3), 5000))
        scored.append((score, dev))
    if not scored:
        scored = [(parse_size_to_bytes(size), dev) for dev, size, _ in disks]
    scored.sort(reverse=True)
    return scored[0][1] if scored else None


def list_partitions_for_disk(disk: str) -> List[Tuple[str, str, str, str, str, str]]:
    """
    Returns a list of (name, size, fstype, mountpoint, partlabel, parttype)
    where 'name' is the full device path (e.g. /dev/nvme0n1p2).
    Robust against spaces in labels/mountpoints by using lsblk JSON.
    """
    if not cmd_ok("lsblk"):
        return []

    disk_base = Path(disk).name

    try:
        cp = subprocess.run(
            ["lsblk", "-J", "-p", "-o", "NAME,TYPE,PKNAME,SIZE,FSTYPE,MOUNTPOINT,PARTLABEL,PARTTYPE"],
            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
        )
        data = json.loads(cp.stdout or "{}")
    except Exception:
        return []

    res: List[Tuple[str, str, str, str, str, str]] = []

    def norm(x) -> str:
        if x is None:
            return ""
        x = str(x)
        return "" if x.strip() in ("-", "null") else x.strip()

    # include normal partitions plus common “partition-like” containers
    ok_types = {"part", "crypt", "lvm", "raid", "md", "dm", "loop"}

    def walk(nodes):
        for n in nodes or []:
            typ = norm(n.get("type")).lower()
            pk = norm(n.get("pkname"))
            name = norm(n.get("name"))
            if pk == disk_base and typ in ok_types and name:
                res.append((
                    name,
                    norm(n.get("size")),
                    norm(n.get("fstype")),
                    norm(n.get("mountpoint")),
                    norm(n.get("partlabel")),
                    norm(n.get("parttype")),
                ))
            walk(n.get("children"))

    walk(data.get("blockdevices"))

    # de-dupe + stable sort
    seen = set()
    out = []
    for row in res:
        if row[0] not in seen:
            seen.add(row[0])
            out.append(row)
    out.sort(key=lambda r: r[0])
    return out



def run_stream(cmd: List[str], on_line, timeout: Optional[int] = None, input_text: Optional[str] = None) -> int:
    p = subprocess.Popen(
        cmd,
        stdin=subprocess.PIPE if input_text is not None else None,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True
    )
    start = time.time()
    try:
        if input_text is not None and p.stdin is not None:
            try:
                p.stdin.write(input_text)
                p.stdin.close()
            except Exception:
                pass
        assert p.stdout is not None
        for line in p.stdout:
            on_line(line.rstrip("\n"))
            if timeout is not None and (time.time() - start) > timeout:
                on_line(f"!! Timeout ({timeout}s) reached, terminating: {' '.join(cmd)}")
                p.terminate()
                try:
                    p.wait(timeout=5)
                except Exception:
                    p.kill()
                return 124
        return p.wait()
    finally:
        try:
            if p.stdout:
                p.stdout.close()
        except Exception:
            pass


def arch_chroot(target_root: Path, cmd: str, log) -> None:
    full = ["arch-chroot", str(target_root), "bash", "-lc", cmd]
    log(f"$ arch-chroot {target_root} bash -lc {cmd}")
    rc = run_stream(full, log, timeout=None)
    if rc != 0:
        raise RuntimeError(f"arch-chroot failed (rc={rc}): {cmd}")


def arch_chroot_soft(target_root: Path, cmd: str, log) -> int:
    full = ["arch-chroot", str(target_root), "bash", "-lc", cmd]
    log(f"$ arch-chroot {target_root} bash -lc {cmd}")
    return run_stream(full, log, timeout=None)


def arch_chroot_input(target_root: Path, cmd: str, input_text: str, log) -> None:
    full = ["arch-chroot", str(target_root), "bash", "-lc", cmd]
    log(f"$ arch-chroot {target_root} bash -lc {cmd}  (stdin provided)")
    rc = run_stream(full, log, timeout=None, input_text=input_text)
    if rc != 0:
        raise RuntimeError(f"arch-chroot failed (rc={rc}): {cmd}")


def find_ecoos_packages_file() -> str:
    candidates = [
        "/etc/ecoos/packages.txt",
        "/usr/share/ecoos/packages.txt",
        "/run/archiso/airootfs/etc/ecoos/packages.txt",
        os.path.expanduser("~/ecoos/packages.txt"),
        os.path.expanduser("~/Desktop/packages.txt"),
    ]
    for p in candidates:
        if os.path.isfile(p):
            return p
    raise FileNotFoundError("Could not find packages.txt in known locations.")


# ============================================================
# Virtual machine detector (guest-side)
# ============================================================
def detect_virtualization() -> Dict[str, str]:
    """
    Returns dict:
      {"is_vm":"yes/no/unknown", "type":"kvm|qemu|oracle|vmware|microsoft|...|none|unknown", "details":"..."}
    Best-effort: uses systemd-detect-virt, then virt-what, then DMI heuristics.
    """
    # 1) systemd-detect-virt (best if available)
    if cmd_ok("systemd-detect-virt"):
        try:
            cp = subprocess.run(["systemd-detect-virt", "--vm"],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            out = (cp.stdout or "").strip().lower()
            # systemd-detect-virt exits 0 for detected, 1 for none; but we rely on output too.
            if out and out != "none":
                typ = out
                if typ in ("kvm", "qemu"):
                    return {
                        "is_vm": "yes",
                        "type": typ,
                        "details": f"systemd-detect-virt: {typ} (GNOME Boxes / virt-manager / libvirt possible)"
                    }
                friendly = {
                    "oracle": "VirtualBox",
                    "vmware": "VMware",
                    "microsoft": "Hyper-V",
                    "xen": "Xen",
                    "bochs": "Bochs",
                    "uml": "User-mode Linux",
                    "parallels": "Parallels",
                    "bhyve": "bhyve",
                    "zvm": "z/VM",
                    "amazon": "Amazon EC2 Nitro",
                    "openvz": "OpenVZ",
                    "lxc": "LXC",
                    "systemd-nspawn": "systemd-nspawn",
                    "podman": "Podman",
                    "docker": "Docker",
                }.get(typ, typ)
                return {"is_vm": "yes", "type": typ, "details": f"systemd-detect-virt: {friendly}"}
            if out == "none":
                return {"is_vm": "no", "type": "none", "details": "systemd-detect-virt: none"}
        except Exception:
            pass

    # 2) virt-what (if present)
    if cmd_ok("virt-what"):
        try:
            cp = subprocess.run(["virt-what"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            out = (cp.stdout or "").strip().lower()
            if out:
                # virt-what can print multiple lines
                lines = [x.strip() for x in out.splitlines() if x.strip()]
                typ = lines[0] if lines else "unknown"
                det = ", ".join(lines)
                if "kvm" in lines or "qemu" in lines:
                    det += " (GNOME Boxes / virt-manager / libvirt possible)"
                return {"is_vm": "yes", "type": typ, "details": f"virt-what: {det}"}
        except Exception:
            pass

    # 3) DMI heuristics
    dmi_paths = [
        Path("/sys/devices/virtual/dmi/id/product_name"),
        Path("/sys/devices/virtual/dmi/id/sys_vendor"),
        Path("/sys/devices/virtual/dmi/id/board_vendor"),
    ]
    dmi = " ".join([read_text(p).strip() for p in dmi_paths if p.exists()]).lower()
    if dmi:
        if "virtualbox" in dmi or "innotek" in dmi:
            return {"is_vm": "yes", "type": "oracle", "details": f"DMI: {dmi} (VirtualBox)"}
        if "vmware" in dmi:
            return {"is_vm": "yes", "type": "vmware", "details": f"DMI: {dmi} (VMware)"}
        if "microsoft" in dmi or "hyper-v" in dmi:
            return {"is_vm": "yes", "type": "microsoft", "details": f"DMI: {dmi} (Hyper-V)"}
        if "qemu" in dmi or "kvm" in dmi:
            return {"is_vm": "yes", "type": "kvm", "details": f"DMI: {dmi} (KVM/QEMU; GNOME Boxes/virt-manager/libvirt possible)"}
        if "xen" in dmi:
            return {"is_vm": "yes", "type": "xen", "details": f"DMI: {dmi} (Xen)"}

    return {"is_vm": "unknown", "type": "unknown", "details": "Unable to detect (no systemd-detect-virt / virt-what, and no clear DMI match)"}


# ============================================================
# Wi-Fi status
# ============================================================
def wifi_status_line() -> str:
    if not cmd_ok("nmcli"):
        return "Wi-Fi: nmcli not available"
    try:
        cp = subprocess.run(["nmcli", "-t", "-f", "DEVICE,TYPE,STATE,CONNECTION", "device"],
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        out = (cp.stdout or "").strip()
        wifi_dev = None
        conn = None
        state = None
        for line in out.splitlines():
            parts = line.split(":")
            if len(parts) >= 4:
                dev, typ, st, con = parts[0], parts[1], parts[2], parts[3]
                if typ == "wifi":
                    wifi_dev = dev
                    state = st
                    conn = con
                    break
        if wifi_dev and state == "connected" and conn:
            return f"Wi-Fi: Connected to {conn} on {wifi_dev}"
        if wifi_dev:
            return f"Wi-Fi: {state or 'unknown'} on {wifi_dev}"
        return "Wi-Fi: Not detected"
    except Exception:
        return "Wi-Fi: Unknown"


# ============================================================
# pacman.conf repo helpers (MULTILIB)
# ============================================================
def enable_repo_in_pacman_conf(conf_path: Path, repo_name: str, log) -> bool:
    txt = read_text(conf_path)
    if not txt.strip():
        raise RuntimeError(f"pacman.conf missing/empty: {conf_path}")
    changed = False
    header_re = re.compile(rf"(?m)^\s*#?\s*\[{re.escape(repo_name)}\]\s*$")
    m = header_re.search(txt)
    if not m:
        txt = txt.rstrip() + f"\n[{repo_name}]\nInclude = /etc/pacman.d/mirrorlist\n"
        changed = True
    else:
        txt2 = re.sub(rf"(?m)^\s*#\s*\[{re.escape(repo_name)}\]\s*$", f"[{repo_name}]", txt)
        if txt2 != txt:
            txt = txt2
            changed = True
    block_re = re.compile(rf"(?ms)^\s*\[{re.escape(repo_name)}\]\s*$.*?(?=^\s*\[|\Z)")
    bm = block_re.search(txt)
    if bm:
        block = bm.group(0)
        block2 = re.sub(r"(?m)^\s*#\s*(Include\s*=\s*/etc/pacman\.d/mirrorlist)\s*$", r"\1", block)
        if block2 != block:
            txt = txt[:bm.start()] + block2 + txt[bm.end():]
            changed = True
        bm2 = block_re.search(txt)
        if bm2:
            block_now = bm2.group(0)
            if not re.search(r"(?m)^\s*Include\s*=\s*/etc/pacman.d/mirrorlist\s*$", block_now):
                block_now2 = block_now.rstrip() + "\nInclude = /etc/pacman.d/mirrorlist\n"
                txt = txt[:bm2.start()] + block_now2 + txt[bm2.end():]
                changed = True
    if changed:
        write_file(conf_path, txt if txt.endswith("\n") else (txt + "\n"))
        log(f"Enabled repo [{repo_name}] in {conf_path}")
    else:
        log(f"Repo [{repo_name}] already enabled in {conf_path}")
    return changed


def ensure_multilib_enabled_live(log) -> None:
    live_conf = Path("/etc/pacman.conf")
    enable_repo_in_pacman_conf(live_conf, "multilib", log)
    if cmd_ok("pacman"):
        run_stream(["pacman", "-Syy", "--noconfirm"], log, timeout=None)


def ensure_multilib_enabled_target(target_root: Path, log) -> None:
    tgt_conf = target_root / "etc" / "pacman.conf"
    if tgt_conf.exists():
        enable_repo_in_pacman_conf(tgt_conf, "multilib", log)




def add_eco_repo_to_pacman_conf(target_root: Path, log) -> None:
    """
    Adds the [eco_repo] stanza to the target system's /etc/pacman.conf
    """
    conf_path = target_root / "etc" / "pacman.conf"
    eco_repo_stanza = """
[eco_repo]
SigLevel = Never
Server = https://rport99.github.io/eco_repo/$arch
"""

    try:
        current_content = read_text(conf_path)
        # Avoid duplicate entries
        if "[eco_repo]" in current_content:
            log("Repository [eco_repo] already present in pacman.conf — skipping.")
            return

        # Append repo at the end
        updated_content = current_content.rstrip() + "\n" + eco_repo_stanza + "\n"
        write_file(conf_path, updated_content)
        log("Added [eco_repo] to target system's /etc/pacman.conf")
    except Exception as e:
        log(f"!! Failed to add [eco_repo] to pacman.conf: {e}")


# ============================================================
# Disk-in-use protection + preparation
# ============================================================
def _lsblk_mounts_and_parts_for_disk(disk: str) -> List[Tuple[str, str]]:
    if not cmd_ok("lsblk"):
        return []
    cp = subprocess.run(
        ["lsblk", "-nrpo", "NAME,TYPE,PKNAME,MOUNTPOINT"],
        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True
    )
    out = (cp.stdout or "").splitlines()
    disk_base = Path(disk).name
    mounted = []
    for line in out:
        parts = line.split(None, 3)
        if len(parts) < 3:
            continue
        name, typ, pk = parts[0], parts[1], parts[2]
        mnt = parts[3].strip() if len(parts) >= 4 else ""
        if typ != "part":
            continue
        if pk != disk_base:
            continue
        if mnt and mnt != "-":
            mounted.append((name, mnt))
    mounted.sort(key=lambda x: len(x[1]), reverse=True)
    return mounted


def _swapoff_on_disk(disk: str, log) -> None:
    try:
        swaps = read_text(Path("/proc/swaps")).splitlines()[1:]
    except Exception:
        swaps = []
    disk_base = Path(disk).name
    to_swapoff = []
    for line in swaps:
        parts = line.split()
        if not parts:
            continue
        dev = parts[0]
        try:
            cp = subprocess.run(["lsblk", "-no", "PKNAME", dev],
                                stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            pk = (cp.stdout or "").strip()
            if pk and pk == disk_base:
                to_swapoff.append(dev)
        except Exception:
            continue
    for dev in to_swapoff:
        log(f"swapoff: disabling swap on {dev} (best-effort)")
        subprocess.run(["swapoff", dev], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)


def prepare_disk_for_partitioning(disk: str, log) -> None:
    if _disk_is_boot_media_archiso(disk):
        raise RuntimeError(
            f"Refusing to erase {disk}: it appears to be the LIVE/boot media (/run/archiso/bootmnt).\n"
            "Boot from a different USB or select your internal disk (often /dev/nvme0n1)."
        )
    _swapoff_on_disk(disk, log)
    mounted = _lsblk_mounts_and_parts_for_disk(disk)
    if mounted:
        log("Disk is in use (mounted partitions detected). Attempting to unmount (best-effort)…")
        for dev, mnt in mounted:
            log(f"umount: {dev} mounted at {mnt}")
            subprocess.run(["umount", "-R", mnt], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            subprocess.run(["umount", mnt], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    subprocess.run(["udevadm", "settle"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    time.sleep(0.5)


# ============================================================
# Copy helpers (merge)
# ============================================================
def copy_tree_merge(src: Path, dst: Path, log) -> None:
    if not src.exists():
        log(f"-- Missing: {src}")
        return
    ensure_dir(dst)
    if cmd_ok("rsync"):
        rc = subprocess.run(["rsync", "-a", f"{str(src)}/", f"{str(dst)}/"],
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True).returncode
        if rc != 0:
            log(f"!! rsync returned non-zero for {src} -> {dst} (continuing)")
    else:
        for root, dirs, files in os.walk(str(src), followlinks=False):
            rp = Path(root)
            rel = rp.relative_to(src)
            out_root = dst / rel
            ensure_dir(out_root)
            for d in dirs:
                ensure_dir(out_root / d)
            for f in files:
                s = rp / f
                o = out_root / f
                try:
                    if o.exists() or o.is_symlink():
                        try:
                            o.unlink()
                        except Exception:
                            pass
                    if s.is_symlink():
                        try:
                            o.symlink_to(os.readlink(str(s)))
                        except Exception:
                            pass
                    else:
                        shutil.copy2(str(s), str(o))
                except Exception as e:
                    log(f"!! copy warn: {s} -> {o}: {e}")


def migrate_usr_local_bin(target_root: Path, log) -> None:
    src = Path("/usr/local/bin")
    dst = target_root / "usr" / "local" / "bin"
    if not src.exists():
        log("Migration: LIVE /usr/local/bin not present — skipping.")
        return
    log(f"Migration: copying {src} -> {dst}")
    copy_tree_merge(src, dst, log)
    try:
        count = 0
        for p in dst.iterdir():
            if p.is_file() and not p.is_symlink():
                st = p.stat()
                mode = st.st_mode
                new_mode = mode | 0o111
                if new_mode != mode:
                    os.chmod(str(p), new_mode)
                    count += 1
        log(f"Migration: ensured executability on {count} files in {dst}")
    except Exception as e:
        log(f"!! Migration: chmod pass failed: {e}")


def migrate_usr_share_icons(target_root: Path, log) -> None:
    src = Path("/usr/share/icons")
    dst = target_root / "usr" / "share" / "icons"
    if not src.exists():
        log("Icons migration: LIVE /usr/share/icons not present — skipping.")
        return
    log(f"Icons migration: copying {src} -> {dst}")
    copy_tree_merge(src, dst, log)


# ============================================================
# Oh My Bash -> /etc/skel
# ============================================================
def copy_oh_my_bash_to_skel(target_root: Path, live_user: str, log) -> None:
    src_omb = Path("/home") / live_user / ".oh-my-bash"
    dst_omb = target_root / "etc" / "skel" / ".oh-my-bash"
    src_bashrc = Path("/home") / live_user / ".bashrc"
    dst_bashrc = target_root / "etc" / "skel" / ".bashrc"
    if not src_omb.exists():
        log(f"Oh My Bash: {src_omb} not found on Live ISO — skipping.")
        return
    log(f"Oh My Bash: copying {src_omb} -> {dst_omb}")
    copy_tree_merge(src_omb, dst_omb, log)
    if src_bashrc.exists():
        log(f"Oh My Bash: copying {src_bashrc} -> {dst_bashrc}")
        ensure_dir(dst_bashrc.parent)
        try:
            shutil.copy2(str(src_bashrc), str(dst_bashrc))
        except Exception as e:
            log(f"!! Oh My Bash: .bashrc copy failed: {e}")
    try:
        txt = read_text(dst_bashrc)
        if "oh-my-bash.sh" not in txt:
            addon = (
                "\n# --- AGES: Oh My Bash ---\n"
                "export OSH=\"$HOME/.oh-my-bash\"\n"
                "OSH_THEME=\"powerline\"\n"
                "plugins=(git sudo)\n"
                "source \"$OSH/oh-my-bash.sh\"\n"
                "# --- end ---\n"
            )
            write_file(dst_bashrc, (txt.rstrip() + "\n" + addon).lstrip())
            log("Oh My Bash: appended source stanza to /etc/skel/.bashrc")
        else:
            log("Oh My Bash: /etc/skel/.bashrc already sources Oh My Bash")
    except Exception as e:
        log(f"!! Oh My Bash: failed to patch /etc/skel/.bashrc: {e}")


def enable_system_oh_my_bash_in_skel(target_root: Path, log) -> None:
    system_omb = target_root / "usr" / "share" / "oh-my-bash" / "oh-my-bash.sh"
    dst_bashrc = target_root / "etc" / "skel" / ".bashrc"
    if not system_omb.exists():
        log(f"Oh My Bash (system): {system_omb} not found in target — skipping.")
        return
    ensure_dir(dst_bashrc.parent)
    if not dst_bashrc.exists():
        write_file(dst_bashrc, "# ~/.bashrc\n\n")
    try:
        txt = read_text(dst_bashrc)
        if "/usr/share/oh-my-bash/oh-my-bash.sh" in txt or "oh-my-bash.sh" in txt:
            log("Oh My Bash (system): /etc/skel/.bashrc already sources Oh My Bash — skipping patch.")
            return
        addon = (
            "\n# --- AGES: Oh My Bash (system) ---\n"
            "export OSH=\"/usr/share/oh-my-bash\"\n"
            "OSH_THEME=\"powerline\"\n"
            "plugins=(git sudo)\n"
            "source \"$OSH/oh-my-bash.sh\"\n"
            "# --- end ---\n"
        )
        write_file(dst_bashrc, (txt.rstrip() + "\n" + addon).lstrip())
        log("Oh My Bash (system): enabled in /etc/skel/.bashrc")
    except Exception as e:
        log(f"!! Oh My Bash (system): failed to patch /etc/skel/.bashrc: {e}")


# ============================================================
# Live presets
# ============================================================
LIVE_SKEL = Path("/etc/skel")
LIVE_PKG_LIST = Path("/etc/stormos/packages.txt")


def apply_skel_preset(target_root: Path, log) -> None:
    if not LIVE_SKEL.exists():
        log("Preset: /etc/skel not found on Live ISO — skipping.")
        return
    log(f"Preset: merging Live ISO {LIVE_SKEL} -> target {target_root/'etc/skel'}")
    copy_tree_merge(LIVE_SKEL, target_root / "etc" / "skel", log)


def copy_ages_wallpapers_into_backgrounds(target_root: Path, log) -> None:
    live = Path("/usr/share/backgrounds/AGES")
    dst = target_root / "usr" / "share" / "backgrounds" / "AGES"
    if not live.exists():
        log("Wallpapers: live /usr/share/backgrounds/AGES not found — skipping.")
        return
    log(f"Wallpapers: copying {live} -> {dst}")
    copy_tree_merge(live, dst, log)


# ============================================================
# Host wallpaper -> installed system wallpaper
# ============================================================
def get_live_wallpaper_path_best_effort(log) -> Optional[Path]:
    if cmd_ok("xfconf-query"):
        candidates = [
            "/backdrop/screen0/monitor0/workspace0/last-image",
            "/backdrop/screen0/monitor0/workspace0/image-path",
            "/backdrop/screen0/monitor0/last-image",
            "/backdrop/screen0/monitor0/image-path",
        ]
        for prop in candidates:
            try:
                cp = subprocess.run(
                    ["xfconf-query", "-c", "xfce4-desktop", "-p", prop],
                    stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, text=True
                )
                val = (cp.stdout or "").strip()
                if val and Path(val).exists():
                    log(f"Wallpaper detect: xfconf {prop} -> {val}")
                    return Path(val)
            except Exception:
                pass

    fallbacks = [
        Path("/usr/share/backgrounds/xfce/xfce-x.svg"),
        Path("/usr/share/backgrounds/xfce/xfce-x.png"),
        Path("/usr/share/backgrounds/xfce/xfce-x.jpg"),
        Path("/usr/share/backgrounds/xfce-x.svg"),
        Path("/usr/share/backgrounds/xfce-x.png"),
        Path("/usr/share/backgrounds/xfce-x.jpg"),
    ]
    for p in fallbacks:
        if p.exists() and p.is_file() and p.stat().st_size > 0:
            log(f"Wallpaper detect: fallback -> {p}")
            return p
    log("Wallpaper detect: could not find a live wallpaper.")
    return None


def ensure_wallpaper_from_host(target_root: Path, log) -> str:
    src = get_live_wallpaper_path_best_effort(log)
    if not src:
        src = Path("/usr/share/backgrounds/xfce/xfce-x.svg")

    ext = src.suffix.lower()
    if ext not in [".png", ".jpg", ".jpeg", ".svg", ".webp"]:
        ext = ".png"

    dest_dir = target_root / "usr" / "share" / "backgrounds" / "xfce"
    ensure_dir(dest_dir)
    dest = dest_dir / f"xfce-x{ext}"

    if src.exists() and src.is_file() and src.stat().st_size > 0:
        shutil.copy2(str(src), str(dest))
        log(f"Wallpaper: copied host wallpaper {src} -> {dest}")
    else:
        raise RuntimeError(f"Wallpaper source missing/invalid: {src}")

    compat = target_root / "usr" / "share" / "backgrounds" / f"xfce-x{ext}"
    try:
        if compat.exists() or compat.is_symlink():
            compat.unlink()
        compat.symlink_to(Path("xfce") / f"xfce-x{ext}")
        log(f"Wallpaper: created symlink {compat} -> xfce/xfce-x{ext}")
    except Exception as e:
        log(f"!! Wallpaper: compat symlink failed (non-fatal): {e}")

    return f"/usr/share/backgrounds/xfce/xfce-x{ext}"


# ============================================================
# XFCE wallpaper patch + firstboot fix (XFCE only)
# ============================================================
def ensure_minimal_xfce_desktop_xml(xml_path: Path, log) -> None:
    if xml_path.exists():
        return
    log("XFCE wallpaper: creating minimal xfce4-desktop.xml in skel")
    ensure_dir(xml_path.parent)
    minimal_xml = '''<?xml version="1.0" encoding="UTF-8"?>
<channel name="xfce4-desktop" version="1.0">
  <property name="backdrop" type="empty">
    <property name="screen0" type="empty">
      <property name="monitor0" type="empty">
        <property name="workspace0" type="empty">
          <property name="last-image" type="string" value=""/>
          <property name="image-path" type="string" value=""/>
          <property name="image-show" type="bool" value="true"/>
        </property>
        <property name="image-path" type="string" value=""/>
        <property name="last-image" type="string" value=""/>
      </property>
    </property>
  </property>
</channel>
'''
    write_file(xml_path, minimal_xml)


def patch_xfce_wallpaper_in_skel(target_root: Path, wallpaper_path: str, log) -> None:
    xml = target_root / "etc" / "skel" / ".config" / "xfce4" / "xfconf" / "xfce-perchannel-xml" / "xfce4-desktop.xml"
    ensure_minimal_xfce_desktop_xml(xml, log)
    txt = read_text(xml)
    if not txt:
        log("XFCE wallpaper: unable to read xfce4-desktop.xml; skipping.")
        return
    new = re.sub(
        r'(<property\s+name="(last-image|image-path)"\s+type="string"\s+value=")[^"]*(")',
        rf'\1{wallpaper_path}\3',
        txt
    )
    if new == txt:
        if '<property name="workspace0"' in new:
            insert = f'          <property name="last-image" type="string" value="{wallpaper_path}"/>\n'
            insert += f'          <property name="image-path" type="string" value="{wallpaper_path}"/>\n'
            new = re.sub(r'(\s*<property name="workspace0"[^>]*>\s*\n)', r'\1' + insert, new)
    if new != txt:
        write_file(xml, new)
        log(f"XFCE wallpaper: patched {xml} → {wallpaper_path}")
    else:
        log("XFCE wallpaper: no changes needed.")


def install_firstboot_wallpaper_fix(target_root: Path, wallpaper_path: str, log) -> None:
    service_dir = target_root / "etc" / "skel" / ".config" / "systemd" / "user"
    ensure_dir(service_dir)
    service_file = service_dir / "ages-wallpaper-fix.service"
    script_file = target_root / "etc" / "skel" / ".local" / "bin" / "ages-apply-wallpaper.sh"
    ensure_dir(script_file.parent)
    script_content = f'''#!/bin/bash
if command -v xfconf-query >/dev/null 2>&1; then
    xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor0/workspace0/last-image -s "{wallpaper_path}" 2>/dev/null || true
    xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor0/workspace0/image-path -s "{wallpaper_path}" 2>/dev/null || true
    xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor0/last-image -s "{wallpaper_path}" 2>/dev/null || true
    xfconf-query -c xfce4-desktop -p /backdrop/screen0/monitor0/image-path -s "{wallpaper_path}" 2>/dev/null || true
fi
systemctl --user disable ages-wallpaper-fix.service 2>/dev/null || true
rm -f ~/.config/systemd/user/ages-wallpaper-fix.service
'''
    write_file(script_file, script_content)
    script_file.chmod(0o755)
    service_content = '''[Unit]
Description=AGES First-Boot Wallpaper Fix
After=graphical-session.target

[Service]
Type=oneshot
ExecStart=%h/.local/bin/ages-apply-wallpaper.sh

[Install]
WantedBy=default.target
'''
    write_file(service_file, service_content)
    log("XFCE wallpaper: installed first-boot fix (systemd user service)")


# ============================================================
# Theme/icon defaults + LightDM greeter
# ============================================================
def list_installed_theme_dirs(target_root: Path) -> List[str]:
    themes_dir = target_root / "usr" / "share" / "themes"
    if not themes_dir.exists():
        return []
    return sorted([d.name for d in themes_dir.iterdir() if d.is_dir()])


def choose_best_theme_name(target_root: Path, preferred: str = "adw-gtk3-dark") -> str:
    themes = set(list_installed_theme_dirs(target_root))
    # Look for adw-gtk3-dark first (the actual installed theme)
    for p in [preferred, "adw-gtk3-dark", "adw-gtk3", "adw-gtk-dark", "adw-gtk", "Adwaita-dark", "Adwaita"]:
        if p in themes:
            return p
    return next(iter(themes), preferred)


def list_installed_icon_dirs(target_root: Path) -> List[str]:
    icons_dir = target_root / "usr" / "share" / "icons"
    if not icons_dir.exists():
        return []
    return sorted([d.name for d in icons_dir.iterdir() if d.is_dir()])


def choose_best_icon_theme(target_root: Path) -> str:
    icons = set(list_installed_icon_dirs(target_root))
    for p in ["Tela-circle-dark", "Tela-circle-black", "Tela-circle", "Tela", "Adwaita", "hicolor"]:
        if p in icons:
            return p
    return next(iter(icons), "Adwaita")


def write_default_gtk_settings_to_skel(target_root: Path, theme_name: str, icon_theme: str, log, cursor_theme: str = "Adwaita") -> None:
    ini = target_root / "etc" / "skel" / ".config" / "gtk-3.0" / "settings.ini"
    ensure_dir(ini.parent)
    content = (
        "[Settings]\n"
        f'gtk-theme-name="{theme_name}"\n'
        f'gtk-icon-theme-name="{icon_theme}"\n'
        f'gtk-cursor-theme-name="{cursor_theme}"\n'
        'gtk-font-name="Sans 10"\n'
    )
    write_file(ini, content)
    log(f"GTK default: wrote {ini} (theme={theme_name}, icons={icon_theme})")


def configure_lightdm_greeter(target_root: Path, background_path: Optional[str], log, theme_name: Optional[str], icon_theme: Optional[str]) -> None:
    conf = target_root / "etc" / "lightdm" / "lightdm-gtk-greeter.conf"
    ensure_dir(conf.parent)
    lines = ["[greeter]"]
    if background_path:
        lines.append(f"background={background_path}")
    if theme_name:
        lines.append(f"theme-name={theme_name}")
    if icon_theme:
        lines.append(f"icon-theme-name={icon_theme}")
    lines.append("font-name=Sans 10")
    lines.append("xft-antialias=true")
    lines.append("xft-hintstyle=hintfull")
    lines.append("xft-rgba=rgb")
    write_file(conf, "\n".join(lines) + "\n")
    log(f"LightDM: wrote {conf}")


# ============================================================
# Boot mode / filesystem / install mode
# ============================================================
BOOT_AUTO = "Auto (recommended)"
BOOT_UEFI = "UEFI"
BOOT_BIOS = "BIOS / Legacy"
FS_EXT4 = "ext4 (recommended)"
FS_BTRFS = "btrfs (snapshots-ready)"
FS_XFS = "xfs (fast, stable)"
MODE_ERASE = "ERASE DISK (automatic partitioning) — DESTRUCTIVE"
MODE_EXISTING = "USE EXISTING PARTITIONS (manual selection) — NO DISK WIPE"


def effective_boot_mode(selection: str) -> str:
    if selection == BOOT_UEFI:
        return "UEFI"
    if selection == BOOT_BIOS:
        return "BIOS"
    return "UEFI" if is_uefi() else "BIOS"


def effective_fs(selection: str) -> str:
    if selection.startswith("btrfs"):
        return "btrfs"
    if selection.startswith("xfs"):
        return "xfs"
    return "ext4"


# ============================================================
# Desktop environments + Window Managers + Display Managers
# ============================================================
DE_XFCE = "XFCE"
DE_GNOME = "GNOME"
DE_KDE = "KDE Plasma"
DE_CINNAMON = "Cinnamon"
DE_MATE = "MATE"
DE_LXQT = "LXQt"

# Window Managers
WM_I3 = "i3"
WM_OPENBOX = "Openbox"
WM_BSPWM = "Bspwm"
WM_AWESOME = "Awesome"
WM_QTILE = "Qtile"
WM_SWAY = "Sway"
WM_HYPRLAND = "Hyprland"

DM_AUTO = "Auto (based on selected DEs/WMs)"
DM_LIGHTDM = "LightDM"
DM_GDM = "GDM"
DM_SDDM = "SDDM"

DESKTOP_PACKAGES: Dict[str, List[str]] = {
    DE_XFCE: [
        "xorg-server",
        "xfce4", "xfce4-session", "xfce4-panel", "xfdesktop", "xfwm4", "xfce4-settings", "xfconf",
        "thunar", "tumbler", "gvfs", "xfce4-terminal",
        "file-roller", "pavucontrol", "xfce4-power-manager",
        "xfce4-goodies",
        "xfce4-whiskermenu-plugin",
        "xfce4-weather-plugin",
    ],
    DE_GNOME: ["xorg-server", "gnome", "gnome-terminal", "nautilus"],
    DE_KDE: ["xorg-server", "plasma", "konsole", "dolphin"],
    DE_CINNAMON: ["xorg-server", "cinnamon", "nemo", "gnome-terminal"],
    DE_MATE: ["xorg-server", "mate", "mate-terminal", "caja"],
    DE_LXQT: ["xorg-server", "lxqt", "qterminal", "pcmanfm-qt"],
    # Window Managers Packages
    WM_I3: ["xorg-server", "i3-wm", "i3status", "dmenu", "i3lock", "alacritty"],
    WM_OPENBOX: ["xorg-server", "openbox", "obconf-qt", "tint2", "alacritty", "lxappearance", "xorg-drivers", "feh", "papirus-icon-theme", "menumaker", "xterm", "xorg-xclock", "xorg-twm", "xorg-xinit", "dbus-broker", "pcmanfm"],
    WM_BSPWM: ["xorg-server", "bspwm", "sxhkd", "dmenu", "alacritty"],
    WM_AWESOME: ["xorg-server", "awesome", "vicious", "alacritty"],
    WM_QTILE: ["xorg-server", "qtile", "alacritty"],
    WM_SWAY: ["sway", "waybar", "wofi", "foot", "swaylock", "xdg-desktop-portal-wlr"],
    WM_HYPRLAND: ["hyprland", "waybar", "wofi", "kitty", "xdg-desktop-portal-hyprland"],
}

DM_PACKAGES: Dict[str, List[str]] = {
    DM_LIGHTDM: ["lightdm", "lightdm-gtk-greeter"],
    DM_GDM: ["gdm"],
    DM_SDDM: ["sddm"],
}

DE_SESSION_HINT: Dict[str, str] = {
    DE_XFCE: "xfce",
    DE_GNOME: "gnome",
    DE_KDE: "plasma",
    DE_CINNAMON: "cinnamon",
    DE_MATE: "mate",
    DE_LXQT: "lxqt",
    # Window Managers Session Hints
    WM_I3: "i3",
    WM_OPENBOX: "openbox",
    WM_BSPWM: "bspwm",
    WM_AWESOME: "awesome",
    WM_QTILE: "qtile",
    WM_SWAY: "sway",
    WM_HYPRLAND: "hyprland",
}


def choose_default_dm_for_desktops(desktops: List[str]) -> str:
    s = set(desktops or [])
    # GNOME prefers GDM
    if DE_GNOME in s:
        return DM_GDM
    # KDE and LXQt prefer SDDM
    if DE_KDE in s or DE_LXQT in s:
        return DM_SDDM
    # Default for XFCE, MATE, Cinnamon, and all Window Managers (i3, Hyprland, etc.)
    return DM_LIGHTDM


def choose_default_session(desktops: List[str]) -> str:
    # Priority list
    order = [DE_GNOME, DE_KDE, DE_XFCE, DE_CINNAMON, DE_MATE, DE_LXQT, WM_HYPRLAND, WM_I3, WM_SWAY, WM_OPENBOX]
    s = set(desktops or [])
    for d in order:
        if d in s:
            return DE_SESSION_HINT.get(d, "")
    if desktops:
        return DE_SESSION_HINT.get(desktops[0], "")
    return ""


# ============================================================
# Packages
# ============================================================
# Kernel options
KERNEL_MAINLINE = "linux"
KERNEL_ZEN = "linux-zen"
KERNEL_LTS = "linux-lts"

DEFAULT_BASE_PACKAGES_NO_KERNEL = [
    "base", "linux-firmware",
    "networkmanager", "sudo", "vim",
    "pipewire", "pipewire-pulse",
]

SAFE_XORG_DRIVERS = [
    "xf86-input-libinput",
    "xf86-video-amdgpu",
    "xf86-video-ati",
    "xf86-video-intel",
    "xf86-video-nouveau",
    "xf86-video-vesa",
]

ICON_PACKAGES = [
    "tela-circle-icon-theme-standard",
    "tela-circle-icon-theme-black",
    "tela-circle-icon-theme-grey",
]

AUR_PREREQS = ["base-devel", "git"]
PACKAGE_BLACKLIST = {
    "archiso", "mkarchiso", "calamares", "calamares-config", "calamares-config-xfce",
    "", "zram-generator", "reflector", "clonezilla", "memtest86+",
}


def parse_packages_text(txt: str) -> List[str]:
    pkgs: List[str] = []
    for line in (txt or "").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "#" in line:
            line = line.split("#", 1)[0].strip()
        for part in line.split():
            if part:
                pkgs.append(part)
    return pkgs


def read_packages_txt(path: Path) -> List[str]:
    if not path.exists():
        return []
    return parse_packages_text(read_text(path))


def normalize_package_set(pkgs: List[str]) -> List[str]:
    out = []
    seen = set()
    for p in pkgs:
        p = (p or "").strip()
        if not p:
            continue
        if p in PACKAGE_BLACKLIST:
            continue
        if p not in seen:
            seen.add(p)
            out.append(p)
    return out


def sanitize_package_list(pkgs: List[str], log) -> List[str]:
    out: List[str] = []
    for p in pkgs:
        if p == "xorg-drivers":
            log("Packages: replacing group 'xorg-drivers' with explicit safe driver packages.")
            out.extend(SAFE_XORG_DRIVERS)
            continue
        if p == "dracut-hook":
            log("Packages: removing 'dracut-hook' (not a repo package). Use 'dracut' + pacman hook instead.")
            continue
        out.append(p)
    seen = set()
    deduped = []
    for x in out:
        if x not in seen:
            seen.add(x)
            deduped.append(x)
    return deduped


def build_required_packages(kernel: str, mode: str, want_yay: bool, fs: str, desktops: List[str], dm: str) -> List[str]:
    micro = detect_microcode_pkg()
    base = list(DEFAULT_BASE_PACKAGES_NO_KERNEL)
    base.append(kernel)  # Add selected kernel
    base += ICON_PACKAGES
    if fs == "btrfs":
        base += ["btrfs-progs"]
    elif fs == "xfs":
        base += ["xfsprogs"]
    if mode == "UEFI":
        base += ["efibootmgr"]
    else:
        base += ["grub"]
    desktops = desktops or [DE_XFCE]
    for d in desktops:
        base += DESKTOP_PACKAGES.get(d, [])
    if dm in DM_PACKAGES:
        base += DM_PACKAGES[dm]
    if want_yay:
        base += AUR_PREREQS
    if micro:
        base.append(micro)
    return normalize_package_set(base)


def choose_package_list(
    kernel: str,
    mode: str,
    want_yay: bool,
    fs: str,
    desktops: List[str],
    dm: str,
    use_local_packages_txt: bool,
    log: Callable[[str], None]
) -> Tuple[List[str], str]:
    required = build_required_packages(kernel, mode, want_yay, fs, desktops, dm)
    
    # ALWAYS try to use the local EcoOS packages.txt file first
    try:
        local_path = find_ecoos_packages_file()
        custom = normalize_package_set(read_packages_txt(Path(local_path)))
        combined = normalize_package_set(custom + required)
        return combined, f"Local EcoOS list: {local_path} (+ required DE/DM packages)"
    except FileNotFoundError as e:
        log(f"!! Local EcoOS packages.txt not found: {e}")
    
    # Fallback to the original behavior
    if use_local_packages_txt and LIVE_PKG_LIST.exists():
        custom = normalize_package_set(read_packages_txt(LIVE_PKG_LIST))
        combined = normalize_package_set(custom + required)
        return combined, f"Local list: {LIVE_PKG_LIST} (+ required DE/DM packages)"
    
    return required, "Required safe package set (base + selected DEs + selected DM)"


def pacman_sync_live(log) -> None:
    if not cmd_ok("pacman"):
        log("!! pacman not found on Live ISO; cannot sync DB.")
        return
    log("Updating pacman databases on Live ISO (pacman -Syy)…")
    rc = run_stream(["pacman", "-Syy", "--noconfirm"], log, timeout=None)
    if rc != 0:
        log("!! pacman -Syy failed on Live ISO (continuing)")


def filter_available_repo_packages(pkgs: List[str], log, chunk: int = 60) -> Tuple[List[str], List[str]]:
    if not cmd_ok("pacman"):
        log("!! pacman not found on Live ISO; cannot pre-check packages.")
        return pkgs, []
    available: List[str] = []
    missing: List[str] = []
    to_check = [p for p in pkgs if p]
    for i in range(0, len(to_check), chunk):
        batch = to_check[i:i + chunk]
        cp = subprocess.run(["pacman", "-Si"] + batch,
                            stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        out = cp.stdout or ""
        if cp.returncode == 0:
            available.extend(batch)
            continue
        missing_in_batch = set(re.findall(r"error:\s+package\s+'([^']+)'\s+was\s+not\s+found", out))
        for p in batch:
            if p in missing_in_batch:
                missing.append(p)
            else:
                cp2 = subprocess.run(["pacman", "-Si", p],
                                     stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, text=True)
                if cp2.returncode == 0:
                    available.append(p)
                else:
                    missing.append(p)

    def dedupe(seq: List[str]) -> List[str]:
        s = set()
        out2 = []
        for x in seq:
            if x not in s:
                s.add(x)
                out2.append(x)
        return out2

    return dedupe(available), dedupe(missing)


def pacstrap_robust(mountpoint: str, pkgs: List[str], log) -> None:
    log("Packages to pacstrap (full set):")
    log("  " + " ".join(pkgs))
    rc = run_stream(["pacstrap", "-K", mountpoint, "--needed"] + pkgs, log, timeout=None)
    if rc == 0:
        return
    log("")
    log(f"!! pacstrap failed (rc={rc}). Will attempt one retry using a reduced set (best-effort).")
    log("   (Usually mirrors/internet, or a truly missing package.)")
    log("")
    pkgs_ok, pkgs_missing = filter_available_repo_packages(pkgs, log)
    if pkgs_missing:
        log("Packages likely missing (from precheck):")
        for m in pkgs_missing[:250]:
            log(f"  - {m}")
        if len(pkgs_missing) > 250:
            log(f"  ... and {len(pkgs_missing) - 250} more")
        log("Retrying pacstrap without these (best-effort)…")
    if not pkgs_ok:
        raise RuntimeError("pacstrap failed and no packages remained after best-effort filtering.")
    rc2 = run_stream(["pacstrap", "-K", mountpoint, "--needed"] + pkgs_ok, log, timeout=None)
    if rc2 != 0:
        raise RuntimeError(f"pacstrap failed again (rc={rc2}). Check internet/mirrors and package names.")


# ============================================================
# DRACUT (target-only) + pacman hook
# ============================================================
def enable_dracut_in_target(target_root: Path, log) -> None:
    log("Dracut: enabling dracut in target...")
    arch_chroot_soft(target_root, "pacman -Syy --noconfirm || true", log)
    arch_chroot_soft(target_root, "pacman -S --noconfirm --needed dracut || true", log)
    confd = target_root / "etc" / "dracut.conf.d"
    ensure_dir(confd)
    storm_conf = confd / "ages.conf"
    conf_txt = (
        "# AGES dracut config\n"
        "hostonly=yes\n"
        "compress=zstd\n"
        "# add_dracutmodules+=\" btrfs \"\n"
        "# If using LUKS: add_dracutmodules+=\" crypt \"\n"
    )
    try:
        write_file(storm_conf, conf_txt)
        log(f"Dracut: wrote {storm_conf}")
    except Exception as e:
        log(f"!! Dracut: failed to write dracut config: {e}")
    hooks_dir = target_root / "etc" / "pacman.d" / "hooks"
    ensure_dir(hooks_dir)
    hook_path = hooks_dir / "90-dracut.hook"
    hook_txt = (
        "[Trigger]\n"
        "Type = Path\n"
        "Operation = Install\n"
        "Operation = Upgrade\n"
        "Operation = Remove\n"
        "Target = usr/lib/modules/*/vmlinuz\n"
        "\n"
        "[Action]\n"
        "Description = Regenerating initramfs with dracut...\n"
        "When = PostTransaction\n"
        "Exec = /usr/bin/dracut --force --regenerate-all\n"
    )
    try:
        write_file(hook_path, hook_txt)
        log(f"Dracut: installed pacman hook {hook_path}")
    except Exception as e:
        log(f"!! Dracut: failed to write pacman hook: {e}")
    arch_chroot_soft(target_root, "dracut --force --regenerate-all || true", log)
    log("Dracut: done (best-effort).")


# ============================================================
# Display Manager enable + Autologin (bypass login screen)
# ============================================================
def enable_dm_service(target_root: Path, dm: str, log) -> None:
    svc = None
    if dm == DM_LIGHTDM:
        svc = "lightdm"
    elif dm == DM_GDM:
        svc = "gdm"
    elif dm == DM_SDDM:
        svc = "sddm"
    if not svc:
        log("DM: No display manager selected (skipping enable).")
        return
    arch_chroot(target_root, f"systemctl enable {svc}", log)
    log(f"DM: enabled {svc}")


def enable_lightdm_autologin(target_root: Path, username: str, log, session: str = "") -> None:
    confd = target_root / "etc" / "lightdm" / "lightdm.conf.d"
    ensure_dir(confd)
    drop = confd / "50-ages-autologin.conf"
    lines = ["[Seat:*]"]
    lines.append(f"autologin-user={username}")
    lines.append("autologin-user-timeout=0")
    if session:
        lines.append(f"user-session={session}")
    write_file(drop, "\n".join(lines) + "\n")
    log(f"LightDM: enabled autologin (drop-in) for '{username}' at {drop} (session={session or 'default'})")


def enable_gdm_autologin(target_root: Path, username: str, log) -> None:
    conf = target_root / "etc" / "gdm" / "custom.conf"
    ensure_dir(conf.parent)
    txt = read_text(conf) if conf.exists() else ""
    if not txt.strip():
        txt = "[daemon]\n#WaylandEnable=false\n\n"
    if "[daemon]" not in txt:
        txt = "[daemon]\n" + txt

    def set_or_add(key: str, value: str, block: str) -> str:
        if re.search(rf"(?m)^\s*{re.escape(key)}\s*=", block):
            return re.sub(rf"(?m)^\s*{re.escape(key)}\s*=.*$", f"{key}={value}", block)
        return block.rstrip() + f"\n{key}={value}\n"

    m = re.search(r"(?ms)^\[daemon\]\s*(.*?)(?=^\[|\Z)", txt)
    if m:
        daemon_block = "[daemon]\n" + m.group(1)
        daemon_block2 = set_or_add("AutomaticLoginEnable", "True", daemon_block)
        daemon_block2 = set_or_add("AutomaticLogin", username, daemon_block2)
        txt = txt[:m.start()] + daemon_block2 + txt[m.end():]
    else:
        txt = txt.rstrip() + f"\n[daemon]\nAutomaticLoginEnable=True\nAutomaticLogin={username}\n"

    write_file(conf, txt if txt.endswith("\n") else txt + "\n")
    log(f"GDM: enabled autologin for '{username}' in {conf}")


def enable_sddm_autologin(target_root: Path, username: str, log, session: str = "") -> None:
    confd = target_root / "etc" / "sddm.conf.d"
    ensure_dir(confd)
    drop = confd / "50-ages-autologin.conf"
    lines = ["[Autologin]"]
    lines.append(f"User={username}")
    if session:
        lines.append(f"Session={session}")
    write_file(drop, "\n".join(lines) + "\n")
    log(f"SDDM: enabled autologin (drop-in) for '{username}' at {drop} (session={session or 'default'})")


# ============================================================
# Robust XFCE plugin ensure + panel config patch (prevents popups)
# ============================================================
def patch_xfce_panel_config_remove_missing_plugins(target_root: Path, missing_pkgs: List[str], log) -> None:
    want_remove = set()
    if any("whisker" in x for x in missing_pkgs):
        want_remove.update(["whiskermenu", "xfce4-whiskermenu-plugin", "whisker"])
    if any("weather" in x for x in missing_pkgs):
        want_remove.update(["weather", "xfce4-weather-plugin"])

    panel_dir = target_root / "etc" / "skel" / ".config" / "xfce4" / "xfconf" / "xfce-perchannel-xml"
    panel_xml = panel_dir / "xfce4-panel.xml"
    if not panel_xml.exists():
        log("XFCE panel patch: xfce4-panel.xml not found in skel; skipping.")
        return

    txt = read_text(panel_xml)
    if not txt.strip():
        log("XFCE panel patch: unable to read xfce4-panel.xml; skipping.")
        return

    before = txt
    for token in sorted(want_remove, key=len, reverse=True):
        txt = re.sub(
            rf'(?ms)\n?\s*<property[^>]+name="plugin-[^"]+"[^>]*>.*?{re.escape(token)}.*?</property>\s*',
            "\n",
            txt
        )
        txt = re.sub(rf'(?m)^.*{re.escape(token)}.*\n', "", txt)

    txt = re.sub(r"\n{3,}", "\n\n", txt)

    if txt != before:
        write_file(panel_xml, txt)
        log(f"XFCE panel patch: removed missing plugin references in {panel_xml}")
    else:
        log("XFCE panel patch: no changes made (pattern not found).")


def ensure_xfce_panel_plugins(target_root: Path, log) -> None:
    wanted = ["xfce4-whiskermenu-plugin", "xfce4-weather-plugin"]
    rc = arch_chroot_soft(target_root, "command -v pacman >/dev/null 2>&1", log)
    if rc != 0:
        log("XFCE plugins: pacman not present in target (unexpected); skipping.")
        return
    missing = []
    for pkg in wanted:
        rcq = arch_chroot_soft(target_root, f"pacman -Q {shlex.quote(pkg)} >/dev/null 2>&1", log)
        if rcq != 0:
            missing.append(pkg)
    if not missing:
        log("XFCE plugins: whisker/weather already installed.")
        return
    log("XFCE plugins: attempting to install missing: " + ", ".join(missing))
    arch_chroot_soft(target_root, "pacman -Syy --noconfirm", log)
    for attempt in range(1, 4):
        rc2 = arch_chroot_soft(
            target_root,
            "pacman -S --noconfirm --needed " + " ".join(shlex.quote(x) for x in missing),
            log
        )
        if rc2 == 0:
            log("XFCE plugins: installed successfully.")
            return
        log(f"!! XFCE plugins install attempt {attempt} failed (rc={rc2}); retrying…")
        time.sleep(2)
    log("!! XFCE plugins: failed to install after retries.")
    log("   Will patch /etc/skel XFCE panel config to remove missing plugin items (to prevent popups).")
    patch_xfce_panel_config_remove_missing_plugins(target_root, missing, log)


def _xfce_plugin_so_exists(target_root: Path, so_name_contains: str) -> bool:
    try:
        base = target_root / "usr" / "lib" / "xfce4" / "panel" / "plugins"
        if not base.exists():
            return False
        for p in base.iterdir():
            if p.is_file() and so_name_contains.lower() in p.name.lower():
                return True
    except Exception:
        pass
    return False


def ensure_xfce_panel_plugins_guarantee_best_effort(target_root: Path, log) -> None:
    log("XFCE plugins (guarantee best-effort): starting...")
    mega = [
        "xfce4-goodies",
        "xfce4-whiskermenu-plugin",
        "xfce4-weather-plugin",
        "xfce4-pulseaudio-plugin",
        "xfce4-systemload-plugin",
        "xfce4-cpugraph-plugin",
        "xfce4-netload-plugin",
        "xfce4-diskperf-plugin",
        "xfce4-sensors-plugin",
        "xfce4-clipman-plugin",
    ]
    arch_chroot_soft(target_root, "pacman -Syy --noconfirm || true", log)
    for attempt in range(1, 4):
        rc = arch_chroot_soft(
            target_root,
            "pacman -S --noconfirm --needed " + " ".join(shlex.quote(x) for x in mega),
            log
        )
        if rc == 0:
            log("XFCE plugins: mega-pack installed successfully.")
            break
        log(f"!! XFCE plugins: mega-pack install attempt {attempt} failed (rc={rc}); retrying…")
        time.sleep(2)

    ensure_xfce_panel_plugins(target_root, log)

    missing_pkgs: List[str] = []
    if not _xfce_plugin_so_exists(target_root, "whisker") and not _xfce_plugin_so_exists(target_root, "whiskermenu"):
        missing_pkgs.append("xfce4-whiskermenu-plugin")
    if not _xfce_plugin_so_exists(target_root, "weather"):
        missing_pkgs.append("xfce4-weather-plugin")

    if missing_pkgs:
        log("!! XFCE plugins: after best-effort installs, some key plugin .so files still appear missing:")
        for m in missing_pkgs:
            log(f"  - {m}")
        log("   Patching skel panel config to remove missing plugin references (prevents popups).")
        patch_xfce_panel_config_remove_missing_plugins(target_root, missing_pkgs, log)
    else:
        log("XFCE plugins: key plugin .so files detected. Best-effort guarantee succeeded.")

    log("XFCE plugins (guarantee best-effort): done.")


# ============================================================
# AUR: yay (best-effort)
# ============================================================
def enforce_makepkg_no_debug(target_root: Path, log) -> str:
    p = target_root / "etc" / "makepkg.conf"
    orig = read_text(p) if p.exists() else ""
    if not orig.strip():
        log("AUR: /etc/makepkg.conf missing/empty; skipping debug enforcement.")
        return orig
    new = orig
    m = re.search(r'(?m)^\s*OPTIONS=\(([^)]*)\)\s*$', new)
    if m:
        inside = m.group(1).strip()
        tokens = inside.split()
        if "!debug" not in tokens:
            tokens.append("!debug")
        tokens = [t for t in tokens if t != "debug"]
        repl = "OPTIONS=(" + " ".join(tokens) + ")"
        new = re.sub(r'(?m)^\s*OPTIONS=\(([^)]*)\)\s*$', repl, new)
    else:
        new = new.rstrip() + "\nOPTIONS=(!debug)\n"
    if new != orig:
        write_file(p, new)
        log("AUR: enforced !debug in /etc/makepkg.conf.")
    return orig


def restore_makepkg_conf(target_root: Path, original: str, log) -> None:
    p = target_root / "etc" / "makepkg.conf"
    if original:
        write_file(p, original)
        log("AUR: restored original /etc/makepkg.conf.")


def install_yay_best_effort(target_root: Path, log) -> None:
    log("AUR: attempting to install yay (best-effort)…")
    arch_chroot_soft(target_root, "install -d -m 1777 /tmp", log)
    rc = arch_chroot_soft(target_root, "pacman -S --noconfirm --needed base-devel git sudo", log)
    if rc != 0:
        log("!! AUR: failed to install base-devel/git/sudo. Skipping yay.")
        return

    arch_chroot_soft(target_root, "id -u aurbuilder >/dev/null 2>&1 || useradd -m -s /bin/bash aurbuilder", log)
    orig = enforce_makepkg_no_debug(target_root, log)
    try:
        arch_chroot_soft(target_root, "rm -rf /tmp/aur-yay", log)
        rc = arch_chroot_soft(
            target_root,
            "sudo -u aurbuilder bash -lc 'git clone --depth 1 https://aur.archlinux.org/yay.git /tmp/aur-yay'",
            log
        )
        if rc != 0:
            log("!! AUR: git clone yay failed. Skipping yay.")
            return
        rc = arch_chroot_soft(
            target_root,
            "sudo -u aurbuilder bash -lc 'set -e; cd /tmp/aur-yay; makepkg -s --noconfirm --needed --skippgpcheck;'",
            log
        )
        if rc != 0:
            log("!! AUR: makepkg build failed. Skipping yay.")
            return
        rc = arch_chroot_soft(
            target_root,
            "bash -lc 'set -e; ls -1 /tmp/aur-yay/yay-*.pkg.tar.* | head -n1 | xargs -r pacman -U --noconfirm'",
            log
        )
        if rc != 0:
            log("!! AUR: pacman -U yay failed. Skipping yay.")
            return
        log("AUR: yay installed successfully.")
    finally:
        restore_makepkg_conf(target_root, orig, log)
        arch_chroot_soft(target_root, "rm -rf /tmp/aur-yay /tmp/yay-bin /tmp/yay 2>/dev/null || true", log)
        arch_chroot_soft(target_root, "rm -f /etc/skel/Desktop/calamares.desktop 2>/dev/null || true", log)
        arch_chroot_soft(target_root, "rm -f /root/Desktop/calamares.desktop 2>/dev/null || true", log)
        arch_chroot_soft(target_root, r"find /home -maxdepth 3 -type f -name '*.desktop' -path '*/Desktop/*' -delete 2>/dev/null || true", log)
        arch_chroot_soft(target_root, "userdel -r aurbuilder 2>/dev/null || true", log)
        arch_chroot_soft(target_root, "getent group aurbuilder >/dev/null 2>&1 && groupdel aurbuilder 2>/dev/null || true", log)
        log("AUR cleanup: removed yay build dirs, calamares.desktop (Desktop), and 'aurbuilder'.")


# ============================================================
# Timezone / keymap helpers
# ============================================================
def guess_live_timezone() -> str:
    # Try location detection first
    try:
        location = LocationDetector.detect_location()
        if location.get("timezone"):
            return location["timezone"]
    except Exception:
        pass
    
    # Fall back to original methods
    try:
        lt = Path("/etc/localtime")
        if lt.is_symlink():
            target = os.readlink(str(lt))
            if "/usr/share/zoneinfo/" in target:
                return target.split("/usr/share/zoneinfo/", 1)[1]
    except Exception:
        pass
    
    return "America/New_York"


def list_timezones_lite(max_items: int = 2000) -> List[str]:
    base = Path("/usr/share/zoneinfo")
    if not base.exists():
        return ["UTC", "America/New_York"]
    out = []
    for root, dirs, files in os.walk(str(base)):
        rp = Path(root)
        rel = rp.relative_to(base)
        if rel.parts and rel.parts[0] in {"posix", "right"}:
            continue
        for f in files:
            p = rp / f
            if f in {"zone.tab", "zone1970.tab", "leapseconds", "tzdata.zi"}:
                continue
            if p.is_symlink():
                continue
            relp = p.relative_to(base)
            if len(relp.parts) >= 2:
                out.append("/".join(relp.parts))
    out = sorted(set(out))
    if len(out) > max_items:
        preferred = [z for z in out if z.startswith(("America/", "Europe/", "Asia/", "Australia/", "Africa/"))]
        out2 = ["UTC"] + preferred[:max_items - 1]
        return sorted(set(out2))
    return ["UTC"] + out


def guess_live_keymap() -> str:
    # Try to infer from location
    try:
        location = LocationDetector.detect_location()
        country = location.get("country", "").lower()
        
        # Country to keymap mapping
        mapping = {
            "united states": "us",
            "united kingdom": "uk",
            "germany": "de",
            "france": "fr",
            "spain": "es",
            "italy": "it",
            "portugal": "pt",
            "brazil": "br-abnt2",
            "russia": "ru",
            "japan": "jp106",
            "korea": "kr",
            "china": "cn",
        }
        
        for country_name, keymap in mapping.items():
            if country_name in country:
                return keymap
    except Exception:
        pass
    
    # Fall back to original method
    if cmd_ok("localectl"):
        try:
            cp = subprocess.run(["localectl", "status"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            t = cp.stdout or ""
            m = re.search(r"VC Keymap:\s*([A-Za-z0-9_-]+)", t)
            if m:
                return m.group(1).strip()
        except Exception:
            pass
    
    return "us"


def common_keymaps() -> List[str]:
    return [
        "us", "uk", "de", "fr", "es", "it", "pt", "br-abnt2", "ca", "dvorak", "colemak",
        "ru", "ua", "pl", "nl", "se", "no", "fi", "dk", "cz", "sk", "hu", "tr",
        "jp106", "kr", "cn", "in", "latam"
    ]


# ============================================================
# BTRFS Restore Point (best-effort)
# ============================================================
@dataclass
class RestorePoint:
    enabled: bool = False
    root_part: str = ""
    created: bool = False
    ts: str = ""
    mounted_subvol: str = ""
    snap_root: str = ""
    snap_home: str = ""
    notes: str = ""


def btrfs_create_restore_point_existing_nofmt(root_part: str, log) -> RestorePoint:
    rp = RestorePoint(enabled=True, root_part=root_part)
    ts = time.strftime("%Y%m%d-%H%M%S")
    rp.ts = ts
    if not cmd_ok("btrfs"):
        rp.notes = "btrfs tool not present on Live ISO."
        log(f"Restore point: disabled ({rp.notes})")
        return rp
    tmp = f"/tmp/ages_btrfs_restore_{ts}"
    ensure_dir(Path(tmp))
    try:
        log(f"Restore point: mounting BTRFS root {root_part} -> {tmp} (top-level)")
        rc = run_stream(["mount", root_part, tmp], log, timeout=30)
        if rc != 0:
            rp.notes = "Failed to mount BTRFS root partition."
            log(f"Restore point: disabled ({rp.notes})")
            return rp
        has_at = Path(tmp, "@").exists()
        has_home = Path(tmp, "@home").exists()
        if has_at:
            rp.mounted_subvol = "@"
            rp.snap_root = f"@ages-preinstall-{ts}"
            log(f"Restore point: snapshotting @ -> {rp.snap_root}")
            rc = run_stream(["btrfs", "subvolume", "snapshot", "-r", f"{tmp}/@", f"{tmp}/{rp.snap_root}"], log, timeout=60)
            if rc != 0:
                rc2 = run_stream(["btrfs", "subvolume", "snapshot", f"{tmp}/@", f"{tmp}/{rp.snap_root}"], log, timeout=60)
                if rc2 != 0:
                    rp.notes = "Failed to snapshot @"
                    log(f"Restore point: failed ({rp.notes})")
                    return rp
            if has_home:
                rp.snap_home = f"@home-ages-preinstall-{ts}"
                log(f"Restore point: snapshotting @home -> {rp.snap_home}")
                rc = run_stream(["btrfs", "subvolume", "snapshot", "-r", f"{tmp}/@home", f"{tmp}/{rp.snap_home}"], log, timeout=60)
                if rc != 0:
                    rc2 = run_stream(["btrfs", "subvolume", "snapshot", f"{tmp}/@home", f"{tmp}/{rp.snap_home}"], log, timeout=60)
                    if rc2 != 0:
                        log("Restore point: WARNING: @home snapshot failed (continuing with @ snapshot only).")
                        rp.snap_home = ""
        else:
            rp.mounted_subvol = ""
            rp.snap_root = f"ages-preinstall-{ts}"
            log(f"Restore point: no '@' found. Snapshotting top-level -> {rp.snap_root}")
            rc = run_stream(["btrfs", "subvolume", "snapshot", "-r", tmp, f"{tmp}/{rp.snap_root}"], log, timeout=60)
            if rc != 0:
                rc2 = run_stream(["btrfs", "subvolume", "snapshot", tmp, f"{tmp}/{rp.snap_root}"], log, timeout=60)
                if rc2 != 0:
                    rp.notes = "Failed to snapshot top-level BTRFS."
                    log(f"Restore point: failed ({rp.notes})")
                    return rp
        rp.created = True
        rp.notes = "Restore point created."
        log(f"Restore point: ✅ created (ts={ts})")
        log("Restore point notes:")
        log("  - This is BEST-EFFORT. Always keep backups.")
        log("  - On failure, installer will attempt rollback if safe; otherwise manual rollback needed.")
        return rp
    finally:
        try:
            run_stream(["umount", tmp], log, timeout=20)
        except Exception:
            pass
        try:
            shutil.rmtree(tmp, ignore_errors=True)
        except Exception:
            pass


def btrfs_best_effort_rollback(rp: RestorePoint, log) -> None:
    if not rp or not rp.created or not rp.snap_root:
        return
    if not cmd_ok("btrfs"):
        log("Rollback: btrfs tool missing; cannot rollback.")
        return
    ts = rp.ts or time.strftime("%Y%m%d-%H%M%S")
    tmp = f"/tmp/ages_btrfs_rollback_{ts}"
    ensure_dir(Path(tmp))
    try:
        log(f"Rollback: mounting {rp.root_part} -> {tmp} (top-level)")
        rc = run_stream(["mount", rp.root_part, tmp], log, timeout=30)
        if rc != 0:
            log("Rollback: failed to mount root partition; cannot rollback.")
            return
        has_at = Path(tmp, "@").exists()
        snap_root_path = Path(tmp, rp.snap_root)
        if has_at and snap_root_path.exists():
            log(f"Rollback: attempting to restore '@' from snapshot '{rp.snap_root}'")
            bad_name = f"@ages-bad-{ts}"
            if Path(tmp, "@").exists():
                log(f"Rollback: snapshotting current @ -> {bad_name} then deleting @ (best-effort)")
                run_stream(["btrfs", "subvolume", "snapshot", f"{tmp}/@", f"{tmp}/{bad_name}"], log, timeout=120)
                run_stream(["btrfs", "subvolume", "delete", f"{tmp}/@"], log, timeout=120)
            rc2 = run_stream(["btrfs", "subvolume", "snapshot", f"{tmp}/{rp.snap_root}", f"{tmp}/@"], log, timeout=120)
            if rc2 != 0:
                log("Rollback: failed to snapshot snapshot->@. Manual rollback required.")
                return
            if rp.snap_home and Path(tmp, "@home").exists() and Path(tmp, rp.snap_home).exists():
                log(f"Rollback: attempting to restore '@home' from snapshot '{rp.snap_home}' (best-effort)")
                bad_home = f"@home-ages-bad-{ts}"
                run_stream(["btrfs", "subvolume", "snapshot", f"{tmp}/@home", f"{tmp}/{bad_home}"], log, timeout=120)
                run_stream(["btrfs", "subvolume", "delete", f"{tmp}/@home"], log, timeout=120)
                run_stream(["btrfs", "subvolume", "snapshot", f"{tmp}/{rp.snap_home}", f"{tmp}/@home"], log, timeout=120)
            log("Rollback: ✅ best-effort rollback completed.")
        else:
            log("Rollback: cannot find expected '@' layout or snapshot path. Manual rollback required.")
        log("Rollback manual hints (if needed):")
        log(f"  1) mount {rp.root_part} /mnt  (top-level)")
        log(f"  2) btrfs subvolume list /mnt")
        log(f"  3) btrfs subvolume snapshot /mnt/{rp.snap_root} /mnt/@   (if using @ layout)")
        log(f"  4) umount /mnt")
    finally:
        try:
            run_stream(["umount", tmp], log, timeout=20)
        except Exception:
            pass
        try:
            shutil.rmtree(tmp, ignore_errors=True)
        except Exception:
            pass


# ============================================================
# Partition + Mount helpers
# ============================================================
def mkfs_ext4(dev: str, label: str, log) -> None:
    log(f"Formatting ext4: {dev} label={label}")
    rc = run_stream(["mkfs.ext4", "-F", "-L", label, dev], log, timeout=None)
    if rc != 0:
        raise RuntimeError(f"mkfs.ext4 failed: {dev}")


def mkfs_xfs(dev: str, label: str, log) -> None:
    log(f"Formatting xfs: {dev} label={label}")
    rc = run_stream(["mkfs.xfs", "-f", "-L", label, dev], log, timeout=None)
    if rc != 0:
        raise RuntimeError(f"mkfs.xfs failed: {dev}")


def mkfs_btrfs(dev: str, label: str, log) -> None:
    log(f"Formatting btrfs: {dev} label={label}")
    rc = run_stream(["mkfs.btrfs", "-f", "-L", label, dev], log, timeout=None)
    if rc != 0:
        raise RuntimeError(f"mkfs.btrfs failed: {dev}")


def mkfs_fat32(dev: str, label: str, log) -> None:
    log(f"Formatting EFI (FAT32): {dev} label={label}")
    rc = run_stream(["mkfs.fat", "-F32", "-n", label, dev], log, timeout=None)
    if rc != 0:
        raise RuntimeError(f"mkfs.fat failed: {dev}")


def wipe_and_partition_erase(disk: str, boot: str, fs: str, log) -> Tuple[str, Optional[str]]:
    prepare_disk_for_partitioning(disk, log)
    if not cmd_ok("wipefs") or not cmd_ok("sgdisk"):
        raise RuntimeError("Missing required tools: wipefs and/or sgdisk on Live ISO.")
    log(f"ERASE: wiping signatures on {disk}")
    run_stream(["wipefs", "-a", disk], log, timeout=None)
    log(f"ERASE: zapping GPT/MBR on {disk}")
    run_stream(["sgdisk", "--zap-all", disk], log, timeout=None)
    if boot == "UEFI":
        log("ERASE: creating GPT partitions (UEFI: EFI 512M + ROOT rest)")
        run_stream(["sgdisk", "-o", disk], log, timeout=None)
        run_stream(["sgdisk", "-n", "1:0:+512M", "-t", "1:ef00", "-c", "1:EFI", disk], log, timeout=None)
        run_stream(["sgdisk", "-n", "2:0:0", "-t", "2:8300", "-c", "2:ROOT", disk], log, timeout=None)
        efi = partition_path(disk, 1)
        root = partition_path(disk, 2)
        run_stream(["partprobe", disk], log, timeout=30)
        run_stream(["udevadm", "settle"], log, timeout=30)
        return root, efi
    else:
        log("ERASE: creating GPT partitions (BIOS: bios_grub 2M + ROOT rest)")
        run_stream(["sgdisk", "-o", disk], log, timeout=None)
        run_stream(["sgdisk", "-n", "1:0:+2M", "-t", "1:ef02", "-c", "1:BIOSGRUB", disk], log, timeout=None)
        run_stream(["sgdisk", "-n", "2:0:0", "-t", "2:8300", "-c", "2:ROOT", disk], log, timeout=None)
        root = partition_path(disk, 2)
        run_stream(["partprobe", disk], log, timeout=30)
        run_stream(["udevadm", "settle"], log, timeout=30)
        return root, None


def mount_root_fs(root_part: str, fs: str, target: str, log) -> None:
    ensure_dir(Path(target))
    if fs == "btrfs":
        log(f"Mounting BTRFS top-level: {root_part} -> {target} (create subvols)")
        run_stream(["mount", root_part, target], log, timeout=30)
        for sub in ["@", "@home"]:
            p = Path(target) / sub
            if not p.exists():
                run_stream(["btrfs", "subvolume", "create", str(p)], log, timeout=60)
        run_stream(["umount", target], log, timeout=20)
        opts = "rw,relatime,ssd,space_cache=v2,compress=zstd:3,subvol=@"
        log(f"Mounting BTRFS @: {root_part} -> {target} opts={opts}")
        run_stream(["mount", "-o", opts, root_part, target], log, timeout=30)
        ensure_dir(Path(target) / "home")
        opts_home = "rw,relatime,ssd,space_cache=v2,compress=zstd:3,subvol=@home"
        log(f"Mounting BTRFS @home: {root_part} -> {target}/home opts={opts_home}")
        run_stream(["mount", "-o", opts_home, root_part, f"{target}/home"], log, timeout=30)
    else:
        log(f"Mounting root: {root_part} -> {target}")
        rc = run_stream(["mount", root_part, target], log, timeout=30)
        if rc != 0:
            raise RuntimeError(f"Failed to mount root partition: {root_part}")


def mount_efi(efi_part: str, target_root: str, log) -> None:
    mp = Path(target_root) / "boot" / "efi"
    ensure_dir(mp)
    log(f"Mounting EFI: {efi_part} -> {mp}")
    rc = run_stream(["mount", efi_part, str(mp)], log, timeout=30)
    if rc != 0:
        raise RuntimeError(f"Failed to mount EFI partition: {efi_part}")


def write_fstab(target_root: Path, log) -> None:
    if not cmd_ok("genfstab"):
        log("!! genfstab not found; fstab may be incomplete.")
        return
    log("Generating fstab (genfstab -U)…")
    cp = subprocess.run(["genfstab", "-U", str(target_root)],
                        stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
    if (cp.stdout or "").strip():
        write_file(target_root / "etc" / "fstab", cp.stdout if cp.stdout.endswith("\n") else cp.stdout + "\n")
        log("fstab written to /etc/fstab")
    else:
        log("!! genfstab returned empty output; fstab may be missing.")


# ============================================================
# System configuration inside target
# ============================================================
def write_basic_system_files(target_root: Path, hostname: str, tz: str, keymap: str, locale: str, log) -> None:
    write_file(target_root / "etc" / "hostname", hostname.strip() + "\n")
    hosts = (
        "127.0.0.1\tlocalhost\n"
        "::1\t\tlocalhost\n"
        f"127.0.1.1\t{hostname}.localdomain\t{hostname}\n"
    )
    write_file(target_root / "etc" / "hosts", hosts)
    log("Wrote /etc/hostname and /etc/hosts")
    zone = target_root / "usr" / "share" / "zoneinfo" / tz
    if zone.exists():
        arch_chroot(target_root, f"ln -sf /usr/share/zoneinfo/{shlex.quote(tz)} /etc/localtime", log)
        arch_chroot(target_root, "hwclock --systohc", log)
        log(f"Timezone set: {tz}")
    else:
        log(f"!! Timezone {tz} not found in target; skipping.")
    locale_gen = target_root / "etc" / "locale.gen"
    lg = read_text(locale_gen)
    if not lg.strip():
        lg = "# locale.gen generated by AGES installer\n"
    if re.search(rf"(?m)^\s*#\s*{re.escape(locale)}\s+UTF-8\s*$", lg):
        lg = re.sub(rf"(?m)^\s*#\s*({re.escape(locale)}\s+UTF-8\s*)$", r"\1", lg)
    elif not re.search(rf"(?m)^\s*{re.escape(locale)}\s+UTF-8\s*$", lg):
        lg = lg.rstrip() + f"\n{locale} UTF-8\n"
    write_file(locale_gen, lg if lg.endswith("\n") else lg + "\n")
    arch_chroot(target_root, "locale-gen", log)
    write_file(target_root / "etc" / "locale.conf", f"LANG={locale}\n")
    log(f"Locale set: {locale}")
    write_file(target_root / "etc" / "vconsole.conf", f"KEYMAP={keymap}\n")
    log(f"Keymap set: {keymap} (wrote /etc/vconsole.conf)")


def setup_users(target_root: Path, username: str, user_password: str, root_password: str, log) -> None:
    arch_chroot(target_root, "sed -i 's/^# %wheel ALL=(ALL:ALL) ALL/%wheel ALL=(ALL:ALL) ALL/' /etc/sudoers", log)
    arch_chroot_soft(target_root, f"id -u {shlex.quote(username)} >/dev/null 2>&1 || useradd -m -G wheel -s /bin/bash {shlex.quote(username)}", log)
    arch_chroot_input(target_root, "chpasswd", f"root:{root_password}\n{username}:{user_password}\n", log)
    log(f"User setup complete: {username} (+ root password set)")


def ensure_user_home_gets_skel_best_effort(target_root: Path, username: str, log) -> None:
    u = shlex.quote(username)
    log(f"Skel: best-effort applying /etc/skel -> /home/{username}")
    arch_chroot_soft(
        target_root,
        f"command -v rsync >/dev/null 2>&1 && rsync -a /etc/skel/ /home/{u}/ || cp -a /etc/skel/. /home/{u}/ 2>/dev/null || true",
        log
    )
    arch_chroot_soft(
        target_root,
        f"chown -R {u}:{u} /home/{u} 2>/dev/null || true",
        log
    )


def enable_base_services(target_root: Path, log) -> None:
    arch_chroot_soft(target_root, "systemctl enable NetworkManager", log)
    arch_chroot_soft(target_root, "systemctl enable systemd-timesyncd", log)
    log("Enabled base services: NetworkManager, systemd-timesyncd (best-effort)")


def _disk_is_gpt(disk: str) -> bool:
    if not cmd_ok("sgdisk"):
        return False
    try:
        cp = subprocess.run(["sgdisk", "-p", disk], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        out = (cp.stdout or "").lower()
        return ("gpt" in out) or ("partition table holds up to" in out)
    except Exception:
        return False


def _gpt_has_bios_grub(disk: str) -> bool:
    if not cmd_ok("sgdisk"):
        return False
    try:
        cp = subprocess.run(["sgdisk", "-p", disk], stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
        out = (cp.stdout or "").lower()
        # look for ef02 type
        return "ef02" in out or "bios boot" in out
    except Exception:
        return False


def install_bootloader(target_root: Path, boot: str, disk: str, fs: str, log) -> None:
    if boot != "UEFI":
        # BIOS/Legacy safety: GRUB on GPT needs BIOS Boot Partition (ef02). Without it, you get blocklists errors on btrfs.
        if _disk_is_gpt(disk) and not _gpt_has_bios_grub(disk):
            raise RuntimeError(
                "GRUB BIOS install on a GPT disk requires a BIOS Boot Partition (type EF02).\n"
                "Your disk appears to be GPT but has NO BIOS Boot Partition.\n\n"
                "Fix options:\n"
                "  1) Re-run in ERASE mode (BIOS) so installer creates BIOSGRUB automatically, OR\n"
                "  2) Manually create a 1–2MiB BIOS Boot Partition (EF02) on the target disk, OR\n"
                "  3) Switch to UEFI install (recommended if your system supports it).\n"
            )
        if fs == "btrfs" and _disk_is_gpt(disk) and not _gpt_has_bios_grub(disk):
            raise RuntimeError(
                "BIOS + GPT + BTRFS without BIOSGRUB causes GRUB blocklists error.\n"
                "Create BIOS Boot Partition (EF02) or use ERASE mode to create it."
            )
        arch_chroot_soft(target_root, "pacman -S --noconfirm --needed grub", log)
        arch_chroot(target_root, f"grub-install --target=i386-pc {shlex.quote(disk)} --recheck", log)
        arch_chroot(target_root, "grub-mkconfig -o /boot/grub/grub.cfg", log)
        log("Bootloader installed: GRUB (BIOS/Legacy)")
        return

    if not Path("/sys/firmware/efi").exists():
        raise RuntimeError(
            "UEFI was selected, but the system does NOT appear to be booted in UEFI mode.\n"
            "Reboot the Live USB and choose the UEFI boot entry in your firmware boot menu."
        )

    esp = target_root / "boot" / "efi"
    if not esp.exists():
        raise RuntimeError("ESP mountpoint missing: /mnt/boot/efi (internal error).")
    cp = subprocess.run(["mountpoint", "-q", str(esp)])
    if cp.returncode != 0:
        raise RuntimeError(
            "EFI System Partition is not mounted at /mnt/boot/efi.\n"
            "Go back to Partitions step and ensure you selected the EFI partition, "
            "and that it is mounted before installing the bootloader."
        )

    arch_chroot_soft(target_root, "pacman -Syy --noconfirm", log)
    arch_chroot_soft(target_root, "pacman -S --noconfirm --needed grub efibootmgr dosfstools mtools", log)
    arch_chroot_soft(
        target_root,
        "mountpoint -q /sys/firmware/efi/efivars || mount -t efivarfs efivarfs /sys/firmware/efi/efivars",
        log
    )

    cmd1 = "grub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=AGES --recheck"
    try:
        arch_chroot(target_root, cmd1, log)
        arch_chroot(target_root, "grub-mkconfig -o /boot/grub/grub.cfg", log)
        log("Bootloader installed: GRUB (UEFI, NVRAM entry created)")
        return
    except Exception as e:
        log(f"!! grub-install normal UEFI failed: {e}")
        log("!! Retrying with --removable --no-nvram (works when NVRAM writes are blocked)…")

    cmd2 = (
        "grub-install --target=x86_64-efi --efi-directory=/boot/efi "
        "--bootloader-id=AGES --recheck --removable --no-nvram"
    )
    arch_chroot(target_root, cmd2, log)
    arch_chroot(target_root, "grub-mkconfig -o /boot/grub/grub.cfg", log)
    log("Bootloader installed: GRUB (UEFI fallback: removable path, no NVRAM write)")


# ============================================================
# Installer configuration
# ============================================================
@dataclass
class InstallerConfig:
    kernel: str = KERNEL_MAINLINE
    boot_mode: str = "UEFI"
    fs: str = "ext4"
    install_mode: str = MODE_ERASE
    disk: str = ""
    root_part: str = ""
    efi_part: str = ""
    format_root: bool = True
    format_efi: bool = True

    hostname: str = "arch"
    username: str = "user"
    user_password: str = ""
    root_password: str = ""  # if empty -> use user_password

    timezone: str = "America/New_York"
    keymap: str = "us"
    locale: str = "en_US.UTF-8"

    desktops: List[str] = None
    dm: str = DM_AUTO
    autologin: bool = True
    want_yay: bool = True

    use_local_packages_txt: bool = True

    restore_point_enabled: bool = False

    use_dracut: bool = False
    copy_oh_my_bash: bool = True
    live_user: str = "liveuser"


# ============================================================
# Install thread
# ============================================================
class InstallThread(QThread):
    sig_line = pyqtSignal(str)
    sig_progress = pyqtSignal(int)
    sig_done = pyqtSignal(bool, str)
    sig_installation_state = pyqtSignal(bool)  # True = started, False = finished

    def __init__(self, cfg: InstallerConfig, parent=None):
        super().__init__(parent)
        self.cfg = cfg
        self.is_running = False

    def log(self, s: str) -> None:
        log_to_file(s)
        self.sig_line.emit(s)

    def run(self) -> None:
        ok = False
        msg = "Unknown error"
        reset_log_file()
        rp: RestorePoint = RestorePoint(enabled=False)
        self.is_running = True
        self.sig_installation_state.emit(True)
        
        try:
            ok, msg, rp = self._run_impl()
        except Exception as e:
            ok = False
            msg = str(e) or repr(e)
            self.log(f"!! Installation failed: {msg}")
            try:
                if rp and rp.created:
                    self.log("Restore point was created; attempting best-effort rollback…")
                    btrfs_best_effort_rollback(rp, self.log)
            except Exception as ee:
                self.log(f"!! Rollback attempt failed (non-fatal): {ee}")
            if rp and rp.created:
                self.log("")
                self.log("Manual rollback instructions (if needed):")
                self.log(f"  - Boot Live ISO")
                self.log(f"  - mount {rp.root_part} /mnt (top-level)")
                self.log(f"  - btrfs subvolume list /mnt")
                self.log(f"  - restore from snapshot: {rp.snap_root} (and {rp.snap_home or 'no home snapshot'})")
                self.log("")
        finally:
            self.is_running = False
            self.sig_installation_state.emit(False)
        
        self.sig_done.emit(ok, msg)

    def _run_impl(self) -> Tuple[bool, str, RestorePoint]:
        cfg = self.cfg
        self.sig_progress.emit(0)
        self.log("=== AGES Easy Installer ===")
        self.log(f"Kernel: {cfg.kernel} | Boot: {cfg.boot_mode} | FS: {cfg.fs} | Mode: {cfg.install_mode}")
        self.log(f"Disk: {cfg.disk}")
        self.log(f"Desktops: {', '.join(cfg.desktops or [])} | DM: {cfg.dm} | Autologin: {cfg.autologin}")
        self.log(f"User: {cfg.username} | Hostname: {cfg.hostname} | TZ: {cfg.timezone} | Keymap: {cfg.keymap}")
        self.log(f"Dracut: {'YES' if cfg.use_dracut else 'NO'} | OhMyBash to skel: {'YES' if cfg.copy_oh_my_bash else 'NO'} (live_user={cfg.live_user})")
        self.log("")
        if not is_root():
            raise RuntimeError("Must run as root (sudo).")
        if not cmd_ok("pacstrap") or not cmd_ok("arch-chroot"):
            raise RuntimeError("This must be run from an ArchISO-like environment (pacstrap + arch-chroot required).")

        kernel = cfg.kernel
        boot = cfg.boot_mode
        fs = cfg.fs
        disk = cfg.disk

        dm = cfg.dm
        if dm == DM_AUTO:
            dm = choose_default_dm_for_desktops(cfg.desktops or [DE_XFCE])
        session_hint = choose_default_session(cfg.desktops or [DE_XFCE])

        rp = RestorePoint(enabled=False)
        if cfg.restore_point_enabled and fs == "btrfs" and cfg.install_mode == MODE_EXISTING and (not cfg.format_root):
            rp = btrfs_create_restore_point_existing_nofmt(cfg.root_part, self.log)

        self.sig_progress.emit(5)

        target_root = Path("/mnt")
        safe_umount_recursive(str(target_root))

        root_part = cfg.root_part
        efi_part = cfg.efi_part or ""

        if cfg.install_mode == MODE_ERASE:
            root_part, efi_auto = wipe_and_partition_erase(disk, boot, fs, self.log)
            efi_part = efi_auto or ""
            cfg.format_root = True
            cfg.format_efi = True

        if cfg.format_root:
            if fs == "btrfs":
                mkfs_btrfs(root_part, "ROOT", self.log)
            elif fs == "xfs":
                mkfs_xfs(root_part, "ROOT", self.log)
            else:
                mkfs_ext4(root_part, "ROOT", self.log)

        if boot == "UEFI":
            if not efi_part:
                raise RuntimeError("UEFI mode requires an EFI partition selection.")
            if cfg.format_efi:
                mkfs_fat32(efi_part, "EFI", self.log)

        self.sig_progress.emit(15)

        mount_root_fs(root_part, fs, "/mnt", self.log)
        if boot == "UEFI":
            mount_efi(efi_part, "/mnt", self.log)

        self.sig_progress.emit(20)

        ensure_multilib_enabled_live(self.log)
        pacman_sync_live(self.log)

        pkgs, source_desc = choose_package_list(
            kernel=kernel,
            mode=boot,
            want_yay=cfg.want_yay,
            fs=fs,
            desktops=cfg.desktops or [DE_XFCE],
            dm=dm,
            use_local_packages_txt=cfg.use_local_packages_txt,
            log=self.log
        )
        
        self.log(f"Package list source: {source_desc}")
        pkgs = sanitize_package_list(pkgs, self.log)

        pacstrap_robust("/mnt", pkgs, self.log)
        self.sig_progress.emit(45)

        write_fstab(target_root, self.log)
        add_eco_repo_to_pacman_conf(target_root, self.log)  # 👈 ADD THIS
        ensure_multilib_enabled_target(target_root, self.log)

        apply_skel_preset(target_root, self.log)
        enable_system_oh_my_bash_in_skel(target_root, self.log)

        if cfg.copy_oh_my_bash:
            copy_oh_my_bash_to_skel(target_root, cfg.live_user, self.log)

        copy_ages_wallpapers_into_backgrounds(target_root, self.log)
        migrate_usr_share_icons(target_root, self.log)
        migrate_usr_local_bin(target_root, self.log)

        wp = ensure_wallpaper_from_host(target_root, self.log)
        patch_xfce_wallpaper_in_skel(target_root, wp, self.log)
        install_firstboot_wallpaper_fix(target_root, wp, self.log)

        # Ensure adw-gtk-theme is installed in target system
        self.log("Checking for adw-gtk-theme in target system...")
        if arch_chroot_soft(target_root, "pacman -Q adw-gtk-theme >/dev/null 2>&1", self.log) != 0:
            self.log("adw-gtk-theme not found, installing...")
            arch_chroot_soft(target_root, "pacman -S --noconfirm --needed adw-gtk-theme", self.log)
        else:
            self.log("adw-gtk-theme already installed")

        # Choose adw-gtk3-dark as the default theme
        theme_name = choose_best_theme_name(target_root, preferred="adw-gtk3-dark")
        icons = choose_best_icon_theme(target_root)
        self.log(f"Theme selected: {theme_name}")
        self.log(f"Icons selected: {icons}")
        write_default_gtk_settings_to_skel(target_root, theme_name, icons, self.log)
        
        if dm == DM_LIGHTDM:
            configure_lightdm_greeter(target_root, wp, self.log, theme_name, icons)

        self.sig_progress.emit(55)

        write_basic_system_files(
            target_root,
            hostname=cfg.hostname,
            tz=cfg.timezone,
            keymap=cfg.keymap,
            locale=cfg.locale,
            log=self.log
        )

        arch_chroot_soft(target_root, "mkinitcpio -P || true", self.log)

        root_pw = cfg.root_password or cfg.user_password
        setup_users(target_root, cfg.username, cfg.user_password, root_pw, self.log)

        ensure_user_home_gets_skel_best_effort(target_root, cfg.username, self.log)

        enable_base_services(target_root, self.log)
        self.sig_progress.emit(65)

        enable_dm_service(target_root, dm, self.log)
        if cfg.autologin:
            if dm == DM_LIGHTDM:
                enable_lightdm_autologin(target_root, cfg.username, self.log, session=session_hint)
            elif dm == DM_GDM:
                enable_gdm_autologin(target_root, cfg.username, self.log)
            elif dm == DM_SDDM:
                enable_sddm_autologin(target_root, cfg.username, self.log, session=session_hint)

        self.sig_progress.emit(72)

        if cfg.desktops and DE_XFCE in cfg.desktops:
            ensure_xfce_panel_plugins_guarantee_best_effort(target_root, self.log)

        if cfg.want_yay:
            install_yay_best_effort(target_root, self.log)

        if cfg.use_dracut:
            enable_dracut_in_target(target_root, self.log)

        self.sig_progress.emit(82)

        install_bootloader(target_root, boot, disk, fs, self.log)
        self.sig_progress.emit(92)

        self.log("=== Final cleanup ===")
        arch_chroot_soft(target_root, "rm -f /etc/skel/Desktop/calamares.desktop 2>/dev/null || true", self.log)
        arch_chroot_soft(target_root, "rm -f /root/Desktop/calamares.desktop 2>/dev/null || true", self.log)
        arch_chroot_soft(target_root, r"find /home -maxdepth 3 -type f -name '*.desktop' -path '*/Desktop/*' -delete 2>/dev/null || true", self.log)

        safe_umount_recursive("/mnt")
        self.sig_progress.emit(100)

        self.log("✅ Installation completed successfully.")
        return True, "Install completed successfully.", rp


# ============================================================
# UI: Step pages base class
# ============================================================
class StepPage(QWidget):
    def on_enter(self):
        pass
    def on_leave(self):
        pass


def make_scroll_page(inner: QWidget) -> QScrollArea:
    sc = QScrollArea()
    sc.setWidgetResizable(True)
    sc.setFrameShape(QScrollArea.NoFrame)
    sc.setWidget(inner)
    return sc


# ============================================================
# Updated Preflight Page with Location Preview
# ============================================================
class PreflightPage(StepPage):
    def __init__(self, main):
        super().__init__()
        self.main = main
        self.detected_location = None
        
        # Create main widget
        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        
        # Title
        title_label = QLabel("Preflight Check")
        title_label.setProperty("class", "Title")
        main_layout.addWidget(title_label)
        
        subtitle_label = QLabel("Verify system requirements before installation")
        subtitle_label.setProperty("class", "Subtitle")
        main_layout.addWidget(subtitle_label)
        
        # System status card
        self._create_status_card(main_layout)
        
        # Location preview card
        self._create_location_preview(main_layout)
        
        # Requirements card
        self._create_requirements_card(main_layout)
        
        # Acknowledgment
        self._create_acknowledgment(main_layout)
        
        main_layout.addStretch(1)
        
        # Wrap in scroll area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.NoFrame)
        scroll.setWidget(main_widget)
        
        layout = QVBoxLayout(self)
        layout.addWidget(scroll)
    
    def _create_status_card(self, parent_layout):
        """Create system status card"""
        status_card = QWidget()
        status_card.setProperty("class", "LocationWidget")
        card_layout = QVBoxLayout(status_card)
        
        # Title
        status_title = QLabel("📊 System Status")
        status_title.setProperty("class", "SectionTitle")
        card_layout.addWidget(status_title)
        
        # Status items
        self.status_wifi = QLabel("Wi-Fi: Checking...")
        card_layout.addWidget(self.status_wifi)
        
        self.status_vm = QLabel("Virtualization: Checking...")
        card_layout.addWidget(self.status_vm)
        
        self.status_root = QLabel("Root access: Checking...")
        card_layout.addWidget(self.status_root)
        
        self.status_internet = QLabel("Internet: Checking...")
        card_layout.addWidget(self.status_internet)
        
        self.status_boot = QLabel("Boot mode: Checking...")
        card_layout.addWidget(self.status_boot)
        
        parent_layout.addWidget(status_card)
    
    def _create_location_preview(self, parent_layout):
        """Create location preview card"""
        self.location_card = QWidget()
        self.location_card.setProperty("class", "LocationWidget")
        card_layout = QVBoxLayout(self.location_card)
        
        # Title
        location_title = QLabel("🌍 Location Preview")
        location_title.setProperty("class", "SectionTitle")
        card_layout.addWidget(location_title)
        
        # Location info
        self.location_preview = QLabel("Location will be detected in the next step...")
        self.location_preview.setWordWrap(True)
        card_layout.addWidget(self.location_preview)
        
        # Note
        note = QLabel("Note: Location helps set correct timezone and regional settings.")
        note.setProperty("class", "Subtitle")
        card_layout.addWidget(note)
        
        parent_layout.addWidget(self.location_card)
    
    def _create_requirements_card(self, parent_layout):
        """Create requirements checklist"""
        req_group = QGroupBox("System Requirements")
        req_layout = QVBoxLayout()
        
        self.req_details = QPlainTextEdit()
        self.req_details.setReadOnly(True)
        self.req_details.setMaximumHeight(150)
        req_layout.addWidget(self.req_details)
        
        req_group.setLayout(req_layout)
        parent_layout.addWidget(req_group)
    
    def _create_acknowledgment(self, parent_layout):
        """Create acknowledgment section"""
        ack_group = QGroupBox("Acknowledgment")
        ack_layout = QVBoxLayout()
        
        warning = QLabel(
            "⚠️ IMPORTANT: This installer can ERASE disks and destroy data.\n"
            "You are solely responsible for backing up important data."
        )
        warning.setProperty("class", "Warning")
        warning.setWordWrap(True)
        ack_layout.addWidget(warning)
        
        self.ack_check = QCheckBox(
            "I understand this installer can ERASE disks and I accept full responsibility "
            "for any data loss. I have verified the target disk is correct."
        )
        self.ack_check.setProperty("danger", "true")
        ack_layout.addWidget(self.ack_check)
        
        ack_group.setLayout(ack_layout)
        parent_layout.addWidget(ack_group)
        
        # Connect to validation
        self.ack_check.stateChanged.connect(self._validate)
    
    def _validate(self):
        """Validate preflight checks"""
        all_ok = (
            self.status_root.text().startswith("✓") and
            self.status_internet.text().startswith("✓") and
            self.ack_check.isChecked()
        )
        self.main.set_step_done(0, all_ok)
    
    def on_enter(self):
        """Run preflight checks when entering page"""
        # Check Wi-Fi
        self.status_wifi.setText(wifi_status_line())
        
        # Check virtualization
        v = detect_virtualization()
        if v.get("is_vm") == "yes":
            self.status_vm.setText(f"✓ Virtualization: {v.get('details','')}")
        elif v.get("is_vm") == "no":
            self.status_vm.setText("✓ Bare metal detected")
        else:
            self.status_vm.setText(f"⚠ Virtualization: {v.get('details','')}")
        
        # Run system checks
        self._run_system_checks()
        
        # Try early location detection for preview
        self._preview_location()
        
        self._validate()
    
    def _run_system_checks(self):
        """Run system requirement checks"""
        msgs = []
        
        # Root check
        if not is_root():
            self.status_root.setText("❌ Not running as root")
            msgs.append("❌ Not running as root. Launch with: sudo python3 ages_easy_installer.py")
        else:
            self.status_root.setText("✓ Running as root")
            msgs.append("✅ Running as root.")
        
        # Internet check
        if have_internet_fast():
            self.status_internet.setText("✓ Internet connection detected")
            msgs.append("✅ Internet connection detected.")
        else:
            self.status_internet.setText("⚠ No internet connection")
            msgs.append("⚠ No internet connection detected. Some features may be limited.")
        
        # Boot mode
        boot_mode = "UEFI" if is_uefi() else "BIOS/Legacy"
        self.status_boot.setText(f"✓ Boot mode: {boot_mode}")
        msgs.append(f"✅ Boot mode: {boot_mode}")
        
        # Required tools
        need = [
            "lsblk", "wipefs", "sgdisk",
            "pacstrap", "arch-chroot", "genfstab",
            "mkfs.ext4", "mkfs.fat", "mkfs.btrfs", "mkfs.xfs",
            "efibootmgr"
        ]
        missing = [c for c in need if not cmd_ok(c)]
        if missing:
            msgs.append(f"❌ Missing required tools: {', '.join(missing)}")
        else:
            msgs.append("✅ All required tools present.")
        
        self.req_details.setPlainText("\n".join(msgs))
    
    def _preview_location(self):
        """Preview location detection"""
        # Run quick location check
        try:
            location = LocationDetector.detect_location()
            self.detected_location = location
            
            # Build preview text
            preview_parts = []
            if location.get("city"):
                preview_parts.append(f"📍 Detected city: {location['city']}")
            if location.get("country"):
                preview_parts.append(f"Country: {location['country']}")
            if location.get("timezone"):
                preview_parts.append(f"Suggested timezone: {location['timezone']}")
            
            if preview_parts:
                preview_parts.append("")  # Empty line
                preview_parts.append("This will be auto-applied in System Settings.")
                self.location_preview.setText("\n".join(preview_parts))
        except Exception as e:
            self.location_preview.setText(f"Location detection failed: {str(e)}\nUsing defaults.")


# ============================================================
# Disk Page (Modernized)
# ============================================================
class DiskPage(StepPage):
    def __init__(self, main):
        super().__init__()
        self.main = main
        self.user_touched_disk = False
        
        # Create main widget
        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        
        # Title
        title_label = QLabel("Disk & Mode")
        title_label.setProperty("class", "Title")
        main_layout.addWidget(title_label)
        
        subtitle_label = QLabel("Select target disk and installation mode")
        subtitle_label.setProperty("class", "Subtitle")
        main_layout.addWidget(subtitle_label)
        
        # Disk selection card
        self._create_disk_card(main_layout)
        
        # Mode selection card
        self._create_mode_card(main_layout)
        
        main_layout.addStretch(1)
        
        # Wrap in scroll area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.NoFrame)
        scroll.setWidget(main_widget)
        
        layout = QVBoxLayout(self)
        layout.addWidget(scroll)
        
        # Timer for disk refresh
        self.t = QTimer(self)
        self.t.setInterval(2000)
        self.t.timeout.connect(self.refresh_disks)
    
    def _create_disk_card(self, parent_layout):
        """Create disk selection card"""
        disk_group = QGroupBox("Target Disk (⚠️ THIS CAN ERASE DATA)")
        disk_layout = QFormLayout()
        
        self.disk_combo = QComboBox()
        self.disk_combo.currentIndexChanged.connect(self._on_disk_changed)
        self.disk_combo.activated.connect(self._user_touched)
        disk_layout.addRow("Disk:", self.disk_combo)
        
        disk_group.setLayout(disk_layout)
        parent_layout.addWidget(disk_group)
    
    def _create_mode_card(self, parent_layout):
        """Create mode selection card"""
        mode_group = QGroupBox("Installation Settings")
        mode_layout = QFormLayout()
        
        self.mode_combo = QComboBox()
        self.mode_combo.addItems([MODE_ERASE, MODE_EXISTING])
        self.mode_combo.currentIndexChanged.connect(lambda _=None: self.main.refresh_partitions_page())
        mode_layout.addRow("Install mode:", self.mode_combo)
        
        self.boot_combo = QComboBox()
        self.boot_combo.addItems([BOOT_AUTO, BOOT_UEFI, BOOT_BIOS])
        self.boot_combo.currentIndexChanged.connect(lambda _=None: self.main.refresh_partitions_page())
        mode_layout.addRow("Boot mode:", self.boot_combo)
        
        self.fs_combo = QComboBox()
        self.fs_combo.addItems([FS_EXT4, FS_BTRFS, FS_XFS])
        self.fs_combo.currentIndexChanged.connect(lambda _=None: self.main.refresh_confirm_page())
        mode_layout.addRow("Filesystem:", self.fs_combo)
        
        mode_group.setLayout(mode_layout)
        parent_layout.addWidget(mode_group)
        
        # Warning label
        self.warn = QLabel(
            "⚠️ ERASE mode will DESTROY ALL DATA on the selected disk.\n"
            "Double-check the disk name (e.g., /dev/nvme0n1 is usually internal)."
        )
        self.warn.setProperty("class", "Warning")
        self.warn.setWordWrap(True)
        parent_layout.addWidget(self.warn)
    
    def _user_touched(self):
        self.user_touched_disk = True
    
    def on_enter(self):
        if not self.t.isActive():
            self.t.start()
        self.refresh_disks()
    
    def on_leave(self):
        if self.t.isActive():
            self.t.stop()
    
    def refresh_disks(self):
        disks = list_disks()
        cur = self.disk_combo.currentData()
        self.disk_combo.blockSignals(True)
        self.disk_combo.clear()
        for dev, size, model in disks:
            label = f"{dev}  ({size})  {model}"
            self.disk_combo.addItem(label, dev)
        self.disk_combo.blockSignals(False)

        best = choose_best_disk(disks)
        if not self.user_touched_disk:
            if best:
                idx = self.disk_combo.findData(best)
                if idx >= 0:
                    self.disk_combo.setCurrentIndex(idx)
        else:
            if cur:
                idx = self.disk_combo.findData(cur)
                if idx >= 0:
                    self.disk_combo.setCurrentIndex(idx)

        self._on_disk_changed()
    
    def _on_disk_changed(self):
        disk = self.disk_combo.currentData() or ""
        self.main.set_step_done(1, bool(disk))
        self.main.refresh_partitions_page()
        self.main.refresh_confirm_page()


# ============================================================
# Partitions Page (Modernized)
# ============================================================
class PartitionsPage(StepPage):
    def __init__(self, main):
        super().__init__()
        self.main = main
        
        # Create main widget
        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        
        # Title
        title_label = QLabel("Partitions")
        title_label.setProperty("class", "Title")
        main_layout.addWidget(title_label)
        
        subtitle_label = QLabel("Configure disk partitions for installation")
        subtitle_label.setProperty("class", "Subtitle")
        main_layout.addWidget(subtitle_label)
        
        # Info label
        self.info = QLabel("")
        self.info.setWordWrap(True)
        self.info.setProperty("class", "Subtitle")
        main_layout.addWidget(self.info)
        
        # Manual selection card (only for EXISTING mode)
        self._create_partition_card(main_layout)
        
        main_layout.addStretch(1)
        
        # Wrap in scroll area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.NoFrame)
        scroll.setWidget(main_widget)
        
        layout = QVBoxLayout(self)
        layout.addWidget(scroll)
    
    def _create_partition_card(self, parent_layout):
        """Create partition selection card"""
        self.partition_group = QGroupBox("Manual Partition Selection")
        partition_layout = QFormLayout()
        
        self.root_combo = QComboBox()
        partition_layout.addRow("Root ( / ):", self.root_combo)
        
        self.efi_combo = QComboBox()
        partition_layout.addRow("EFI (UEFI only):", self.efi_combo)
        
        self.format_root = QCheckBox("Format ROOT partition (⚠️ destroys data on that partition)")
        self.format_root.setProperty("danger", "true")
        self.format_root.setChecked(False)
        partition_layout.addRow("", self.format_root)
        
        self.format_efi = QCheckBox("Format EFI partition (FAT32)")
        self.format_efi.setProperty("danger", "true")
        self.format_efi.setChecked(False)
        partition_layout.addRow("", self.format_efi)
        
        self.partition_group.setLayout(partition_layout)
        parent_layout.addWidget(self.partition_group)
        
        # Connect signals
        for w in [self.root_combo, self.efi_combo]:
            w.currentIndexChanged.connect(lambda _=None: self._changed())
        self.format_root.stateChanged.connect(lambda _=None: self._changed())
        self.format_efi.stateChanged.connect(lambda _=None: self._changed())
    
    def refresh(self):
        disk = self.main.disk_page.disk_combo.currentData() or ""
        mode = self.main.disk_page.mode_combo.currentText()
        boot = effective_boot_mode(self.main.disk_page.boot_combo.currentText())

        if mode == MODE_ERASE:
            self.info.setText(
                "✅ ERASE mode selected:\n"
                "• Partitions are created automatically.\n"
                "• Root is formatted.\n"
                "• EFI is created/formatted in UEFI mode.\n"
            )
            self.partition_group.setVisible(False)
            self.main.set_step_done(2, True)
            return

        self.partition_group.setVisible(True)
        self.root_combo.setEnabled(True)
        self.format_root.setEnabled(True)
        self.efi_combo.setEnabled(boot == "UEFI")
        self.format_efi.setEnabled(boot == "UEFI")

        if not disk:
            self.root_combo.clear()
            self.efi_combo.clear()
            self.main.set_step_done(2, False)
            return

        parts = list_partitions_for_disk(disk)

        self.root_combo.blockSignals(True)
        self.efi_combo.blockSignals(True)
        self.root_combo.clear()
        self.efi_combo.clear()

        root_pick = None
        efi_pick = None

        for name, size, fstype, mnt, plabel, ptype in parts:
            disp = f"{name}  ({size})  {fstype or 'unknown'}  {('mounted:'+mnt) if mnt else ''}  {plabel or ''}"
            self.root_combo.addItem(disp, name)
            if not mnt and root_pick is None:
                root_pick = name
            if boot == "UEFI":
                if (fstype.lower() in ("vfat", "fat32")) or ("EFI" in (plabel or "").upper()) or ("ef00" in (ptype or "").lower()):
                    efi_pick = name
                self.efi_combo.addItem(disp, name)

        if root_pick:
            idx = self.root_combo.findData(root_pick)
            if idx >= 0:
                self.root_combo.setCurrentIndex(idx)
        if boot == "UEFI" and efi_pick:
            idx = self.efi_combo.findData(efi_pick)
            if idx >= 0:
                self.efi_combo.setCurrentIndex(idx)

        self.root_combo.blockSignals(False)
        self.efi_combo.blockSignals(False)

        self.info.setText(
            "ℹ️ USE EXISTING PARTITIONS mode:\n"
            "• Select your ROOT partition.\n"
            "• Select EFI partition if UEFI.\n"
            "• Formatting is optional but destructive.\n"
        )
        self._changed()
    
    def _changed(self):
        mode = self.main.disk_page.mode_combo.currentText()
        if mode == MODE_ERASE:
            self.main.set_step_done(2, True)
            self.main.refresh_confirm_page()
            return
        boot = effective_boot_mode(self.main.disk_page.boot_combo.currentText())
        root = self.root_combo.currentData() or ""
        efi = self.efi_combo.currentData() or ""
        ok = bool(root)
        if boot == "UEFI":
            ok = ok and bool(efi)
        self.main.set_step_done(2, ok)
        self.main.refresh_confirm_page()


# ============================================================
# System Page with Enhanced Location Detection
# ============================================================
class SystemPage(StepPage):
    def __init__(self, main):
        super().__init__()
        self.main = main
        self.location_info = None
        self.location_thread = None
        
        # Create main widget
        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        
        # Title section
        title_label = QLabel("System Settings")
        title_label.setProperty("class", "Title")
        main_layout.addWidget(title_label)
        
        subtitle_label = QLabel("Configure your system identity and regional settings")
        subtitle_label.setProperty("class", "Subtitle")
        main_layout.addWidget(subtitle_label)
        
        # Location detection card
        self._create_location_card(main_layout)
        
        # Kernel selection
        self._create_kernel_section(main_layout)
        
        # User identity
        self._create_user_section(main_layout)
        
        # Locale settings
        self._create_locale_section(main_layout)
        
        main_layout.addStretch(1)
        
        # Wrap in scroll area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.NoFrame)
        scroll.setWidget(main_widget)
        
        layout = QVBoxLayout(self)
        layout.addWidget(scroll)
    
    def _create_location_card(self, parent_layout):
        """Create location detection card"""
        location_card = QWidget()
        location_card.setProperty("class", "LocationWidget")
        card_layout = QVBoxLayout(location_card)
        
        # Title
        location_title = QLabel("🌍 Location Detection")
        location_title.setProperty("class", "SectionTitle")
        card_layout.addWidget(location_title)
        
        # Status label
        self.location_status = QLabel("Detecting your location...")
        self.location_status.setProperty("class", "Subtitle")
        card_layout.addWidget(self.location_status)
        
        # Location info display
        self.location_display = QLabel("")
        self.location_display.setWordWrap(True)
        card_layout.addWidget(self.location_display)
        
        # Detect button
        detect_btn = QPushButton("⟳ Re-detect Location")
        detect_btn.clicked.connect(self._detect_location)
        card_layout.addWidget(detect_btn)
        
        parent_layout.addWidget(location_card)
    
    def _create_kernel_section(self, parent_layout):
        """Create kernel selection section"""
        kernel_group = QGroupBox("Kernel Selection")
        kernel_layout = QVBoxLayout()
        
        self.kernel_combo = QComboBox()
        self.kernel_combo.addItems([
            "linux (Mainline - Latest features)",
            "linux-zen (Zen Kernel - Optimized for desktop)",
            "linux-lts (Long-Term Support - Stable)"
        ])
        self.kernel_combo.setCurrentIndex(0)
        
        kernel_layout.addWidget(self.kernel_combo)
        kernel_group.setLayout(kernel_layout)
        parent_layout.addWidget(kernel_group)
    
    def _create_user_section(self, parent_layout):
        """Create user identity section"""
        user_group = QGroupBox("User Identity")
        user_layout = QFormLayout()
        
        # Hostname
        self.hostname = QLineEdit()
        self.hostname.setPlaceholderText("e.g., my-computer")
        user_layout.addRow("Hostname:", self.hostname)
        
        # Username
        self.username = QLineEdit()
        self.username.setPlaceholderText("e.g., user")
        user_layout.addRow("Username:", self.username)
        
        # User password
        self.user_password = QLineEdit()
        self.user_password.setEchoMode(QLineEdit.Password)
        self.user_password.setPlaceholderText("Minimum 4 characters")
        user_layout.addRow("User Password:", self.user_password)
        
        self.user_password2 = QLineEdit()
        self.user_password2.setEchoMode(QLineEdit.Password)
        self.user_password2.setPlaceholderText("Confirm password")
        user_layout.addRow("Confirm:", self.user_password2)
        
        # Password warning
        self.pw_warn = QLabel("")
        self.pw_warn.setProperty("class", "Warning")
        user_layout.addRow("", self.pw_warn)
        
        # Separate root password
        self.separate_root = QCheckBox("Set separate root password (optional)")
        user_layout.addRow("", self.separate_root)
        
        self.root_password = QLineEdit()
        self.root_password.setEchoMode(QLineEdit.Password)
        self.root_password.setEnabled(False)
        self.root_password.setPlaceholderText("Optional - leave empty to use user password")
        user_layout.addRow("Root Password:", self.root_password)
        
        self.root_password2 = QLineEdit()
        self.root_password2.setEchoMode(QLineEdit.Password)
        self.root_password2.setEnabled(False)
        user_layout.addRow("Confirm:", self.root_password2)
        
        user_group.setLayout(user_layout)
        parent_layout.addWidget(user_group)
        
        # Connect signals
        self.separate_root.stateChanged.connect(self._on_separate_root_changed)
        for widget in [self.hostname, self.username, self.user_password, self.user_password2,
                      self.root_password, self.root_password2]:
            widget.textChanged.connect(self._validate)
    
    def _create_locale_section(self, parent_layout):
        """Create locale settings section"""
        locale_group = QGroupBox("Regional Settings")
        locale_layout = QFormLayout()
        
        # Timezone with smart detection
        self.timezone_combo = QComboBox()
        self.timezone_combo.setEditable(True)
        self.timezone_combo.setInsertPolicy(QComboBox.NoInsert)
        
        # Add popular cities first
        popular_cities = [
            ("🇺🇸 New York", "America/New_York"),
            ("🇺🇸 Los Angeles", "America/Los_Angeles"),
            ("🇺🇸 Chicago", "America/Chicago"),
            ("🇺🇸 Denver", "America/Denver"),
            ("🇬🇧 London", "Europe/London"),
            ("🇫🇷 Paris", "Europe/Paris"),
            ("🇩🇪 Berlin", "Europe/Berlin"),
            ("🇯🇵 Tokyo", "Asia/Tokyo"),
            ("🇨🇳 Shanghai", "Asia/Shanghai"),
            ("🇦🇺 Sydney", "Australia/Sydney"),
            ("🇨🇦 Toronto", "America/Toronto"),
            ("🇧🇷 São Paulo", "America/Sao_Paulo"),
            ("🇮🇳 Mumbai", "Asia/Kolkata"),
            ("🇸🇬 Singapore", "Asia/Singapore"),
            ("🇿🇦 Johannesburg", "Africa/Johannesburg"),
            ("🇦🇪 Dubai", "Asia/Dubai"),
            ("🇷🇺 Moscow", "Europe/Moscow"),
        ]
        
        for display, tz in popular_cities:
            self.timezone_combo.addItem(display, tz)
        
        # Add separator
        self.timezone_combo.insertSeparator(len(popular_cities))
        
        # Add all timezones
        all_tz = self._get_all_timezones()
        for tz in all_tz:
            if tz not in [data for _, data in popular_cities]:
                self.timezone_combo.addItem(tz, tz)
        
        locale_layout.addRow("Timezone:", self.timezone_combo)
        
        # Keymap
        self.keymap_combo = QComboBox()
        self.keymap_combo.addItems([
            "us", "uk", "de", "fr", "es", "it", "pt", "br-abnt2",
            "ru", "ua", "pl", "nl", "se", "no", "fi", "dk", "cz",
            "sk", "hu", "tr", "jp106", "kr", "cn", "in", "latam"
        ])
        locale_layout.addRow("Keymap:", self.keymap_combo)
        
        # Locale
        self.locale_combo = QComboBox()
        self.locale_combo.addItems([
            "en_US.UTF-8", "en_GB.UTF-8", "de_DE.UTF-8", "fr_FR.UTF-8",
            "es_ES.UTF-8", "it_IT.UTF-8", "pt_BR.UTF-8", "ru_RU.UTF-8",
            "ja_JP.UTF-8", "zh_CN.UTF-8", "ko_KR.UTF-8"
        ])
        locale_layout.addRow("Locale:", self.locale_combo)
        
        locale_group.setLayout(locale_layout)
        parent_layout.addWidget(locale_group)
        
        # Connect timezone change
        self.timezone_combo.currentIndexChanged.connect(self._validate)
    
    def _get_all_timezones(self):
        """Get list of all available timezones"""
        base = Path("/usr/share/zoneinfo")
        if not base.exists():
            return ["UTC", "America/New_York", "Europe/London", "Asia/Tokyo"]
        
        timezones = []
        try:
            for root, dirs, files in os.walk(str(base)):
                rp = Path(root)
                rel = rp.relative_to(base)
                if rel.parts and rel.parts[0] in {"posix", "right"}:
                    continue
                for f in files:
                    p = rp / f
                    if f in {"zone.tab", "zone1970.tab", "leapseconds", "tzdata.zi"}:
                        continue
                    if p.is_symlink():
                        continue
                    relp = p.relative_to(base)
                    if len(relp.parts) >= 1:
                        timezones.append("/".join(relp.parts))
        except Exception:
            pass
        
        return sorted(set(timezones))
    
    def _detect_location(self):
        """Start location detection"""
        self.location_status.setText("Detecting your location...")
        self.location_display.setText("")
        
        # Kill existing thread if any
        if self.location_thread and self.location_thread.isRunning():
            self.location_thread.terminate()
            self.location_thread.wait()
        
        # Start new detection thread
        self.location_thread = LocationDetectionThread()
        self.location_thread.sig_location_detected.connect(self._on_location_detected)
        self.location_thread.sig_detection_failed.connect(self._on_location_failed)
        self.location_thread.start()
    
    def _on_location_detected(self, location_info):
        """Handle successful location detection"""
        self.location_info = location_info
        
        # Update status
        confidence = location_info.get("confidence", "low")
        method = location_info.get("method", "unknown")
        
        confidence_text = {
            "very_high": "✓ High confidence",
            "high": "✓ Good confidence",
            "medium": "⚠ Medium confidence",
            "low": "⚠ Low confidence",
            "very_low": "✗ Very low confidence"
        }.get(confidence, "⚠ Unknown confidence")
        
        self.location_status.setText(f"Location detected ({confidence_text})")
        
        # Build display text
        display_parts = []
        if location_info.get("city"):
            display_parts.append(f"📍 {location_info['city']}")
        if location_info.get("region"):
            display_parts.append(f"Region: {location_info['region']}")
        if location_info.get("country"):
            display_parts.append(f"Country: {location_info['country']}")
        if location_info.get("timezone"):
            display_parts.append(f"Timezone: {location_info['timezone']}")
        
        if display_parts:
            self.location_display.setText("\n".join(display_parts))
        
        # Auto-select timezone if found
        if location_info.get("timezone"):
            tz = location_info["timezone"]
            # Try to find in combo
            index = self.timezone_combo.findData(tz)
            if index >= 0:
                self.timezone_combo.setCurrentIndex(index)
            else:
                # Add it if not found
                self.timezone_combo.addItem(tz, tz)
                self.timezone_combo.setCurrentIndex(self.timezone_combo.count() - 1)
        
        # Auto-suggest keymap based on country
        self._suggest_keymap(location_info)
        
        # Auto-suggest locale
        self._suggest_locale(location_info)
    
    def _on_location_failed(self, error_msg):
        """Handle location detection failure"""
        self.location_status.setText("✗ Location detection failed")
        self.location_display.setText(f"Error: {error_msg}\nUsing system defaults.")
        
        # Fallback to system timezone
        system_tz = LocationDetector._get_system_timezone()
        if system_tz:
            index = self.timezone_combo.findData(system_tz)
            if index >= 0:
                self.timezone_combo.setCurrentIndex(index)
    
    def _suggest_keymap(self, location_info):
        """Suggest keymap based on location"""
        country = location_info.get("country", "").lower()
        city = location_info.get("city", "").lower()
        
        keymap_suggestions = {
            "united states": "us",
            "usa": "us",
            "united kingdom": "uk",
            "germany": "de",
            "france": "fr",
            "spain": "es",
            "italy": "it",
            "portugal": "pt",
            "brazil": "br-abnt2",
            "russia": "ru",
            "ukraine": "ua",
            "poland": "pl",
            "netherlands": "nl",
            "sweden": "se",
            "norway": "no",
            "finland": "fi",
            "denmark": "dk",
            "czech": "cz",
            "slovakia": "sk",
            "hungary": "hu",
            "turkey": "tr",
            "japan": "jp106",
            "korea": "kr",
            "china": "cn",
            "india": "in",
            "mexico": "latam",
        }
        
        # Try country match
        for country_name, keymap in keymap_suggestions.items():
            if country_name in country:
                index = self.keymap_combo.findText(keymap)
                if index >= 0:
                    self.keymap_combo.setCurrentIndex(index)
                return
        
        # Try city match
        city_keymaps = {
            "new york": "us",
            "los angeles": "us",
            "london": "uk",
            "paris": "fr",
            "berlin": "de",
            "tokyo": "jp106",
            "moscow": "ru",
            "beijing": "cn",
            "seoul": "kr",
            "mumbai": "in",
        }
        
        for city_name, keymap in city_keymaps.items():
            if city_name in city:
                index = self.keymap_combo.findText(keymap)
                if index >= 0:
                    self.keymap_combo.setCurrentIndex(index)
                return
    
    def _suggest_locale(self, location_info):
        """Suggest locale based on location"""
        country = location_info.get("country", "").lower()
        city = location_info.get("city", "").lower()
        
        locale_suggestions = {
            "united states": "en_US.UTF-8",
            "usa": "en_US.UTF-8",
            "united kingdom": "en_GB.UTF-8",
            "germany": "de_DE.UTF-8",
            "france": "fr_FR.UTF-8",
            "spain": "es_ES.UTF-8",
            "italy": "it_IT.UTF-8",
            "portugal": "pt_PT.UTF-8",
            "brazil": "pt_BR.UTF-8",
            "russia": "ru_RU.UTF-8",
            "japan": "ja_JP.UTF-8",
            "china": "zh_CN.UTF-8",
            "korea": "ko_KR.UTF-8",
        }
        
        # Try country match
        for country_name, locale in locale_suggestions.items():
            if country_name in country:
                index = self.locale_combo.findText(locale)
                if index >= 0:
                    self.locale_combo.setCurrentIndex(index)
                return
        
        # Try city match
        city_locales = {
            "new york": "en_US.UTF-8",
            "los angeles": "en_US.UTF-8",
            "london": "en_GB.UTF-8",
            "paris": "fr_FR.UTF-8",
            "berlin": "de_DE.UTF-8",
            "tokyo": "ja_JP.UTF-8",
            "beijing": "zh_CN.UTF-8",
            "seoul": "ko_KR.UTF-8",
        }
        
        for city_name, locale in city_locales.items():
            if city_name in city:
                index = self.locale_combo.findText(locale)
                if index >= 0:
                    self.locale_combo.setCurrentIndex(index)
                return
    
    def _on_separate_root_changed(self):
        """Handle separate root password checkbox"""
        enabled = self.separate_root.isChecked()
        self.root_password.setEnabled(enabled)
        self.root_password2.setEnabled(enabled)
        self._validate()
    
    def _validate(self):
        """Validate all inputs"""
        # Password validation
        user_pw = self.user_password.text()
        user_pw2 = self.user_password2.text()
        root_pw = self.root_password.text() if self.separate_root.isChecked() else ""
        root_pw2 = self.root_password2.text() if self.separate_root.isChecked() else ""
        
        ok = True
        msgs = []
        
        # User password
        if len(user_pw) < 4:
            ok = False
            msgs.append("❌ User password must be at least 4 characters")
        elif user_pw != user_pw2:
            ok = False
            msgs.append("❌ User passwords don't match")
        else:
            msgs.append("✅ User password OK")
        
        # Root password (if separate)
        if self.separate_root.isChecked():
            if len(root_pw) < 4:
                ok = False
                msgs.append("❌ Root password must be at least 4 characters")
            elif root_pw != root_pw2:
                ok = False
                msgs.append("❌ Root passwords don't match")
            else:
                msgs.append("✅ Root password OK")
        
        # Username and hostname
        if not self.hostname.text().strip():
            ok = False
            msgs.append("❌ Hostname cannot be empty")
        else:
            msgs.append("✅ Hostname OK")
        
        if not self.username.text().strip():
            ok = False
            msgs.append("❌ Username cannot be empty")
        else:
            msgs.append("✅ Username OK")
        
        # Timezone selection
        if not self.timezone_combo.currentData():
            ok = False
            msgs.append("❌ Please select a timezone")
        else:
            msgs.append("✅ Timezone selected")
        
        self.pw_warn.setText("\n".join(msgs))
        self.main.set_step_done(3, ok)
    
    def on_enter(self):
        """Called when entering the page"""
        # Auto-detect location on first entry
        if not self.location_info:
            self._detect_location()
        
        # Auto-fill username from environment
        if not self.username.text():
            env_user = os.environ.get("SUDO_USER") or os.environ.get("USER") or "user"
            self.username.setText(env_user)
        
        # Auto-fill hostname
        if not self.hostname.text():
            try:
                hostname = socket.gethostname()
                if hostname and hostname != "localhost":
                    self.hostname.setText(hostname)
            except:
                pass
        
        self._validate()


# ============================================================
# Desktop Page (Modernized)
# ============================================================
class DesktopPage(StepPage):
    def __init__(self, main):
        super().__init__()
        self.main = main
        
        # Create main widget
        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        
        # Title
        title_label = QLabel("Desktop Environment")
        title_label.setProperty("class", "Title")
        main_layout.addWidget(title_label)
        
        subtitle_label = QLabel("Choose your desktop environment and display settings")
        subtitle_label.setProperty("class", "Subtitle")
        main_layout.addWidget(subtitle_label)
        
        # Desktop selection
        self._create_desktop_selection(main_layout)
        
        # Display manager
        self._create_display_manager(main_layout)
        
        # Advanced options
        self._create_advanced_options(main_layout)
        
        main_layout.addStretch(1)
        
        # Wrap in scroll area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.NoFrame)
        scroll.setWidget(main_widget)
        
        layout = QVBoxLayout(self)
        layout.addWidget(scroll)
    
    def _create_desktop_selection(self, parent_layout):
        """Create desktop environment selection"""
        de_group = QGroupBox("Desktop Environment")
        de_layout = QVBoxLayout()
        
        # Popular DEs section
        popular_label = QLabel("Popular Choices:")
        popular_label.setProperty("class", "SectionTitle")
        de_layout.addWidget(popular_label)
        
        self.de_checks = {}
        popular_des = [DE_XFCE, DE_GNOME, DE_KDE, DE_CINNAMON]
        for de in popular_des:
            cb = QCheckBox(de)
            self.de_checks[de] = cb
            de_layout.addWidget(cb)
        
        # Other DEs section
        other_label = QLabel("Other Options:")
        other_label.setProperty("class", "SectionTitle")
        de_layout.addWidget(other_label)
        
        other_des = [DE_MATE, DE_LXQT]
        for de in other_des:
            cb = QCheckBox(de)
            self.de_checks[de] = cb
            de_layout.addWidget(cb)
        
        # Window Managers section
        wm_label = QLabel("Window Managers:")
        wm_label.setProperty("class", "SectionTitle")
        de_layout.addWidget(wm_label)
        
        self.wm_checks = {}
        wms = [WM_I3, WM_OPENBOX, WM_BSPWM, WM_AWESOME, WM_QTILE, WM_SWAY, WM_HYPRLAND]
        for wm in wms:
            cb = QCheckBox(wm)
            self.wm_checks[wm] = cb
            de_layout.addWidget(cb)
        
        # Connect signals
        for cb in list(self.de_checks.values()) + list(self.wm_checks.values()):
            cb.stateChanged.connect(self._update_dm_combo)
        
        de_group.setLayout(de_layout)
        parent_layout.addWidget(de_group)
    
    def _create_display_manager(self, parent_layout):
        """Create display manager selection"""
        dm_group = QGroupBox("Display Settings")
        dm_layout = QVBoxLayout()
        
        # DM selection
        dm_label = QLabel("Display Manager:")
        dm_layout.addWidget(dm_label)
        
        self.dm_combo = QComboBox()
        self.dm_combo.addItems([DM_AUTO, DM_LIGHTDM, DM_GDM, DM_SDDM])
        dm_layout.addWidget(self.dm_combo)
        
        # Autologin
        self.autologin = QCheckBox("Enable autologin (bypass login screen)")
        self.autologin.setChecked(True)
        dm_layout.addWidget(self.autologin)
        
        dm_group.setLayout(dm_layout)
        parent_layout.addWidget(dm_group)
    
    def _create_advanced_options(self, parent_layout):
        """Create advanced options section"""
        adv_group = QGroupBox("Advanced Options")
        adv_layout = QVBoxLayout()
        
        # Package options
        self.use_local_packages_txt = QCheckBox("Use local packages.txt file")
        self.use_local_packages_txt.setChecked(True)
        adv_layout.addWidget(self.use_local_packages_txt)
        
        self.want_yay = QCheckBox("Install yay (AUR helper)")
        self.want_yay.setChecked(True)
        adv_layout.addWidget(self.want_yay)
        
        self.copy_oh_my_bash = QCheckBox("Copy Oh My Bash to /etc/skel")
        self.copy_oh_my_bash.setChecked(True)
        adv_layout.addWidget(self.copy_oh_my_bash)
        
        self.use_dracut = QCheckBox("Use dracut initramfs (advanced)")
        self.use_dracut.setChecked(False)
        adv_layout.addWidget(self.use_dracut)
        
        adv_group.setLayout(adv_layout)
        parent_layout.addWidget(adv_group)
        
        # Connect validation
        for widget in [self.dm_combo, self.autologin]:
            if hasattr(widget, 'currentIndexChanged'):
                widget.currentIndexChanged.connect(self._validate)
            else:
                widget.stateChanged.connect(self._validate)
    
    def _update_dm_combo(self):
        """Update DM combo based on selection"""
        selected = []
        for de, cb in self.de_checks.items():
            if cb.isChecked():
                selected.append(de)
        for wm, cb in self.wm_checks.items():
            if cb.isChecked():
                selected.append(wm)
        
        if not selected:
            selected = [DE_XFCE]
        
        auto_dm = choose_default_dm_for_desktops(selected)
        
        # Update combo without triggering signals
        self.dm_combo.blockSignals(True)
        current_text = self.dm_combo.currentText()
        
        if current_text == DM_AUTO:
            idx = self.dm_combo.findText(DM_AUTO)
            if idx >= 0:
                self.dm_combo.setItemText(idx, f"{DM_AUTO} → {auto_dm}")
        else:
            # Restore original text for Auto option
            idx = self.dm_combo.findText(f"{DM_AUTO} → ")
            if idx >= 0:
                self.dm_combo.setItemText(idx, DM_AUTO)
        
        self.dm_combo.blockSignals(False)
        self._validate()
    
    def _validate(self):
        """Validate desktop selection"""
        has_desktop = any(cb.isChecked() for cb in self.de_checks.values())
        has_wm = any(cb.isChecked() for cb in self.wm_checks.values())
        
        ok = has_desktop or has_wm
        self.main.set_step_done(4, ok)
    
    def on_enter(self):
        """Called when entering the page"""
        # Ensure at least XFCE is checked by default
        if not any(cb.isChecked() for cb in self.de_checks.values()) and \
           not any(cb.isChecked() for cb in self.wm_checks.values()):
            self.de_checks[DE_XFCE].setChecked(True)
        
        self._update_dm_combo()


# ============================================================
# Confirm Page (Modernized)
# ============================================================
class ConfirmPage(StepPage):
    def __init__(self, main):
        super().__init__()
        self.main = main
        
        # Create main widget
        main_widget = QWidget()
        main_layout = QVBoxLayout(main_widget)
        
        # Title
        title_label = QLabel("Confirmation")
        title_label.setProperty("class", "Title")
        main_layout.addWidget(title_label)
        
        subtitle_label = QLabel("Review your settings before installation")
        subtitle_label.setProperty("class", "Subtitle")
        main_layout.addWidget(subtitle_label)
        
        # Summary
        self.summary = QPlainTextEdit()
        self.summary.setReadOnly(True)
        self.summary.setMinimumHeight(300)
        main_layout.addWidget(self.summary)
        
        # Warning box
        warning_box = QGroupBox("")
        warning_box.setStyleSheet("QGroupBox { color: #ff7a7a; border: 2px solid #ff7a7a; }")
        warning_box_lay = QVBoxLayout(warning_box)
        
        self.warning_label = QLabel("")
        self.warning_label.setWordWrap(True)
        self.warning_label.setProperty("class", "Warning")
        warning_box_lay.addWidget(self.warning_label)
        
        main_layout.addWidget(warning_box)
        
        # Confirmation word section
        confirm_box = QGroupBox("Confirmation Required")
        confirm_box.setStyleSheet("QGroupBox { color: #dbe3ff; border: 1px solid #1b2a50; }")
        confirm_box_lay = QVBoxLayout(confirm_box)
        
        self.confirm_word_label = QLabel("")
        self.confirm_word_label.setWordWrap(True)
        self.confirm_word_label.setProperty("class", "Warning")
        confirm_box_lay.addWidget(self.confirm_word_label)
        
        self.confirm_input = QLineEdit()
        self.confirm_input.setPlaceholderText("Type the confirmation word exactly as shown above")
        confirm_box_lay.addWidget(self.confirm_input)
        
        main_layout.addWidget(confirm_box)
        
        main_layout.addStretch(1)
        
        # Wrap in scroll area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QScrollArea.NoFrame)
        scroll.setWidget(main_widget)
        
        layout = QVBoxLayout(self)
        layout.addWidget(scroll)
        
        self.confirm_input.textChanged.connect(self._validate)
    
    def refresh_summary(self):
        cfg = self.main.get_config()
        
        # Determine confirmation word
        confirm_word = self._determine_confirm_word(cfg)
        self.confirm_word_label.setText(
            f"Type this exact word to proceed:<br><br>"
            f"<font size='+2' color='#ff7a7a'>{confirm_word}</font>"
        )
        
        # Build warning text
        if cfg.install_mode == MODE_ERASE:
            disk_display = cfg.disk or "<unknown disk>"
            warning_text = f"⚠️ ERASE MODE: ALL DATA on {disk_display} will be DESTROYED!"
        elif cfg.format_root:
            root_display = cfg.root_part or "<unknown partition>"
            warning_text = f"⚠️ FORMATTING: The ROOT partition {root_display} will be formatted, destroying all data on it!"
        else:
            warning_text = "⚠️ INSTALLING: This will install the system WITHOUT formatting (data should be preserved)."
        
        self.warning_label.setText(warning_text)
        
        # Build summary
        summary_lines = []
        summary_lines.append("=== INSTALLATION SUMMARY ===")
        summary_lines.append("")
        summary_lines.append("SYSTEM:")
        summary_lines.append(f"  Kernel: {cfg.kernel}")
        summary_lines.append(f"  Boot mode: {cfg.boot_mode}")
        summary_lines.append(f"  Filesystem: {cfg.fs}")
        summary_lines.append(f"  Disk: {cfg.disk or '<not selected>'}")
        summary_lines.append(f"  Install mode: {cfg.install_mode}")
        
        if cfg.install_mode == MODE_EXISTING:
            summary_lines.append(f"  Root partition: {cfg.root_part or '<not selected>'}")
            if cfg.boot_mode == "UEFI":
                summary_lines.append(f"  EFI partition: {cfg.efi_part or '<not selected>'}")
            summary_lines.append(f"  Format root: {cfg.format_root}")
            if cfg.boot_mode == "UEFI":
                summary_lines.append(f"  Format EFI: {cfg.format_efi}")
        
        summary_lines.append("")
        summary_lines.append("USER:")
        summary_lines.append(f"  Hostname: {cfg.hostname or '<empty>'}")
        summary_lines.append(f"  Username: {cfg.username or '<empty>'}")
        summary_lines.append(f"  Timezone: {cfg.timezone}")
        summary_lines.append(f"  Keymap: {cfg.keymap}")
        summary_lines.append(f"  Locale: {cfg.locale}")
        
        summary_lines.append("")
        summary_lines.append("DESKTOP:")
        desktops = cfg.desktops or []
        if desktops:
            summary_lines.append(f"  Desktop(s): {', '.join(desktops)}")
        summary_lines.append(f"  Display Manager: {cfg.dm}")
        summary_lines.append(f"  Autologin: {cfg.autologin}")
        
        summary_lines.append("")
        summary_lines.append("ADVANCED:")
        summary_lines.append(f"  Install yay: {cfg.want_yay}")
        summary_lines.append(f"  Copy Oh My Bash: {cfg.copy_oh_my_bash}")
        summary_lines.append(f"  Use dracut: {cfg.use_dracut}")
        summary_lines.append(f"  Use local packages.txt: {cfg.use_local_packages_txt}")
        
        if cfg.fs == "btrfs" and cfg.install_mode == MODE_EXISTING and not cfg.format_root:
            summary_lines.append(f"  BTRFS Restore Point: {'YES (best-effort)' if cfg.restore_point_enabled else 'NO'}")
        
        self.summary.setPlainText("\n".join(summary_lines))
    
    def _determine_confirm_word(self, cfg):
        if cfg.install_mode == MODE_ERASE:
            return "ERASE"
        elif cfg.format_root:
            return "FORMAT"
        else:
            return "INSTALL"
    
    def _validate(self):
        cfg = self.main.get_config()
        confirm_word = self._determine_confirm_word(cfg)
        ok = (self.confirm_input.text() == confirm_word)
        self.main.set_step_done(5, ok)
    
    def on_enter(self):
        self.refresh_summary()
        self.confirm_input.clear()
        self._validate()


# ============================================================
# Install Page (Modernized) with navigation lock
# ============================================================
class InstallPage(StepPage):
    def __init__(self, main):
        super().__init__()
        self.main = main
        self.thread = None
        self.installation_running = False
        
        lay = QVBoxLayout(self)

        title = QLabel("Installation")
        title.setProperty("class", "Title")
        lay.addWidget(title)

        subtitle = QLabel("Installing your system...")
        subtitle.setProperty("class", "Subtitle")
        lay.addWidget(subtitle)

        # Warning about not going back
        self.warning_label = QLabel("⚠️ DO NOT navigate away from this page while installation is in progress!")
        self.warning_label.setProperty("class", "Warning")
        self.warning_label.setWordWrap(True)
        self.warning_label.setVisible(False)
        lay.addWidget(self.warning_label)

        self.progress = QProgressBar()
        lay.addWidget(self.progress)

        self.log_view = QPlainTextEdit()
        self.log_view.setReadOnly(True)
        self.log_view.setMinimumHeight(400)
        lay.addWidget(self.log_view)

        self.reboot_btn = QPushButton("Reboot")
        self.reboot_btn.clicked.connect(self._reboot)
        self.reboot_btn.setEnabled(False)
        
        self.back_btn = QPushButton("Back to Start")
        self.back_btn.clicked.connect(lambda: self.main.set_current_step(0))
        self.back_btn.setEnabled(False)
        
        btn_lay = QHBoxLayout()
        btn_lay.addWidget(self.reboot_btn)
        btn_lay.addWidget(self.back_btn)
        lay.addLayout(btn_lay)

    def on_enter(self):
        self.progress.setValue(0)
        self.log_view.clear()
        self.reboot_btn.setEnabled(False)
        self.back_btn.setEnabled(False)
        self.warning_label.setVisible(False)
        
        # Start installation
        cfg = self.main.get_config()
        self.thread = InstallThread(cfg)
        self.thread.sig_line.connect(self._log)
        self.thread.sig_progress.connect(self.progress.setValue)
        self.thread.sig_done.connect(self._install_done)
        self.thread.sig_installation_state.connect(self._on_installation_state)
        self.thread.start()

    def on_leave(self):
        """Prevent leaving during installation"""
        if self.installation_running:
            # Show warning and prevent navigation
            QMessageBox.warning(
                self,
                "Installation in Progress",
                "Cannot navigate away while installation is running.\n"
                "Please wait for installation to complete or restart the installer."
            )
            # Force return to this page
            self.main.stack.setCurrentWidget(self)

    def _log(self, line):
        self.log_view.appendPlainText(line)
        # Auto-scroll to bottom
        scrollbar = self.log_view.verticalScrollBar()
        scrollbar.setValue(scrollbar.maximum())

    def _on_installation_state(self, is_running):
        """Handle installation state changes"""
        self.installation_running = is_running
        self.warning_label.setVisible(is_running)
        
        # Update main window navigation lock
        self.main.installation_running = is_running
        self.main.update_nav()

    def _install_done(self, success, message):
        if success:
            self._log("✅ Installation completed successfully!")
            self._log("You can now reboot into your new system.")
            self.reboot_btn.setEnabled(True)
            self.back_btn.setEnabled(True)
        else:
            self._log(f"❌ Installation failed: {message}")
            self._log("Please check the log above for details.")
            self.back_btn.setEnabled(True)

    def _reboot(self):
        reply = QMessageBox.question(
            self, "Reboot",
            "Are you sure you want to reboot now?",
            QMessageBox.Yes | QMessageBox.No,
            QMessageBox.No
        )
        if reply == QMessageBox.Yes:
            self._log("Rebooting system...")
            subprocess.run(["reboot"])


# ============================================================
# Main Window with navigation lock
# ============================================================
class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("AGES EcoOS Installer")
        self.setMinimumSize(1200, 700)
        
        # Set application style
        self.setStyleSheet(MODERN_QSS)
        
        # Initialize ALL attributes before creating pages
        self.current_step = 0
        self._step_done = [False] * 7  # We have 7 steps
        self.installation_running = False  # NEW: Track installation state
        
        # Central widget
        central = QWidget()
        self.setCentralWidget(central)
        main_lay = QHBoxLayout(central)
        main_lay.setContentsMargins(0, 0, 0, 0)
        main_lay.setSpacing(0)
        
        # Left sidebar (navigation)
        self.sidebar = QWidget()
        self.sidebar.setObjectName("SideNav")
        self.sidebar.setFixedWidth(220)
        sidebar_lay = QVBoxLayout(self.sidebar)
        sidebar_lay.setContentsMargins(10, 10, 10, 10)
        
        nav_title = QLabel("AGES Installer")
        nav_title.setProperty("class", "Title")
        sidebar_lay.addWidget(nav_title)
        
        self.nav_btns = []
        steps = [
            ("Preflight", "Check system requirements"),
            ("Disk & Mode", "Select target disk and mode"),
            ("Partitions", "Configure partitions"),
            ("System", "Set up users and locale"),
            ("Desktop", "Choose DE/WM and options"),
            ("Confirm", "Review and confirm"),
            ("Install", "Install system")
        ]
        
        for i, (title, desc) in enumerate(steps):
            btn = QPushButton(f"{i+1}. {title}\n{desc}")
            btn.setProperty("class", "NavStep")
            btn.clicked.connect(lambda checked, idx=i: self.set_current_step(idx))
            btn.setEnabled(False)
            self.nav_btns.append(btn)
            sidebar_lay.addWidget(btn)
        
        sidebar_lay.addStretch(1)
        
        # Add version info
        version = QLabel("AGES EcoOS Installer v2.0")
        version.setProperty("class", "Subtitle")
        sidebar_lay.addWidget(version)
        
        main_lay.addWidget(self.sidebar)
        
        # Right area (pages)
        self.stack = QStackedWidget()
        main_lay.addWidget(self.stack, 1)
        
        # Create pages
        self.pages = [
            PreflightPage(self),
            DiskPage(self),
            PartitionsPage(self),
            SystemPage(self),
            DesktopPage(self),
            ConfirmPage(self),
            InstallPage(self)
        ]
        
        for page in self.pages:
            self.stack.addWidget(page)
        
        # Update navigation
        self.update_nav()
        
        # Show first page
        self.set_current_step(0)
    
    def set_current_step(self, step):
        """Navigate to a specific step with installation lock check"""
        if step < 0 or step >= len(self.pages):
            return
        
        # Check if installation is running and trying to navigate away from install page
        if self.installation_running and step != self.current_step:
            QMessageBox.warning(
                self,
                "Installation in Progress",
                "Cannot navigate away while installation is running.\n"
                "Please wait for installation to complete."
            )
            return
        
        # Leave current page
        if self.current_step < len(self.pages):
            self.pages[self.current_step].on_leave()
        
        # Enter new page
        self.current_step = step
        self.stack.setCurrentIndex(step)
        self.pages[step].on_enter()
        
        self.update_nav()
    
    def update_nav(self):
        """Update navigation buttons state"""
        for i, btn in enumerate(self.nav_btns):
            active = (i == self.current_step)
            done = self._step_done[i] if i < len(self._step_done) else False
            
            # NEW: Disable navigation during installation (except current install page)
            if self.installation_running:
                locked = (i != self.current_step)
                btn.setEnabled(not locked)
                btn.setProperty("disabled", "true" if locked else "false")
            else:
                locked = (i > 0 and not self._step_done[i-1])
                btn.setEnabled(not locked or active)
                btn.setProperty("disabled", "false")
            
            btn.setProperty("active", "true" if active else "false")
            btn.setProperty("done", "true" if done else "false")
            btn.setProperty("locked", "true" if locked else "false")
            
            # Update style
            btn.style().unpolish(btn)
            btn.style().polish(btn)
    
    def is_step_done(self, step):
        if step < 0 or step >= len(self._step_done):
            return False
        return self._step_done[step]
    
    def set_step_done(self, step, done):
        if step < 0 or step >= len(self._step_done):
            return
        
        self._step_done[step] = done
        self.update_nav()
    
    @property
    def disk_page(self):
        return self.pages[1]
    
    @property
    def partitions_page(self):
        return self.pages[2]
    
    @property
    def system_page(self):
        return self.pages[3]
    
    @property
    def desktop_page(self):
        return self.pages[4]
    
    @property
    def confirm_page(self):
        return self.pages[5]
    
    def refresh_partitions_page(self):
        self.pages[2].refresh()
    
    def refresh_confirm_page(self):
        if self.current_step >= 5:  # Only if we're on or past confirm page
            self.pages[5].refresh_summary()
    
    def get_config(self):
        cfg = InstallerConfig()
        
        # Get disk/mode info
        cfg.disk = self.disk_page.disk_combo.currentData() or ""
        cfg.install_mode = self.disk_page.mode_combo.currentText()
        cfg.boot_mode = effective_boot_mode(self.disk_page.boot_combo.currentText())
        cfg.fs = effective_fs(self.disk_page.fs_combo.currentText())
        
        # Get partition info
        if cfg.install_mode == MODE_EXISTING:
            cfg.root_part = self.partitions_page.root_combo.currentData() or ""
            cfg.efi_part = self.partitions_page.efi_combo.currentData() or ""
            cfg.format_root = self.partitions_page.format_root.isChecked()
            cfg.format_efi = self.partitions_page.format_efi.isChecked()
        
        # Get system info
        cfg.kernel = self.system_page.kernel_combo.currentText().split()[0]  # Get first word
        cfg.hostname = sanitize_hostname(self.system_page.hostname.text())
        cfg.username = sanitize_username(self.system_page.username.text())
        cfg.user_password = self.system_page.user_password.text()
        
        if self.system_page.separate_root.isChecked():
            cfg.root_password = self.system_page.root_password.text()
        
        cfg.timezone = self.system_page.timezone_combo.currentData() or "America/New_York"
        cfg.keymap = self.system_page.keymap_combo.currentText()
        cfg.locale = self.system_page.locale_combo.currentText()
        
        # Get desktop info
        selected_desktops = []
        for de, cb in self.desktop_page.de_checks.items():
            if cb.isChecked():
                selected_desktops.append(de)
        
        for wm, cb in self.desktop_page.wm_checks.items():
            if cb.isChecked():
                selected_desktops.append(wm)
        
        cfg.desktops = selected_desktops if selected_desktops else [DE_XFCE]
        
        dm = self.desktop_page.dm_combo.currentText()
        if dm.startswith(DM_AUTO):
            cfg.dm = DM_AUTO
        else:
            cfg.dm = dm
        
        cfg.autologin = self.desktop_page.autologin.isChecked()
        cfg.want_yay = self.desktop_page.want_yay.isChecked()
        cfg.copy_oh_my_bash = self.desktop_page.copy_oh_my_bash.isChecked()
        cfg.use_dracut = self.desktop_page.use_dracut.isChecked()
        cfg.use_local_packages_txt = self.desktop_page.use_local_packages_txt.isChecked()
        
        # Live user
        cfg.live_user = live_user_best_effort()
        
        # Restore point (only for BTRFS, existing partitions, no format)
        if (cfg.fs == "btrfs" and cfg.install_mode == MODE_EXISTING and 
            not cfg.format_root and cfg.root_part):
            cfg.restore_point_enabled = True
        
        return cfg


# ============================================================
# Entry point
# ============================================================
if __name__ == "__main__":
    if not is_root():
        print("ERROR: This installer must be run as root (sudo).")
        sys.exit(1)
    
    app = QApplication(sys.argv)
    app.setFont(QFont("Segoe UI", 10))
    
    # Set modern palette
    palette = QPalette()
    palette.setColor(QPalette.Window, QColor("#0a0e1a"))
    palette.setColor(QPalette.WindowText, QColor("#e0e6ff"))
    palette.setColor(QPalette.Base, QColor("#0d1422"))
    palette.setColor(QPalette.AlternateBase, QColor("#111827"))
    palette.setColor(QPalette.ToolTipBase, QColor("#1e293b"))
    palette.setColor(QPalette.ToolTipText, QColor("#e0e6ff"))
    palette.setColor(QPalette.Text, QColor("#e0e6ff"))
    palette.setColor(QPalette.Button, QColor("#1e293b"))
    palette.setColor(QPalette.ButtonText, QColor("#e0e6ff"))
    palette.setColor(QPalette.BrightText, QColor("#ffffff"))
    palette.setColor(QPalette.Highlight, QColor("#3b82f6"))
    palette.setColor(QPalette.HighlightedText, QColor("#ffffff"))
    app.setPalette(palette)
    
    app.setStyleSheet(MODERN_QSS)
    
    window = MainWindow()
    window.show()
    
    sys.exit(app.exec_())
